use std::collections::BTreeMap;

#[allow(warnings, clippy::pedantic, clippy::nursery)]
mod ddmetric_proto {
    include!(concat!(env!("OUT_DIR"), "/datadog.agentpayload.rs"));
}

use ddmetric_proto::{
    metric_payload::{MetricSeries, MetricType},
    MetricPayload,
};

use super::*;

const SERIES_ENDPOINT: &str = "/api/v2/series";

// unique identification of a Series
#[derive(Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]
struct SeriesContext {
    metric_name: String,
    tags: Vec<String>,
    r#type: i32,
}

// 1. filters out the metrics not generated by the Emitter
// 2. Aggregates the metric value across the different payloads.
//    This is necessary because we can't guarantee the payloads sent from
//    Agent/Vector will contain the exact same sets of data across a time period.
// 3. Normalizes the `host` value, and the `interval`
fn aggregate_normalize_series(
    payloads: &Vec<MetricPayload>,
) -> BTreeMap<SeriesContext, MetricSeries> {
    let mut aggregate = BTreeMap::new();

    for metric_payload in payloads {
        for serie in &metric_payload.series {
            // filter out the metrics we don't care about
            if !serie.metric.starts_with("foo_metric") {
                continue;
            }

            let ctx = SeriesContext {
                metric_name: serie.metric.clone(),
                tags: serie.tags.clone(),
                r#type: serie.r#type,
            };

            if !aggregate.contains_key(&ctx) {
                aggregate.insert(ctx, serie.clone());
                continue;
            }

            let existing = aggregate.get_mut(&ctx).unwrap();

            match serie.r#type() {
                MetricType::Unspecified => {
                    panic!("unspecified metric type")
                }
                MetricType::Count => {
                    existing.points.extend_from_slice(&serie.points);
                }
                MetricType::Rate => {
                    existing.points.extend_from_slice(&serie.points);
                }
                MetricType::Gauge => {
                    // last reported one wins
                    if let Some(point) = serie.points.last() {
                        let current = existing.points.last().unwrap();
                        if point.timestamp > current.timestamp && point.value > 0.0 {
                            existing.points = vec![point.clone()];
                        }
                    }
                }
            }
        }
    }

    // remove the timestamps and sum the points and normalize the other metadata
    for (_ctx, series) in &mut aggregate {
        // the Agent sets a non-zero default interval for all metric types.
        // Vector on ingest from the Agent, only sets the interval if it is a Rate.
        if series.r#type() != MetricType::Rate && series.interval != 0 {
            println!(
                "serie {:?} non-rate metric has interval set. Setting to zero.",
                _ctx.metric_name
            );
            series.interval = 0;
        }

        let mut value = 0.0;

        series.points.retain(|point| point.value > 0.0);

        for point in &mut series.points {
            point.timestamp = 0;

            if series.interval > 0 {
                value += point.value * series.interval as f64;
            } else {
                value += point.value;
            }
            point.value = 0.0;
        }
        if series.points.len() > 0 {
            series.points[0].value = value;
        }

        for resource in &mut series.resources {
            if resource.r#type == "host" {
                if resource.name.ends_with("-vector") {
                    resource
                        .name
                        .truncate(resource.name.len() - "-vector".len());
                }
            }
        }

        println!("{:?}", series);
    }

    aggregate
}

// runs assertions that each set of payloads should be true to regardless
// of the pipeline
fn common_series_assertions(series: &BTreeMap<SeriesContext, MetricSeries>) {
    // we should have received some metrics from the emitter
    assert!(series.len() > 0);
    println!("metric series received: {}", series.len());

    // specifically we should have received each of these
    let mut found = vec![
        (false, "rate"),
        (false, "gauge"),
        (false, "set"),
        (false, "histogram"),
    ];
    series.keys().for_each(|ctx| {
        found.iter_mut().for_each(|found| {
            if ctx
                .metric_name
                .starts_with(&format!("foo_metric.{}", found.1))
            {
                println!("received {}", found.1);
                found.0 = true;
            }
        });
    });

    found
        .iter()
        .for_each(|(found, mtype)| assert!(found, "Didn't receive metric type {}", *mtype));
}

async fn get_series_from_pipeline(address: String) -> BTreeMap<SeriesContext, MetricSeries> {
    println!("getting series payloads");
    let payloads =
        get_fakeintake_payloads::<FakeIntakeResponseRaw>(&address, SERIES_ENDPOINT).await;

    println!("unpacking payloads");
    let payloads = unpack_proto_payloads::<MetricPayload>(&payloads);

    println!("aggregating payloads");
    let series = aggregate_normalize_series(&payloads);

    common_series_assertions(&series);

    println!("{:?}", series.keys());

    series
}

pub(super) async fn validate() {
    println!("==== getting series data from agent-only pipeline ==== ");
    let agent_series = get_series_from_pipeline(fake_intake_agent_address()).await;

    println!("==== getting series data from agent-vector pipeline ====");
    let vector_series = get_series_from_pipeline(fake_intake_vector_address()).await;

    assert_eq!(agent_series, vector_series);
}
