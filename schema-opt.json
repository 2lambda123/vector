{
  "description": "A complete Vector configuration.",
  "$ref": "#/definitions/vector::config::builder::ConfigBuilder",
  "definitions": {
    "vector::config::builder::ConfigBuilder": {
      "description": "A complete Vector configuration.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "api": {
              "description": "API options.",
              "default": {
                "enabled": false,
                "address": "127.0.0.1:8686",
                "playground": true
              },
              "$ref": "#/definitions/vector::config::api::Options"
            },
            "schema": {
              "description": "Schema options.",
              "default": {
                "enabled": false,
                "validation": false,
                "log_namespace": null
              },
              "$ref": "#/definitions/vector::config::schema::Options"
            },
            "enterprise": {
              "title": "Enterprise options for using Datadog's [Observability Pipelines][datadog_op].",
              "description": "[datadog_op]: https://www.datadoghq.com/product/observability-pipelines/",
              "default": null,
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "Enterprise options for using Datadog's [Observability Pipelines][datadog_op].",
                  "$ref": "#/definitions/vector::config::enterprise::Options"
                }
              ]
            },
            "healthchecks": {
              "description": "Healthcheck options.",
              "default": {
                "enabled": true,
                "require_healthy": false
              },
              "$ref": "#/definitions/vector::config::HealthcheckOptions"
            },
            "enrichment_tables": {
              "description": "All configured enrichment tables.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/vector::config::enrichment_table::EnrichmentTableOuter"
              }
            },
            "sources": {
              "description": "All configured sources.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/vector::config::source::SourceOuter"
              }
            },
            "sinks": {
              "description": "All configured sinks.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/vector::config::sink::SinkOuter<alloc::string::String>"
              }
            },
            "transforms": {
              "description": "All configured transforms.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/vector::config::transform::TransformOuter<alloc::string::String>"
              }
            },
            "tests": {
              "description": "All configured unit tests.",
              "default": [],
              "type": "array",
              "items": {
                "$ref": "#/definitions/vector::config::TestDefinition<alloc::string::String>"
              }
            },
            "provider": {
              "title": "Optional configuration provider to use.",
              "description": "Configuration providers allow sourcing configuration information from a source other than\n the typical configuration files that must be passed to Vector.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector::providers::Providers"
                }
              ]
            },
            "secret": {
              "description": "All configured secrets backends.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/vector::secrets::SecretBackends"
              }
            }
          }
        },
        {
          "description": "Global configuration options.",
          "default": {
            "data_dir": null
          },
          "$ref": "#/definitions/vector_core::config::global_options::GlobalOptions"
        }
      ]
    },
    "vector_core::config::global_options::GlobalOptions": {
      "description": "Global configuration options.",
      "default": {
        "data_dir": null
      },
      "type": "object",
      "properties": {
        "data_dir": {
          "title": "The directory used for persisting Vector state data.",
          "description": "This is the directory where Vector will store any state data, such as disk buffers, file\n checkpoints, and more.\n\nVector must have write permissions to this directory.",
          "default": "/var/lib/vector/",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "log_schema": {
          "title": "Default log schema for all events.",
          "description": "This is used if a component does not have its own specific log schema. All events use a log\n schema, whether or not the default is used, to assign event fields on incoming events.",
          "default": {
            "message_key": "message",
            "timestamp_key": "timestamp",
            "host_key": "host",
            "source_type_key": "source_type",
            "metadata_key": "metadata"
          },
          "$ref": "#/definitions/vector_core::config::log_schema::LogSchema"
        },
        "timezone": {
          "title": "The name of the timezone to apply to timestamp conversions that do not contain an explicit timezone.",
          "description": "The timezone name may be any name in the [TZ database][tzdb], or `local` to indicate system\n local time.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "$ref": "#/definitions/vector_common::datetime::TimeZone"
        },
        "proxy": {
          "title": "Proxy configuration.",
          "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "expire_metrics": {
          "title": "The amount of time, in seconds, that internal metrics will persist after having not been\n updated before they expire and are removed.",
          "description": "Not set by default, which allows all internal metrics to grow unbounded over time. If you\n have a configuration that emits many high-cardinality metrics, you may want to consider\n setting this to a value that ensures that metrics live long enough to be emitted and\n captured, but not so long that they continue to build up indefinitely, as this will consume\n a small amount of memory for each metric.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::Duration"
            }
          ]
        },
        "expire_metrics_secs": {
          "title": "The amount of time, in seconds, that internal metrics will persist after having not been\n updated before they expire and are removed.",
          "description": "Not set by default, which allows all internal metrics to grow unbounded over time. If you\n have a configuration that emits many high-cardinality metrics, you may want to consider\n setting this to a value that ensures that metrics live long enough to be emitted and\n captured, but not so long that they continue to build up indefinitely, as this will consume\n a small amount of memory for each metric.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "stdlib::PathBuf": {
      "description": "A file path.",
      "type": "string",
      "pattern": "(\\/.*|[a-zA-Z]:\\\\(?:([^<>:\"\\/\\\\|?*]*[^<>:\"\\/\\\\|?*.]\\\\|..\\\\)*([^<>:\"\\/\\\\|?*]*[^<>:\"\\/\\\\|?*.]\\\\?|..\\\\))?)"
    },
    "vector_core::config::log_schema::LogSchema": {
      "title": "Log schema.",
      "description": "A log schema is used by Vector not only to uniformly process the fields of an event, but also to\n specify which fields should hold speicifc data that is also set by Vector once an event is\n flowing through a topology.",
      "default": {
        "message_key": "message",
        "timestamp_key": "timestamp",
        "host_key": "host",
        "source_type_key": "source_type",
        "metadata_key": "metadata"
      },
      "type": "object",
      "properties": {
        "message_key": {
          "title": "The name of the event field to treat as the event message.",
          "description": "This would be the field that holds the raw message, such as a raw log line.",
          "default": "message",
          "type": "string"
        },
        "timestamp_key": {
          "description": "The name of the event field to treat as the event timestamp.",
          "default": "timestamp",
          "type": "string"
        },
        "host_key": {
          "title": "The name of the event field to treat as the host which sent the message.",
          "description": "This field will generally represent a real host, or container, that generated the message,\n but is somewhat source-dependent.",
          "default": "host",
          "type": "string"
        },
        "source_type_key": {
          "title": "The name of the event field to set the source identifier in.",
          "description": "This field will be set by the Vector source that the event was created in.",
          "default": "source_type",
          "type": "string"
        },
        "metadata_key": {
          "title": "The name of the event field to set the event metadata in.",
          "description": "Generally, this field will be set by Vector to hold event-specific metadata, such as\n annotations by the `remap` transform when an error or abort is encountered.",
          "default": "metadata",
          "type": "string"
        }
      }
    },
    "vector_common::datetime::TimeZone": {
      "title": "Timezone reference.",
      "description": "This can refer to any valid timezone as defined in the [TZ database][tzdb], or \"local\" which refers to the system local timezone.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
      "oneOf": [
        {
          "description": "System local timezone.",
          "const": "local",
          "_metadata": {
            "logical_name": "Local"
          }
        },
        {
          "title": "A named timezone.",
          "description": "Must be a valid name in the [TZ database][tzdb].\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "type": "string",
          "_metadata": {
            "logical_name": "Named"
          }
        }
      ]
    },
    "vector_core::config::proxy::ProxyConfig": {
      "title": "Proxy configuration.",
      "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Enables proxying support.",
          "default": true,
          "type": "boolean"
        },
        "http": {
          "title": "Proxy endpoint to use when proxying HTTP traffic.",
          "description": "Must be a valid URI string.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "format": "uri"
        },
        "https": {
          "title": "Proxy endpoint to use when proxying HTTPS traffic.",
          "description": "Must be a valid URI string.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "format": "uri"
        },
        "no_proxy": {
          "title": "A list of hosts to avoid proxying.",
          "description": "Multiple patterns are allowed:\n\n| Pattern             | Example match                                                               |\n | ------------------- | --------------------------------------------------------------------------- |\n | Domain names        | `**example.com**` matches requests to `**example.com**`                     |\n | Wildcard domains    | `**.example.com**` matches requests to `**example.com**` and its subdomains |\n | IP addresses        | `**127.0.0.1**` matches requests to `**127.0.0.1**`                         |\n | [CIDR][cidr] blocks | `**192.168.0.0/16**` matches requests to any IP addresses in this range     |\n | Splat               | `__*__` matches all hosts                                                   |\n\n[cidr]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "vector_core::config::AcknowledgementsConfig": {
      "description": "Configuration of acknowledgement behavior.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Enables end-to-end acknowledgements.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "stdlib::Duration": {
      "description": "An duration of time.",
      "type": "object",
      "required": [
        "nsecs",
        "secs"
      ],
      "properties": {
        "secs": {
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "nsecs": {
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        }
      }
    },
    "vector::config::api::Options": {
      "description": "API options.",
      "default": {
        "enabled": false,
        "address": "127.0.0.1:8686",
        "playground": true
      },
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Whether or not the API endpoint is available.",
          "default": false,
          "type": "boolean"
        },
        "address": {
          "description": "The address to listen on for the API endpoint.",
          "default": "127.0.0.1:8686",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::SocketAddr"
            }
          ]
        },
        "playground": {
          "description": "Whether or not to expose the GraphQL playground on the API endpoint.",
          "default": true,
          "type": "boolean"
        }
      }
    },
    "stdlib::SocketAddr": {
      "description": "An internet socket address, either IPv4 or IPv6.",
      "type": "string"
    },
    "vector::config::schema::Options": {
      "description": "Schema options.",
      "default": {
        "enabled": false,
        "validation": false,
        "log_namespace": null
      },
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Whether or not schema is enabled.",
          "default": false,
          "type": "boolean"
        },
        "validation": {
          "description": "Whether or not schema validation is enabled.",
          "default": false,
          "type": "boolean"
        },
        "log_namespace": {
          "description": "Whether or not to enable log namespacing.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "vector::config::enterprise::Options": {
      "title": "Enterprise options for using Datadog's [Observability Pipelines][datadog_op].",
      "description": "[datadog_op]: https://www.datadoghq.com/product/observability-pipelines/",
      "type": "object",
      "required": [
        "configuration_key"
      ],
      "properties": {
        "enabled": {
          "description": "Whether or not Observability Pipelines support is enabled.",
          "default": true,
          "type": "boolean"
        },
        "enable_logs_reporting": {
          "description": "Whether or not to report internal component logs to Observability Pipelines.",
          "default": true,
          "type": "boolean"
        },
        "site": {
          "title": "The Datadog [site][dd_site] to send data to.",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "default": null,
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "title": "The Datadog region to send data to.",
          "description": "This option is deprecated, and the `site` field should be used instead.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::common::datadog::Region"
            }
          ]
        },
        "endpoint": {
          "title": "The Datadog endpoint to send data to.",
          "description": "This is an advanced setting that is generally meant only for testing, and overrides both\n `site` and `region`.\n\nYou should prefer to set `site`.",
          "type": [
            "string",
            "null"
          ]
        },
        "api_key": {
          "title": "The Datadog [API key][api_key] to send data with.",
          "description": "[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "application_key": {
          "title": "The Datadog application key.",
          "description": "This is deprecated.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "configuration_key": {
          "description": "The configuration key for Observability Pipelines.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "reporting_interval_secs": {
          "description": "The amount of time, in seconds, between reporting host metrics to Observability Pipelines.",
          "default": 1.0,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "max_retries": {
          "description": "The maximum number of retries to report Vector's configuration to Observability Pipelines at startup.",
          "default": 4294967295,
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "proxy": {
          "title": "Proxy configuration.",
          "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
          "default": {
            "enabled": true,
            "http": null,
            "https": null
          },
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig"
        },
        "tags": {
          "description": "A map of additional tags for metrics sent to Observability Pipelines.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector::common::datadog::Region": {
      "description": "A Datadog region.",
      "oneOf": [
        {
          "description": "US region.",
          "const": "us",
          "_metadata": {
            "logical_name": "Us"
          }
        },
        {
          "description": "EU region.",
          "const": "eu",
          "_metadata": {
            "logical_name": "Eu"
          }
        }
      ]
    },
    "vector_common::sensitive_string::SensitiveString": {
      "description": "Wrapper for sensitive strings containing credentials",
      "type": "string",
      "_metadata": {
        "sensitive": true
      }
    },
    "vector::config::HealthcheckOptions": {
      "description": "Healthcheck options.",
      "default": {
        "enabled": true,
        "require_healthy": false
      },
      "type": "object",
      "properties": {
        "enabled": {
          "title": "Whether or not healthchecks are enabled for all sinks.",
          "description": "Can be overridden on a per-sink basis.",
          "type": "boolean"
        },
        "require_healthy": {
          "title": "Whether or not to require a sink to report as being healthy during startup.",
          "description": "When enabled and a sink reports not being healthy, Vector will exit during start-up.\n\nCan be alternatively set, and overridden by, the `--require-healthy` command-line flag.",
          "type": "boolean"
        }
      }
    },
    "vector_common::config::ComponentKey": {
      "description": "Component identifier.",
      "type": "string"
    },
    "vector::config::enrichment_table::EnrichmentTableOuter": {
      "description": "Fully resolved enrichment table component.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "description": "Configurable enrichment tables in Vector.",
          "$ref": "#/definitions/vector::enrichment_tables::EnrichmentTables"
        }
      ]
    },
    "vector::enrichment_tables::EnrichmentTables": {
      "description": "Configurable enrichment tables in Vector.",
      "oneOf": [
        {
          "description": "File.",
          "allOf": [
            {
              "description": "Configuration for the `file` enrichment table.",
              "$ref": "#/definitions/vector::enrichment_tables::file::FileConfig",
              "_metadata": {
                "component_type": "enrichment_table"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "file"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "File"
          }
        },
        {
          "description": "GeoIP.",
          "allOf": [
            {
              "description": "Configuration for the `geoip` enrichment table.",
              "$ref": "#/definitions/vector::enrichment_tables::geoip::GeoipConfig",
              "_metadata": {
                "component_type": "enrichment_table"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "geoip"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Geoip"
          }
        }
      ]
    },
    "vector::enrichment_tables::file::FileConfig": {
      "description": "Configuration for the `file` enrichment table.",
      "type": "object",
      "required": [
        "file"
      ],
      "properties": {
        "file": {
          "description": "File-specific settings.",
          "$ref": "#/definitions/vector::enrichment_tables::file::FileSettings"
        },
        "schema": {
          "title": "Key/value pairs representing mapped log field names and types.",
          "description": "This is used to coerce log fields from strings into their proper types. The available types are listed in the `Types` list below.\n\nTimestamp coercions need to be prefaced with `timestamp|`, for example `\"timestamp|%F\"`. Timestamp specifiers can use either of the following:\n\n1. One of the built-in-formats listed in the `Timestamp Formats` table below.\n 2. The [time format specifiers][chrono_fmt] from Rust’s `chrono` library.\n\n### Types\n\n- **`bool`**\n - **`string`**\n - **`float`**\n - **`integer`**\n - **`date`**\n - **`timestamp`** (see the table below for formats)\n\n### Timestamp Formats\n\n| Format               | Description                                                                      | Example                          |\n |----------------------|----------------------------------------------------------------------------------|----------------------------------|\n | `%F %T`              | `YYYY-MM-DD HH:MM:SS`                                                            | `2020-12-01 02:37:54`            |\n | `%v %T`              | `DD-Mmm-YYYY HH:MM:SS`                                                           | `01-Dec-2020 02:37:54`           |\n | `%FT%T`              | [ISO 8601][iso8601]/[RFC 3339][rfc3339], without time zone                       | `2020-12-01T02:37:54`            |\n | `%FT%TZ`             | [ISO 8601][iso8601]/[RFC 3339][rfc3339], UTC                                     | `2020-12-01T09:37:54Z`           |\n | `%+`                 | [ISO 8601][iso8601]/[RFC 3339][rfc3339], UTC, with time zone                     | `2020-12-01T02:37:54-07:00`      |\n | `%a, %d %b %Y %T`    | [RFC 822][rfc822]/[RFC 2822][rfc2822], without time zone                         | `Tue, 01 Dec 2020 02:37:54`      |\n | `%a %b %e %T %Y`     | [ctime][ctime] format                                                            | `Tue Dec 1 02:37:54 2020`        |\n | `%s`                 | [UNIX timestamp][unix_ts]                                                        | `1606790274`                     |\n | `%a %d %b %T %Y`     | [date][date] command, without time zone                                          | `Tue 01 Dec 02:37:54 2020`       |\n | `%a %d %b %T %Z %Y`  | [date][date] command, with time zone                                             | `Tue 01 Dec 02:37:54 PST 2020`   |\n | `%a %d %b %T %z %Y`  | [date][date] command, with numeric time zone                                     | `Tue 01 Dec 02:37:54 -0700 2020` |\n | `%a %d %b %T %#z %Y` | [date][date] command, with numeric time zone (minutes can be missing or present) | `Tue 01 Dec 02:37:54 -07 2020`   |\n\n[date]: https://man7.org/linux/man-pages/man1/date.1.html\n [ctime]: https://www.cplusplus.com/reference/ctime\n [unix_ts]: https://en.wikipedia.org/wiki/Unix_time\n [rfc822]: https://tools.ietf.org/html/rfc822#section-5\n [rfc2822]: https://tools.ietf.org/html/rfc2822#section-3.3\n [iso8601]: https://en.wikipedia.org/wiki/ISO_8601\n [rfc3339]: https://tools.ietf.org/html/rfc3339\n [chrono_fmt]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "_metadata": {
        "component_type": "enrichment_table"
      }
    },
    "vector::enrichment_tables::file::FileSettings": {
      "description": "File-specific settings.",
      "type": "object",
      "required": [
        "encoding",
        "path"
      ],
      "properties": {
        "path": {
          "title": "The path of the enrichment table file.",
          "description": "Currently, only [CSV][csv] files are supported.\n\n[csv]: https://en.wikipedia.org/wiki/Comma-separated_values",
          "$ref": "#/definitions/stdlib::PathBuf"
        },
        "encoding": {
          "description": "File encoding options.",
          "$ref": "#/definitions/vector::enrichment_tables::file::Encoding"
        }
      }
    },
    "vector::enrichment_tables::file::Encoding": {
      "description": "File encoding options.",
      "oneOf": [
        {
          "description": "Comma-separated values.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "include_headers": {
              "title": "Whether or not the file contains column headers.",
              "description": "When set to `true`, the first row of the CSV file will be read as the header row, and\n the values will be used for the names of each column. This is the default behavior.\n\nWhen set to `false`, columns are referred to by their numerical index.",
              "default": true,
              "type": "boolean"
            },
            "delimiter": {
              "description": "The delimiter used to separate fields in each row of the CSV file.",
              "default": ",",
              "type": "string",
              "maxLength": 1,
              "minLength": 1
            },
            "type": {
              "description": "Comma-separated values.",
              "const": "csv",
              "_metadata": {
                "logical_name": "Csv"
              }
            }
          },
          "_metadata": {
            "logical_name": "Csv"
          }
        }
      ]
    },
    "vector::enrichment_tables::geoip::GeoipConfig": {
      "description": "Configuration for the `geoip` enrichment table.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "title": "Path to the [MaxMind GeoIP2][geoip2] or [GeoLite2 binary city database file][geolite2]\n (**GeoLite2-City.mmdb**).",
          "description": "Other databases, such as the country database, are not supported.\n\n[geoip2]: https://dev.maxmind.com/geoip/geoip2/downloadable\n [geolite2]: https://dev.maxmind.com/geoip/geoip2/geolite2/#Download_Access",
          "type": "string"
        },
        "locale": {
          "title": "The locale to use when querying the database.",
          "description": "MaxMind includes localized versions of some of the fields within their database, such as\n country name. This setting can control which of those localized versions are returned by the\n transform.\n\nMore information on which portions of the geolocation data are localized, and what languages\n are available, can be found [here][locale_docs].\n\n[locale_docs]: https://support.maxmind.com/hc/en-us/articles/4414877149467-IP-Geolocation-Data#h_01FRRGRYTGZB29ERDBZCX3MR8Q",
          "default": "en",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "enrichment_table"
      }
    },
    "vector::config::source::SourceOuter": {
      "description": "Fully resolved source component.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "proxy": {
              "title": "Proxy configuration.",
              "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig"
            }
          }
        },
        {
          "description": "Configurable sources in Vector.",
          "$ref": "#/definitions/vector::sources::Sources"
        }
      ]
    },
    "vector::sources::Sources": {
      "description": "Configurable sources in Vector.",
      "oneOf": [
        {
          "description": "AMQP.",
          "allOf": [
            {
              "title": "Configuration for the `amqp` source.",
              "description": "Supports AMQP version 0.9.1",
              "$ref": "#/definitions/vector::sources::amqp::AmqpSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "amqp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Amqp"
          }
        },
        {
          "description": "Apache HTTP Server (HTTPD) Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `apache_metrics` source.",
              "$ref": "#/definitions/vector::sources::apache_metrics::ApacheMetricsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "apache_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "ApacheMetrics"
          }
        },
        {
          "description": "AWS ECS Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_ecs_metrics` source.",
              "$ref": "#/definitions/vector::sources::aws_ecs_metrics::AwsEcsMetricsSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_ecs_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsEcsMetrics"
          }
        },
        {
          "description": "AWS Kinesis Firehose.",
          "allOf": [
            {
              "description": "Configuration for the `aws_kinesis_firehose` source.",
              "$ref": "#/definitions/vector::sources::aws_kinesis_firehose::AwsKinesisFirehoseConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_kinesis_firehose"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsKinesisFirehose"
          }
        },
        {
          "description": "AWS S3.",
          "allOf": [
            {
              "description": "Configuration for the `aws_s3` source.",
              "default": {
                "region": null,
                "endpoint": null,
                "compression": "auto",
                "strategy": "sqs",
                "sqs": null,
                "assume_role": null,
                "auth": {
                  "load_timeout_secs": null
                },
                "multiline": null,
                "acknowledgements": {
                  "enabled": null
                },
                "tls_options": null
              },
              "$ref": "#/definitions/vector::sources::aws_s3::AwsS3Config",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_s3"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsS3"
          }
        },
        {
          "description": "AWS SQS.",
          "allOf": [
            {
              "description": "Configuration for the `aws_sqs` source.",
              "$ref": "#/definitions/vector::sources::aws_sqs::config::AwsSqsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_sqs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsSqs"
          }
        },
        {
          "description": "Datadog Agent.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_agent` source.",
              "$ref": "#/definitions/vector::sources::datadog_agent::DatadogAgentConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "datadog_agent"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DatadogAgent"
          }
        },
        {
          "description": "Demo logs.",
          "allOf": [
            {
              "description": "Configuration for the `demo_logs` source.",
              "default": {
                "interval": 1.0,
                "count": 9223372036854775807,
                "format": "json",
                "framing": {
                  "method": "bytes"
                },
                "decoding": {
                  "codec": "bytes"
                },
                "log_namespace": null
              },
              "$ref": "#/definitions/vector::sources::demo_logs::DemoLogsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "demo_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DemoLogs"
          }
        },
        {
          "description": "DNSTAP.",
          "allOf": [
            {
              "description": "Configuration for the `dnstap` source.",
              "$ref": "#/definitions/vector::sources::dnstap::DnstapConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "dnstap"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Dnstap"
          }
        },
        {
          "description": "Docker Logs.",
          "allOf": [
            {
              "description": "Configuration for the `docker_logs` source.",
              "default": {
                "host_key": "host",
                "docker_host": null,
                "exclude_containers": null,
                "include_containers": null,
                "include_labels": null,
                "include_images": null,
                "partial_event_marker_field": "_partial",
                "auto_partial_merge": true,
                "retry_backoff_secs": 2,
                "multiline": null,
                "tls": null
              },
              "$ref": "#/definitions/vector::sources::docker_logs::DockerLogsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "docker_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DockerLogs"
          }
        },
        {
          "description": "EventStoreDB Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `eventstoredb_metrics` source.",
              "$ref": "#/definitions/vector::sources::eventstoredb_metrics::EventStoreDbConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "eventstoredb_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "EventstoredbMetrics"
          }
        },
        {
          "description": "Exec.",
          "allOf": [
            {
              "description": "Configuration for the `exec` source.",
              "default": {
                "mode": "scheduled",
                "scheduled": {
                  "exec_interval_secs": 60
                },
                "streaming": null,
                "command": [
                  "echo",
                  "Hello World!"
                ],
                "working_directory": null,
                "include_stderr": true,
                "maximum_buffer_size_bytes": 1000000,
                "framing": null,
                "decoding": {
                  "codec": "bytes"
                }
              },
              "$ref": "#/definitions/vector::sources::exec::ExecConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "exec"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Exec"
          }
        },
        {
          "description": "File.",
          "allOf": [
            {
              "description": "Configuration for the `file` source.",
              "default": {
                "include": [],
                "exclude": [],
                "file_key": "file",
                "start_at_beginning": null,
                "ignore_checkpoints": null,
                "read_from": null,
                "ignore_older_secs": null,
                "max_line_bytes": 102400,
                "host_key": null,
                "data_dir": null,
                "offset_key": null,
                "glob_minimum_cooldown_ms": 1000,
                "fingerprint": {
                  "strategy": "checksum",
                  "bytes": null,
                  "ignored_header_bytes": 0,
                  "lines": 1
                },
                "ignore_not_found": false,
                "message_start_indicator": null,
                "multi_line_timeout": 1000,
                "multiline": null,
                "max_read_bytes": 2048,
                "oldest_first": false,
                "remove_after_secs": null,
                "line_delimiter": "\n",
                "encoding": null,
                "acknowledgements": {
                  "enabled": null
                }
              },
              "$ref": "#/definitions/vector::sources::file::FileConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "file"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "File"
          }
        },
        {
          "description": "File descriptor.",
          "allOf": [
            {
              "description": "Configuration for the `file_descriptor` source.",
              "$ref": "#/definitions/vector::sources::file_descriptors::file_descriptor::FileDescriptorSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "file_descriptor"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "FileDescriptor"
          }
        },
        {
          "description": "Fluent.",
          "allOf": [
            {
              "description": "Configuration for the `fluent` source.",
              "$ref": "#/definitions/vector::sources::fluent::FluentConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "fluent"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Fluent"
          }
        },
        {
          "description": "GCP Pub/Sub.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_pubsub` source.",
              "$ref": "#/definitions/vector::sources::gcp_pubsub::PubsubConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gcp_pubsub"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "GcpPubsub"
          }
        },
        {
          "description": "Heroku Logs.",
          "allOf": [
            {
              "description": "Configuration for `heroku_logs` source.",
              "$ref": "#/definitions/vector::sources::heroku_logs::LogplexConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "heroku_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "HerokuLogs"
          }
        },
        {
          "description": "Host Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `host_metrics` source.",
              "$ref": "#/definitions/vector::sources::host_metrics::HostMetricsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "host_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "HostMetrics"
          }
        },
        {
          "description": "HTTP.",
          "allOf": [
            {
              "description": "Configuration for the `http` source.",
              "$ref": "#/definitions/vector::sources::http::SimpleHttpConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "http"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Http"
          }
        },
        {
          "description": "HTTP Scrape.",
          "allOf": [
            {
              "description": "Configuration for the `http_scrape` source.",
              "$ref": "#/definitions/vector::sources::http_scrape::scrape::HttpScrapeConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "http_scrape"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "HttpScrape"
          }
        },
        {
          "description": "Internal Logs.",
          "allOf": [
            {
              "description": "Configuration for the `internal_logs` source.",
              "$ref": "#/definitions/vector::sources::internal_logs::InternalLogsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "internal_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "InternalLogs"
          }
        },
        {
          "description": "Internal Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `internal_metrics` source.",
              "default": {
                "scrape_interval_secs": 2.0,
                "tags": {
                  "host_key": null,
                  "pid_key": null
                },
                "namespace": null
              },
              "$ref": "#/definitions/vector::sources::internal_metrics::InternalMetricsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "internal_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "InternalMetrics"
          }
        },
        {
          "description": "Journald.",
          "allOf": [
            {
              "description": "Configuration for the `journald` source.",
              "default": {
                "since_now": null,
                "current_boot_only": null,
                "units": [],
                "include_units": [],
                "exclude_units": [],
                "include_matches": {},
                "exclude_matches": {},
                "data_dir": null,
                "batch_size": null,
                "journalctl_path": null,
                "journal_directory": null,
                "acknowledgements": {
                  "enabled": null
                },
                "remap_priority": false
              },
              "$ref": "#/definitions/vector::sources::journald::JournaldConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "journald"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Journald"
          }
        },
        {
          "description": "Kafka.",
          "allOf": [
            {
              "description": "Configuration for the `kafka` source.",
              "$ref": "#/definitions/vector::sources::kafka::KafkaSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "kafka"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Kafka"
          }
        },
        {
          "description": "Kubernetes Logs.",
          "allOf": [
            {
              "description": "Configuration for the `kubernetes_logs` source.",
              "default": {
                "extra_label_selector": "",
                "extra_namespace_label_selector": "",
                "self_node_name": "${VECTOR_SELF_NODE_NAME}",
                "extra_field_selector": "",
                "auto_partial_merge": true,
                "data_dir": null,
                "pod_annotation_fields": {
                  "pod_name": "kubernetes.pod_name",
                  "pod_namespace": "kubernetes.pod_namespace",
                  "pod_uid": "kubernetes.pod_uid",
                  "pod_ip": "kubernetes.pod_ip",
                  "pod_ips": "kubernetes.pod_ips",
                  "pod_labels": "kubernetes.pod_labels",
                  "pod_annotations": "kubernetes.pod_annotations",
                  "pod_node_name": "kubernetes.pod_node_name",
                  "pod_owner": "kubernetes.pod_owner",
                  "container_name": "kubernetes.container_name",
                  "container_id": "kubernetes.container_id",
                  "container_image": "kubernetes.container_image"
                },
                "namespace_annotation_fields": {
                  "namespace_labels": "kubernetes.namespace_labels"
                },
                "node_annotation_fields": {
                  "node_labels": "kubernetes.node_labels"
                },
                "exclude_paths_glob_patterns": [
                  "**/*.gz",
                  "**/*.tmp"
                ],
                "max_read_bytes": 2048,
                "max_line_bytes": 32768,
                "fingerprint_lines": 1,
                "glob_minimum_cooldown_ms": 60000,
                "ingestion_timestamp_field": null,
                "timezone": null,
                "kube_config_file": null,
                "delay_deletion_ms": 60000
              },
              "$ref": "#/definitions/vector::sources::kubernetes_logs::Config",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "kubernetes_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "KubernetesLogs"
          }
        },
        {
          "description": "Logstash.",
          "allOf": [
            {
              "description": "Configuration for the `logstash` source.",
              "$ref": "#/definitions/vector::sources::logstash::LogstashConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "logstash"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Logstash"
          }
        },
        {
          "description": "MongoDB Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `mongodb_metrics` source.",
              "$ref": "#/definitions/vector::sources::mongodb_metrics::MongoDbMetricsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "mongodb_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "MongodbMetrics"
          }
        },
        {
          "description": "NATS.",
          "allOf": [
            {
              "description": "Configuration for the `nats` source.",
              "$ref": "#/definitions/vector::sources::nats::NatsSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "nats"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Nats"
          }
        },
        {
          "description": "NGINX Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `nginx_metrics` source.",
              "$ref": "#/definitions/vector::sources::nginx_metrics::NginxMetricsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "nginx_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "NginxMetrics"
          }
        },
        {
          "description": "OpenTelemetry.",
          "allOf": [
            {
              "description": "Configuration for the `opentelemetry` source.",
              "$ref": "#/definitions/vector::sources::opentelemetry::OpentelemetryConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "opentelemetry"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Opentelemetry"
          }
        },
        {
          "description": "PostgreSQL Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `postgresql_metrics` source.",
              "default": {
                "endpoints": [],
                "include_databases": null,
                "exclude_databases": null,
                "scrape_interval_secs": 15,
                "namespace": "postgresql",
                "tls": null
              },
              "$ref": "#/definitions/vector::sources::postgresql_metrics::PostgresqlMetricsConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "postgresql_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "PostgresqlMetrics"
          }
        },
        {
          "description": "Prometheus Scrape.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_scrape` source.",
              "$ref": "#/definitions/vector::sources::prometheus::scrape::PrometheusScrapeConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "prometheus_scrape"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "PrometheusScrape"
          }
        },
        {
          "description": "Prometheus Remote Write.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_remote_write` source.",
              "$ref": "#/definitions/vector::sources::prometheus::remote_write::PrometheusRemoteWriteConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "prometheus_remote_write"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "PrometheusRemoteWrite"
          }
        },
        {
          "description": "Redis.",
          "allOf": [
            {
              "description": "Configuration for the `redis` source.",
              "$ref": "#/definitions/vector::sources::redis::RedisSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "redis"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Redis"
          }
        },
        {
          "description": "Socket.",
          "allOf": [
            {
              "description": "Configuration for the `socket` source.",
              "$ref": "#/definitions/vector::sources::socket::SocketConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "socket"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Socket"
          }
        },
        {
          "description": "Splunk HEC.",
          "allOf": [
            {
              "description": "Configuration for the `splunk_hec` source.",
              "default": {
                "address": "0.0.0.0:8088",
                "token": null,
                "valid_tokens": null,
                "store_hec_token": false,
                "tls": null,
                "acknowledgements": {
                  "enabled": null,
                  "max_pending_acks": 10000000,
                  "max_number_of_ack_channels": 1000000,
                  "max_pending_acks_per_channel": 1000000,
                  "ack_idle_cleanup": false,
                  "max_idle_time": 300
                }
              },
              "$ref": "#/definitions/vector::sources::splunk_hec::SplunkConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "splunk_hec"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "SplunkHec"
          }
        },
        {
          "description": "Statsd.",
          "allOf": [
            {
              "description": "Configuration for the `statsd` source.",
              "$ref": "#/definitions/vector::sources::statsd::StatsdConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "statsd"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Statsd"
          }
        },
        {
          "description": "Stdin.",
          "allOf": [
            {
              "description": "Configuration for the `stdin` source.",
              "default": {
                "max_length": 102400,
                "host_key": null,
                "framing": null,
                "decoding": {
                  "codec": "bytes"
                }
              },
              "$ref": "#/definitions/vector::sources::file_descriptors::stdin::StdinConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "stdin"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Stdin"
          }
        },
        {
          "description": "Syslog.",
          "allOf": [
            {
              "description": "Configuration for the `syslog` source.",
              "$ref": "#/definitions/vector::sources::syslog::SyslogConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "syslog"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Syslog"
          }
        },
        {
          "description": "Unit test.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test` source.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "unit_test"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "UnitTest"
          }
        },
        {
          "description": "Unit test stream.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test_stream` source.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestStreamSourceConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "unit_test_stream"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "UnitTestStream"
          }
        },
        {
          "description": "Vector.",
          "allOf": [
            {
              "description": "Configuration for the `vector` source.",
              "$ref": "#/definitions/vector::sources::vector::VectorConfig",
              "_metadata": {
                "component_type": "source"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "vector"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Vector"
          }
        }
      ]
    },
    "vector::sources::amqp::AmqpSourceConfig": {
      "title": "Configuration for the `amqp` source.",
      "description": "Supports AMQP version 0.9.1",
      "type": "object",
      "required": [
        "connection"
      ],
      "properties": {
        "queue": {
          "description": "The name of the queue to consume.",
          "default": "vector",
          "type": "string"
        },
        "consumer": {
          "description": "The identifier for the consumer.",
          "default": "vector",
          "type": "string"
        },
        "connection": {
          "description": "Connection options for `AMQP` source.",
          "$ref": "#/definitions/vector::amqp::AmqpConfig"
        },
        "routing_key_field": {
          "description": "The `AMQP` routing key.",
          "default": "routing",
          "type": "string"
        },
        "exchange_key": {
          "description": "The `AMQP` exchange key.",
          "default": "exchange",
          "type": "string"
        },
        "offset_key": {
          "description": "The `AMQP` offset key.",
          "default": "offset",
          "type": "string"
        },
        "log_namespace": {
          "description": "The namespace to use. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::amqp::AmqpConfig": {
      "description": "Connection options for `AMQP`.",
      "type": "object",
      "required": [
        "connection_string"
      ],
      "properties": {
        "connection_string": {
          "title": "URI for the `AMQP` server.",
          "description": "Format: amqp://<user>:<password>@<host>:<port>/<vhost>?timeout=<seconds>",
          "type": "string"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        }
      }
    },
    "vector_core::tls::settings::TlsConfig": {
      "description": "Standard TLS options.",
      "type": "object",
      "properties": {
        "verify_certificate": {
          "title": "Enables certificate verification.",
          "description": "If enabled, certificates must be valid in terms of not being expired, as well as being issued by a trusted\n issuer. This verification operates in a hierarchical manner, checking that not only the leaf certificate (the\n certificate presented by the client/server) is valid, but also that the issuer of that certificate is valid, and\n so on until reaching a root certificate.\n\nRelevant for both incoming and outgoing connections.\n\nDo NOT set this to `false` unless you understand the risks of not verifying the validity of certificates.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "verify_hostname": {
          "title": "Enables hostname verification.",
          "description": "If enabled, the hostname used to connect to the remote host must be present in the TLS certificate presented by\n the remote host, either as the Common Name or as an entry in the Subject Alternative Name extension.\n\nOnly relevant for outgoing connections.\n\nDo NOT set this to `false` unless you understand the risks of not verifying the remote hostname.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "alpn_protocols": {
          "title": "Sets the list of supported ALPN protocols.",
          "description": "Declare the supported ALPN protocols, which are used during negotiation with peer. Prioritized in the order\n they are defined.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "ca_file": {
          "title": "Absolute path to an additional CA certificate file.",
          "description": "The certficate must be in the DER or PEM (X.509) format. Additionally, the certificate can be provided as an inline string in PEM format.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "crt_file": {
          "title": "Absolute path to a certificate file used to identify this server.",
          "description": "The certificate must be in DER, PEM (X.509), or PKCS#12 format. Additionally, the certificate can be provided as\n an inline string in PEM format.\n\nIf this is set, and is not a PKCS#12 archive, `key_file` must also be set.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "key_file": {
          "title": "Absolute path to a private key file used to identify this server.",
          "description": "The key must be in DER or PEM (PKCS#8) format. Additionally, the key can be provided as an inline string in PEM format.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "key_pass": {
          "title": "Passphrase used to unlock the encrypted key file.",
          "description": "This has no effect unless `key_file` is set.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "codecs::decoding::FramingConfig": {
      "description": "Configuration for building a `Framer`.",
      "oneOf": [
        {
          "description": "Configures the `BytesDecoder`.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "const": "bytes"
            }
          },
          "_metadata": {
            "logical_name": "Bytes"
          }
        },
        {
          "description": "Configures the `CharacterDelimitedDecoder`.",
          "type": "object",
          "required": [
            "character_delimited",
            "method"
          ],
          "properties": {
            "character_delimited": {
              "description": "Options for the character delimited decoder.",
              "$ref": "#/definitions/codecs::decoding::framing::character_delimited::CharacterDelimitedDecoderOptions"
            },
            "method": {
              "description": "Configures the `CharacterDelimitedDecoder`.",
              "const": "character_delimited",
              "_metadata": {
                "logical_name": "CharacterDelimited"
              }
            }
          },
          "_metadata": {
            "logical_name": "CharacterDelimited"
          }
        },
        {
          "description": "Configures the `LengthDelimitedDecoder`.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "const": "length_delimited"
            }
          },
          "_metadata": {
            "logical_name": "LengthDelimited"
          }
        },
        {
          "description": "Configures the `NewlineDelimitedDecoder`.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "newline_delimited": {
              "description": "Options for the newline delimited decoder.",
              "default": {},
              "$ref": "#/definitions/codecs::decoding::framing::newline_delimited::NewlineDelimitedDecoderOptions"
            },
            "method": {
              "description": "Configures the `NewlineDelimitedDecoder`.",
              "const": "newline_delimited",
              "_metadata": {
                "logical_name": "NewlineDelimited"
              }
            }
          },
          "_metadata": {
            "logical_name": "NewlineDelimited"
          }
        },
        {
          "description": "Configures the `OctetCountingDecoder`.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "octet_counting": {
              "description": "Options for the octet counting decoder.",
              "default": {},
              "$ref": "#/definitions/codecs::decoding::framing::octet_counting::OctetCountingDecoderOptions"
            },
            "method": {
              "description": "Configures the `OctetCountingDecoder`.",
              "const": "octet_counting",
              "_metadata": {
                "logical_name": "OctetCounting"
              }
            }
          },
          "_metadata": {
            "logical_name": "OctetCounting"
          }
        }
      ]
    },
    "codecs::decoding::framing::character_delimited::CharacterDelimitedDecoderOptions": {
      "description": "Options for building a `CharacterDelimitedDecoder`.",
      "type": "object",
      "required": [
        "delimiter"
      ],
      "properties": {
        "delimiter": {
          "description": "The character that delimits byte sequences.",
          "type": "number",
          "maximum": 255.0,
          "minimum": 0.0
        },
        "max_length": {
          "title": "The maximum length of the byte buffer.",
          "description": "This length does *not* include the trailing delimiter.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "codecs::decoding::framing::newline_delimited::NewlineDelimitedDecoderOptions": {
      "description": "Options for building a `NewlineDelimitedDecoder`.",
      "type": "object",
      "properties": {
        "max_length": {
          "title": "The maximum length of the byte buffer.",
          "description": "This length does *not* include the trailing delimiter.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "codecs::decoding::framing::octet_counting::OctetCountingDecoderOptions": {
      "description": "Options for building a `OctetCountingDecoder`.",
      "type": "object",
      "properties": {
        "max_length": {
          "description": "The maximum length of the byte buffer.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "codecs::decoding::DeserializerConfig": {
      "description": "Configuration for building a `Deserializer`.",
      "oneOf": [
        {
          "description": "Configures the `BytesDeserializer`.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "bytes"
            }
          },
          "_metadata": {
            "logical_name": "Bytes"
          }
        },
        {
          "description": "Configures the `JsonDeserializer`.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "json"
            }
          },
          "_metadata": {
            "logical_name": "Json"
          }
        },
        {
          "description": "Configures the `SyslogDeserializer`.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "syslog"
            }
          },
          "_metadata": {
            "logical_name": "Syslog"
          }
        },
        {
          "description": "Configures the `NativeDeserializer`.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "native"
            }
          },
          "_metadata": {
            "logical_name": "Native"
          }
        },
        {
          "description": "Configures the `NativeJsonDeserializer`.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "native_json"
            }
          },
          "_metadata": {
            "logical_name": "NativeJson"
          }
        },
        {
          "description": "Configures the `GelfDeserializer`.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "gelf"
            }
          },
          "_metadata": {
            "logical_name": "Gelf"
          }
        }
      ]
    },
    "vector::sources::apache_metrics::ApacheMetricsConfig": {
      "description": "Configuration for the `apache_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "description": "The list of `mod_status` endpoints to scrape metrics from.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "namespace": {
          "title": "The namespace of the metric.",
          "description": "Disabled if empty.",
          "default": "apache",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::aws_ecs_metrics::AwsEcsMetricsSourceConfig": {
      "description": "Configuration for the `aws_ecs_metrics` source.",
      "type": "object",
      "properties": {
        "endpoint": {
          "title": "Base URI of the task metadata endpoint.",
          "description": "If empty, the URI will be automatically discovered based on the latest version detected.\n\nBy default:\n - The version 2 endpoint base URI is `169.254.170.2/v2/`.\n - The version 3 endpoint base URI is stored in the environment variable `ECS_CONTAINER_METADATA_URI`.\n - The version 4 endpoint base URI is stored in the environment variable `ECS_CONTAINER_METADATA_URI_V4`.",
          "default": "http://169.254.170.2/v2",
          "type": "string"
        },
        "version": {
          "title": "The version of the task metadata endpoint to use.",
          "description": "If empty, the version is automatically discovered based on environment variables.\n\nBy default:\n - Version 4 is used if the environment variable `ECS_CONTAINER_METADATA_URI_V4` is defined.\n - Version 3 is used if the environment variable `ECS_CONTAINER_METADATA_URI_V4` is not defined, but the\n   environment variable `ECS_CONTAINER_METADATA_URI` _is_ defined.\n - Version 2 is used if neither of the environment variables `ECS_CONTAINER_METADATA_URI_V4` or\n   `ECS_CONTAINER_METADATA_URI` are defined.",
          "default": "v2",
          "$ref": "#/definitions/vector::sources::aws_ecs_metrics::Version"
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "namespace": {
          "title": "The namespace of the metric.",
          "description": "Disabled if empty.",
          "default": "awsecs",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::aws_ecs_metrics::Version": {
      "title": "Version of the AWS ECS task metadata endpoint to use.",
      "description": "More information about the different versions can be found\n (here)[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint.html].",
      "oneOf": [
        {
          "title": "Version 2.",
          "description": "More information about version 2 of the task metadata endpoint can be found\n (here)[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v2.html].",
          "const": "v2",
          "_metadata": {
            "logical_name": "V2"
          }
        },
        {
          "title": "Version 3.",
          "description": "More information about version 3 of the task metadata endpoint can be found\n (here)[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v3.html].",
          "const": "v3",
          "_metadata": {
            "logical_name": "V3"
          }
        },
        {
          "title": "Version 4.",
          "description": "More information about version 4 of the task metadata endpoint can be found\n (here)[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v4.html].",
          "const": "v4",
          "_metadata": {
            "logical_name": "V4"
          }
        }
      ]
    },
    "vector::sources::aws_kinesis_firehose::AwsKinesisFirehoseConfig": {
      "description": "Configuration for the `aws_kinesis_firehose` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "access_key": {
          "title": "An optional access key to authenticate requests against.",
          "description": "AWS Kinesis Firehose can be configured to pass along a user-configurable access key with each request. If\n configured, `access_key` should be set to the same value. Otherwise, all requests will be allowed.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "record_compression": {
          "title": "The compression scheme to use for decompressing records within the Firehose message.",
          "description": "Some services, like AWS CloudWatch Logs, will [compress the events with\n gzip](\\(urls.aws_cloudwatch_logs_firehose)), before sending them AWS Kinesis Firehose. This option can be used\n to automatically decompress them before forwarding them to the next component.\n\nNote that this is different from [Content encoding option](\\(urls.aws_kinesis_firehose_http_protocol)) of the\n Firehose HTTP endpoint destination. That option controls the content encoding of the entire HTTP request.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::aws_kinesis_firehose::Compression"
            }
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::aws_kinesis_firehose::Compression": {
      "description": "Compression scheme for records in a Firehose message.",
      "oneOf": [
        {
          "title": "Automatically attempt to determine the compression scheme.",
          "description": "Vector will try to determine the compression scheme of the object by looking at its file signature, also known\n as [magic bytes](\\(urls.magic_bytes)).\n\nGiven that determining the encoding using magic bytes is not a perfect check, if the record fails to decompress\n with the discovered format, the record will be forwarded as-is. Thus, if you know the records will always be\n gzip encoded (for example if they are coming from AWS CloudWatch Logs) then you should prefer to set `gzip` here\n to have Vector reject any records that are not-gziped.",
          "const": "auto",
          "_metadata": {
            "logical_name": "Auto"
          }
        },
        {
          "description": "Uncompressed.",
          "const": "none",
          "_metadata": {
            "logical_name": "None"
          }
        },
        {
          "description": "GZIP.",
          "const": "gzip",
          "_metadata": {
            "logical_name": "Gzip"
          }
        }
      ]
    },
    "vector_core::tls::settings::TlsEnableableConfig": {
      "description": "Configures the TLS options for incoming/outgoing connections.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "enabled": {
              "title": "Whether or not to require TLS for incoming/outgoing connections.",
              "description": "When enabled and used for incoming connections, an identity certificate is also required. See `tls.crt_file` for\n more information.",
              "type": [
                "boolean",
                "null"
              ]
            }
          }
        },
        {
          "description": "Standard TLS options.",
          "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
        }
      ]
    },
    "vector::sources::aws_s3::AwsS3Config": {
      "description": "Configuration for the `aws_s3` source.",
      "default": {
        "region": null,
        "endpoint": null,
        "compression": "auto",
        "strategy": "sqs",
        "sqs": null,
        "assume_role": null,
        "auth": {
          "load_timeout_secs": null
        },
        "multiline": null,
        "acknowledgements": {
          "enabled": null
        },
        "tls_options": null
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "compression": {
              "description": "The compression scheme used for decompressing objects retrieved from S3.",
              "$ref": "#/definitions/vector::sources::aws_s3::Compression"
            },
            "strategy": {
              "description": "The strategy to use to consume objects from S3.",
              "$ref": "#/definitions/vector::sources::aws_s3::Strategy"
            },
            "sqs": {
              "title": "Configuration options for SQS.",
              "description": "Only relevant when `strategy = \"sqs\"`.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector::sources::aws_s3::sqs::Config"
                }
              ]
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "multiline": {
              "title": "Multiline aggregation configuration.",
              "description": "If not specified, multiline aggregation is disabled.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector::sources::util::multiline_config::MultilineConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            },
            "tls_options": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::aws::region::RegionOrEndpoint": {
      "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
      "default": {
        "region": null,
        "endpoint": null
      },
      "type": "object",
      "properties": {
        "region": {
          "description": "The AWS region to use.",
          "type": [
            "string",
            "null"
          ]
        },
        "endpoint": {
          "description": "The API endpoint of the service.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::sources::aws_s3::Compression": {
      "description": "Compression scheme for objects retrieved from S3.",
      "oneOf": [
        {
          "title": "Automatically attempt to determine the compression scheme.",
          "description": "Vector will try to determine the compression scheme of the object from its: `Content-Encoding` and\n `Content-Type` metadata, as well as the key suffix (e.g. `.gz`).\n\nIt will fallback to 'none' if the compression scheme cannot be determined.",
          "const": "auto",
          "_metadata": {
            "logical_name": "Auto"
          }
        },
        {
          "description": "Uncompressed.",
          "const": "none",
          "_metadata": {
            "logical_name": "None"
          }
        },
        {
          "description": "GZIP.",
          "const": "gzip",
          "_metadata": {
            "logical_name": "Gzip"
          }
        },
        {
          "description": "ZSTD.",
          "const": "zstd",
          "_metadata": {
            "logical_name": "Zstd"
          }
        }
      ]
    },
    "vector::sources::aws_s3::Strategy": {
      "description": "Strategies for consuming objects from S3.",
      "oneOf": [
        {
          "title": "Consumes objects by processing bucket notification events sent to an [AWS SQS queue][aws_sqs].",
          "description": "[aws_sqs]: https://aws.amazon.com/sqs/",
          "const": "sqs",
          "_metadata": {
            "logical_name": "Sqs"
          }
        }
      ]
    },
    "vector::sources::aws_s3::sqs::Config": {
      "description": "SQS configuration options.",
      "type": "object",
      "required": [
        "queue_url"
      ],
      "properties": {
        "queue_url": {
          "description": "The URL of the SQS queue to poll for bucket notifications.",
          "type": "string"
        },
        "poll_secs": {
          "title": "How long to wait while polling the queue for new messages, in seconds.",
          "description": "Generally should not be changed unless instructed to do so, as if messages are available, they will always be\n consumed, regardless of the value of `poll_secs`.",
          "default": 15,
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "visibility_timeout_secs": {
          "title": "The visibility timeout to use for messages, in secords.",
          "description": "This controls how long a message is left unavailable after Vector receives it. If Vector receives a message, and\n takes longer than `visibility_timeout_secs` to process and delete the message from the queue, it will be made reavailable for another consumer.\n\nThis can happen if, for example, if Vector crashes between consuming a message and deleting it.",
          "default": 300,
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "delete_message": {
          "title": "Whether to delete the message once Vector processes it.",
          "description": "It can be useful to set this to `false` to debug or during initial Vector setup.",
          "default": true,
          "type": "boolean"
        },
        "client_concurrency": {
          "title": "Number of concurrent tasks to create for polling the queue for messages.",
          "description": "Defaults to the number of available CPUs on the system.\n\nShould not typically need to be changed, but it can sometimes be beneficial to raise this value when there is a\n high rate of messages being pushed into the queue and the objects being fetched are small. In these cases,\n Vector may not fully utilize system resources without fetching more messages per second, as the SQS message\n consumption rate affects the S3 object retrieval rate.",
          "default": 10,
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "tls_options": {
          "description": "Standard TLS options.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        }
      }
    },
    "vector::aws::auth::AwsAuthentication": {
      "description": "Configuration of the authentication strategy for interacting with AWS services.",
      "oneOf": [
        {
          "description": "Authenticate using a fixed access key and secret pair.",
          "type": "object",
          "required": [
            "access_key_id",
            "secret_access_key"
          ],
          "properties": {
            "access_key_id": {
              "description": "The AWS access key ID.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            },
            "secret_access_key": {
              "description": "The AWS secret access key.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          },
          "_metadata": {
            "logical_name": "AccessKey"
          }
        },
        {
          "title": "Authenticate using credentials stored in a file.",
          "description": "Additionally, the specific credential profile to use can be set.",
          "type": "object",
          "required": [
            "credentials_file"
          ],
          "properties": {
            "credentials_file": {
              "description": "Path to the credentials file.",
              "type": "string"
            },
            "profile": {
              "description": "The credentials profile to use.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "_metadata": {
            "logical_name": "File"
          }
        },
        {
          "description": "Assume the given role ARN.",
          "type": "object",
          "required": [
            "assume_role"
          ],
          "properties": {
            "assume_role": {
              "description": "The ARN of the role to assume.",
              "type": "string"
            },
            "load_timeout_secs": {
              "description": "Timeout for assuming the role, in seconds.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "region": {
              "title": "The AWS region to send STS requests to.",
              "description": "If not set, this will default to the configured region\n for the service itself.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "_metadata": {
            "logical_name": "Role"
          }
        },
        {
          "description": "Default authentication strategy which tries a variety of substrategies in a one-after-the-other fashion.",
          "type": "object",
          "properties": {
            "load_timeout_secs": {
              "description": "Timeout for successfully loading any credentials, in seconds.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            }
          },
          "_metadata": {
            "logical_name": "Default"
          }
        }
      ]
    },
    "vector::sources::util::multiline_config::MultilineConfig": {
      "description": "Configuration of multi-line aggregation.",
      "type": "object",
      "required": [
        "condition_pattern",
        "mode",
        "start_pattern",
        "timeout_ms"
      ],
      "properties": {
        "start_pattern": {
          "description": "Regular expression pattern that is used to match the start of a new message.",
          "type": "string"
        },
        "condition_pattern": {
          "title": "Regular expression pattern that is used to determine whether or not more lines should be read.",
          "description": "This setting must be configured in conjunction with `mode`.",
          "type": "string"
        },
        "mode": {
          "title": "Aggregation mode.",
          "description": "This setting must be configured in conjunction with `condition_pattern`.",
          "$ref": "#/definitions/vector::line_agg::Mode"
        },
        "timeout_ms": {
          "title": "The maximum amount of time to wait for the next additional line, in milliseconds.",
          "description": "Once this timeout is reached, the buffered message is guaranteed to be flushed, even if incomplete.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::line_agg::Mode": {
      "description": "Mode of operation of the line aggregator.",
      "oneOf": [
        {
          "title": "All consecutive lines matching this pattern are included in the group.",
          "description": "The first line (the line that matched the start pattern) does not need to match the `ContinueThrough` pattern.\n\nThis is useful in cases such as a Java stack trace, where some indicator in the line (such as leading\n whitespace) indicates that it is an extension of the proceeding line.",
          "const": "continue_through",
          "_metadata": {
            "logical_name": "ContinueThrough"
          }
        },
        {
          "title": "All consecutive lines matching this pattern, plus one additional line, are included in the group.",
          "description": "This is useful in cases where a log message ends with a continuation marker, such as a backslash, indicating\n that the following line is part of the same message.",
          "const": "continue_past",
          "_metadata": {
            "logical_name": "ContinuePast"
          }
        },
        {
          "title": "All consecutive lines not matching this pattern are included in the group.",
          "description": "This is useful where a log line contains a marker indicating that it begins a new message.",
          "const": "halt_before",
          "_metadata": {
            "logical_name": "HaltBefore"
          }
        },
        {
          "title": "All consecutive lines, up to and including the first line matching this pattern, are included in the group.",
          "description": "This is useful where a log line ends with a termination marker, such as a semicolon.",
          "const": "halt_with",
          "_metadata": {
            "logical_name": "HaltWith"
          }
        }
      ]
    },
    "vector::sources::aws_sqs::config::AwsSqsConfig": {
      "description": "Configuration for the `aws_sqs` source.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "queue_url"
          ],
          "properties": {
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "queue_url": {
              "description": "The URL of the SQS queue to poll for messages.",
              "type": "string"
            },
            "poll_secs": {
              "title": "How long to wait while polling the queue for new messages, in seconds.",
              "description": "Generally should not be changed unless instructed to do so, as if messages are available, they will always be\n consumed, regardless of the value of `poll_secs`.",
              "default": 15,
              "type": "number",
              "maximum": 4294967295.0,
              "minimum": 0.0
            },
            "visibility_timeout_secs": {
              "title": "The visibility timeout to use for messages, in secords.",
              "description": "This controls how long a message is left unavailable after Vector receives it. If Vector receives a message, and\n takes longer than `visibility_timeout_secs` to process and delete the message from the queue, it will be made reavailable for another consumer.\n\nThis can happen if, for example, if Vector crashes between consuming a message and deleting it.",
              "default": 300,
              "type": "number",
              "maximum": 4294967295.0,
              "minimum": 0.0
            },
            "delete_message": {
              "title": "Whether to delete the message once Vector processes it.",
              "description": "It can be useful to set this to `false` to debug or during initial Vector setup.",
              "default": true,
              "type": "boolean"
            },
            "client_concurrency": {
              "title": "Number of concurrent tasks to create for polling the queue for messages.",
              "description": "Defaults to the number of available CPUs on the system.\n\nShould not typically need to be changed, but it can sometimes be beneficial to raise this value when there is a\n high rate of messages being pushed into the queue and the messages being fetched are small. In these cases,\n Vector may not fully utilize system resources without fetching more messages per second, as it spends more time\n fetching the messages than processing them.",
              "default": 10,
              "type": "number",
              "maximum": 4294967295.0,
              "minimum": 0.0
            },
            "framing": {
              "description": "Configuration for building a `Framer`.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            },
            "decoding": {
              "description": "Configuration for building a `Deserializer`.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::datadog_agent::DatadogAgentConfig": {
      "description": "Configuration for the `datadog_agent` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "title": "The address to accept connections on.",
          "description": "The address _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "store_api_key": {
          "description": "When incoming events contain a Datadog API key, if this setting is set to `true` the key will kept in the event\n metadata and will be used if the event is sent to a Datadog sink.",
          "default": true,
          "type": "boolean"
        },
        "disable_logs": {
          "description": "If this settings is set to `true`, logs won't be accepted by the component.",
          "default": false,
          "type": "boolean"
        },
        "disable_metrics": {
          "description": "If this settings is set to `true`, metrics won't be accepted by the component.",
          "default": false,
          "type": "boolean"
        },
        "disable_traces": {
          "description": "If this settings is set to `true`, traces won't be accepted by the component.",
          "default": false,
          "type": "boolean"
        },
        "multiple_outputs": {
          "title": "If this setting is set to `true` logs, metrics and traces will be sent to different outputs.",
          "description": "For a source component named `agent` the received logs, metrics, and traces can then be accessed by specifying\n `agent.logs`, `agent.metrics`, and `agent.traces`, respectively, as the input to another component.",
          "default": false,
          "type": "boolean"
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global settings",
          "default": null,
          "type": [
            "boolean",
            "null"
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::demo_logs::DemoLogsConfig": {
      "description": "Configuration for the `demo_logs` source.",
      "default": {
        "interval": 1.0,
        "count": 9223372036854775807,
        "format": "json",
        "framing": {
          "method": "bytes"
        },
        "decoding": {
          "codec": "bytes"
        },
        "log_namespace": null
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "interval": {
              "title": "The amount of time, in seconds, to pause between each batch of output lines.",
              "description": "The default is one batch per second. In order to remove the delay and output batches as quickly as possible, set\n `interval` to `0.0`.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0
            },
            "count": {
              "title": "The total number of lines to output.",
              "description": "By default, the source continuously prints logs (infinitely).",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "framing": {
              "description": "Configuration for building a `Framer`.",
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            },
            "decoding": {
              "description": "Configuration for building a `Deserializer`.",
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting",
              "default": null,
              "type": [
                "boolean",
                "null"
              ]
            }
          }
        },
        {
          "description": "Output format configuration.",
          "$ref": "#/definitions/vector::sources::demo_logs::OutputFormat"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::demo_logs::OutputFormat": {
      "description": "Output format configuration.",
      "oneOf": [
        {
          "description": "Lines are chosen at random from the list specified using `lines`.",
          "type": "object",
          "required": [
            "format",
            "lines"
          ],
          "properties": {
            "sequence": {
              "description": "If `true`, each output line starts with an increasing sequence number, beginning with 0.",
              "default": false,
              "type": "boolean"
            },
            "lines": {
              "description": "The list of lines to output.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "format": {
              "description": "Lines are chosen at random from the list specified using `lines`.",
              "const": "shuffle",
              "_metadata": {
                "logical_name": "Shuffle"
              }
            }
          },
          "_metadata": {
            "logical_name": "Shuffle"
          }
        },
        {
          "description": "Randomly generated logs in [Apache common](\\(urls.apache_common)) format.",
          "type": "object",
          "required": [
            "format"
          ],
          "properties": {
            "format": {
              "const": "apache_common"
            }
          },
          "_metadata": {
            "logical_name": "ApacheCommon"
          }
        },
        {
          "description": "Randomly generated logs in [Apache error](\\(urls.apache_error)) format.",
          "type": "object",
          "required": [
            "format"
          ],
          "properties": {
            "format": {
              "const": "apache_error"
            }
          },
          "_metadata": {
            "logical_name": "ApacheError"
          }
        },
        {
          "description": "Randomly generated logs in Syslog format ([RFC 5424](\\(urls.syslog_5424))).",
          "type": "object",
          "required": [
            "format"
          ],
          "properties": {
            "format": {
              "const": "syslog"
            }
          },
          "_metadata": {
            "logical_name": "Syslog"
          }
        },
        {
          "description": "Randomly generated logs in Syslog format ([RFC 3164](\\(urls.syslog_3164))).",
          "type": "object",
          "required": [
            "format"
          ],
          "properties": {
            "format": {
              "const": "bsd_syslog"
            }
          },
          "_metadata": {
            "logical_name": "BsdSyslog"
          }
        },
        {
          "description": "Randomly generated HTTP server logs in [JSON](\\(urls.json)) format.",
          "type": "object",
          "required": [
            "format"
          ],
          "properties": {
            "format": {
              "const": "json"
            }
          },
          "_metadata": {
            "logical_name": "Json"
          }
        }
      ]
    },
    "vector::sources::dnstap::DnstapConfig": {
      "description": "Configuration for the `dnstap` source.",
      "type": "object",
      "required": [
        "socket_path"
      ],
      "properties": {
        "max_frame_length": {
          "description": "Maximum length, in bytes, that a frame can be.",
          "default": 102400,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the source path to each event.",
          "description": "The value will be the socket path itself.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "socket_path": {
          "title": "Absolute path to the socket file to read DNSTAP data from.",
          "description": "The DNS server must be configured to send its DNSTAP data to this socket file. The socket file will be created,\n if it doesn't already exist, when the source first starts.",
          "$ref": "#/definitions/stdlib::PathBuf"
        },
        "raw_data_only": {
          "title": "Whether or not to skip parsing/decoding of DNSTAP frames.",
          "description": "If set to `true`, frames will not be parsed/decoded. The raw frame data will be set as a field on the event\n (called `rawData`) and encoded as a base64 string.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "multithreaded": {
          "description": "Whether or not to concurrently process DNSTAP frames.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "max_frame_handling_tasks": {
          "description": "Maximum number of frames that can be processed concurrently.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "socket_file_mode": {
          "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
          "description": "Note that the file mode value can be specified in any numeric format supported by your configuration\n language, but it is most intuitive to use an octal number.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "socket_receive_buffer_size": {
          "title": "The size, in bytes, of the receive buffer used for the socket.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "socket_send_buffer_size": {
          "title": "The size, in bytes, of the send buffer used for the socket.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::docker_logs::DockerLogsConfig": {
      "description": "Configuration for the `docker_logs` source.",
      "default": {
        "host_key": "host",
        "docker_host": null,
        "exclude_containers": null,
        "include_containers": null,
        "include_labels": null,
        "include_images": null,
        "partial_event_marker_field": "_partial",
        "auto_partial_merge": true,
        "retry_backoff_secs": 2,
        "multiline": null,
        "tls": null
      },
      "type": "object",
      "properties": {
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "The value will be the current hostname for wherever Vector is running.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "type": "string"
        },
        "docker_host": {
          "title": "Docker host to connect to.",
          "description": "Use an HTTPS URL to enable TLS encryption.\n\nIf absent, Vector will try to use `DOCKER_HOST` environment variable. If `DOCKER_HOST` is also absent, Vector will use default Docker local socket (`/var/run/docker.sock` on Unix platforms, `//./pipe/docker_engine` on Windows).",
          "type": [
            "string",
            "null"
          ]
        },
        "exclude_containers": {
          "title": "A list of container IDs or names of containers to exclude from log collection.",
          "description": "Matching is prefix first, so specifying a value of `foo` would match any container named `foo` as well as any\n container whose name started with `foo`. This applies equally whether matching container IDs or names.\n\nBy default, the source will collect logs for all containers. If `exclude_containers` is configured, any\n container that matches a configured exclusion will be excluded even if it is also included via\n `include_containers`, so care should be taken when utilizing prefix matches as they cannot be overridden by a\n corresponding entry in `include_containers` e.g. excluding `foo` by attempting to include `foo-specific-id`.\n\nThis can be used in conjunction with `include_containers`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "include_containers": {
          "title": "A list of container IDs or names of containers to include in log collection.",
          "description": "Matching is prefix first, so specifying a value of `foo` would match any container named `foo` as well as any\n container whose name started with `foo`. This applies equally whether matching container IDs or names.\n\nBy default, the source will collect logs for all containers. If `include_containers` is configured, only\n containers that match a configured inclusion and are also not excluded will be matched.\n\nThis can be used in conjunction with `include_containers`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "include_labels": {
          "title": "A list of container object labels to match against when filtering running containers.",
          "description": "Labels should follow the syntax described in the [Docker object labels](https://docs.docker.com/config/labels-custom-metadata/) documentation.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "include_images": {
          "title": "A list of image names to match against.",
          "description": "If not provided, all images will be included.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "partial_event_marker_field": {
          "title": "Overrides the name of the log field used to mark an event as partial.",
          "description": "If `auto_partial_merge` is disabled, partial events will be emitted with a log field, controlled by this\n configuration value, is set, indicating that the event is not complete.\n\nBy default, `\"_partial\"` is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "auto_partial_merge": {
          "description": "Enables automatic merging of partial events.",
          "type": "boolean"
        },
        "retry_backoff_secs": {
          "description": "The amount of time, in seconds, to wait before retrying after an error.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "multiline": {
          "title": "Multiline aggregation configuration.",
          "description": "If not specified, multiline aggregation is disabled.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::multiline_config::MultilineConfig"
            }
          ]
        },
        "tls": {
          "title": "Configuration of TLS when connecting to the Docker daemon.",
          "description": "Only relevant when connecting to Docker via an HTTPS URL.\n\nIf not configured, Vector will try to use environment variable `DOCKER_CERT_PATH` and then` DOCKER_CONFIG`. If both environment variables are absent, Vector will try to read certificates in `~/.docker/`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of TLS when connecting to the Docker daemon.",
              "$ref": "#/definitions/vector::docker::DockerTlsConfig"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::docker::DockerTlsConfig": {
      "title": "Configuration of TLS when connecting to the Docker daemon.",
      "description": "Only relevant when connecting to Docker via an HTTPS URL.\n\nIf not configured, Vector will try to use environment variable `DOCKER_CERT_PATH` and then` DOCKER_CONFIG`. If both environment variables are absent, Vector will try to read certificates in `~/.docker/`.",
      "type": "object",
      "required": [
        "ca_file",
        "crt_file",
        "key_file"
      ],
      "properties": {
        "ca_file": {
          "description": "Path to the CA certificate file.",
          "$ref": "#/definitions/stdlib::PathBuf"
        },
        "crt_file": {
          "description": "Path to the TLS certificate file.",
          "$ref": "#/definitions/stdlib::PathBuf"
        },
        "key_file": {
          "description": "Path to the TLS key file.",
          "$ref": "#/definitions/stdlib::PathBuf"
        }
      }
    },
    "vector::sources::eventstoredb_metrics::EventStoreDbConfig": {
      "description": "Configuration for the `eventstoredb_metrics` source.",
      "type": "object",
      "properties": {
        "endpoint": {
          "description": "Endpoints to scrape stats from.",
          "default": "https://localhost:2113/stats",
          "type": "string"
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "default_namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "By default, `eventstoredb` is used.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::exec::ExecConfig": {
      "description": "Configuration for the `exec` source.",
      "default": {
        "mode": "scheduled",
        "scheduled": {
          "exec_interval_secs": 60
        },
        "streaming": null,
        "command": [
          "echo",
          "Hello World!"
        ],
        "working_directory": null,
        "include_stderr": true,
        "maximum_buffer_size_bytes": 1000000,
        "framing": null,
        "decoding": {
          "codec": "bytes"
        }
      },
      "type": "object",
      "properties": {
        "mode": {
          "description": "Mode of operation for running the command.",
          "$ref": "#/definitions/vector::sources::exec::Mode"
        },
        "scheduled": {
          "description": "Configuration options for scheduled commands.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::exec::ScheduledConfig"
            }
          ]
        },
        "streaming": {
          "description": "Configuration options for streaming commands.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::exec::StreamingConfig"
            }
          ]
        },
        "command": {
          "description": "The command to be run, plus any arguments required.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "working_directory": {
          "description": "The directory in which to run the command.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "include_stderr": {
          "description": "Whether or not the output from stderr should be included when generating events.",
          "default": true,
          "type": "boolean"
        },
        "maximum_buffer_size_bytes": {
          "description": "The maximum buffer size allowed before a log event will be generated.",
          "default": 1000000,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            }
          ]
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::exec::Mode": {
      "description": "Mode of operation for running the command.",
      "oneOf": [
        {
          "description": "The command is run on a schedule.",
          "const": "scheduled",
          "_metadata": {
            "logical_name": "Scheduled"
          }
        },
        {
          "description": "The command is run until it exits, potentially being restarted.",
          "const": "streaming",
          "_metadata": {
            "logical_name": "Streaming"
          }
        }
      ]
    },
    "vector::sources::exec::ScheduledConfig": {
      "description": "Configuration options for scheduled commands.",
      "type": "object",
      "properties": {
        "exec_interval_secs": {
          "title": "The interval, in seconds, between scheduled command runs.",
          "description": "If the command takes longer than `exec_interval_secs` to run, it will be killed.",
          "default": 60,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sources::exec::StreamingConfig": {
      "description": "Configuration options for streaming commands.",
      "type": "object",
      "properties": {
        "respawn_on_exit": {
          "description": "Whether or not the command should be rerun if the command exits.",
          "default": true,
          "type": "boolean"
        },
        "respawn_interval_secs": {
          "description": "The amount of time, in seconds, that Vector will wait before rerunning a streaming command that exited.",
          "default": 5,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sources::file::FileConfig": {
      "description": "Configuration for the `file` source.",
      "default": {
        "include": [],
        "exclude": [],
        "file_key": "file",
        "start_at_beginning": null,
        "ignore_checkpoints": null,
        "read_from": null,
        "ignore_older_secs": null,
        "max_line_bytes": 102400,
        "host_key": null,
        "data_dir": null,
        "offset_key": null,
        "glob_minimum_cooldown_ms": 1000,
        "fingerprint": {
          "strategy": "checksum",
          "bytes": null,
          "ignored_header_bytes": 0,
          "lines": 1
        },
        "ignore_not_found": false,
        "message_start_indicator": null,
        "multi_line_timeout": 1000,
        "multiline": null,
        "max_read_bytes": 2048,
        "oldest_first": false,
        "remove_after_secs": null,
        "line_delimiter": "\n",
        "encoding": null,
        "acknowledgements": {
          "enabled": null
        }
      },
      "type": "object",
      "properties": {
        "include": {
          "description": "Array of file patterns to include. [Globbing](https://vector.dev/docs/reference/configuration/sources/file/#globbing) is supported.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          }
        },
        "exclude": {
          "title": "Array of file patterns to exclude. [Globbing](https://vector.dev/docs/reference/configuration/sources/file/#globbing) is supported.",
          "description": "Takes precedence over the `include` option.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          }
        },
        "file_key": {
          "title": "Overrides the name of the log field used to add the file path to each event.",
          "description": "The value will be the full path to the file where the event was read message.\n\nBy default, `file` is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "start_at_beginning": {
          "title": "Whether or not to start reading from the beginning of a new file.",
          "description": "DEPRECATED: This is a deprecated option -- replaced by `ignore_checkpoints`/`read_from` -- and should be removed.",
          "deprecated": true,
          "type": [
            "boolean",
            "null"
          ]
        },
        "ignore_checkpoints": {
          "title": "Whether or not to ignore existing checkpoints when determining where to start reading a file.",
          "description": "Checkpoints are still written normally.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "read_from": {
          "description": "File position to use when reading a new file.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::file::ReadFromConfig"
            }
          ]
        },
        "ignore_older_secs": {
          "description": "Ignore files with a data modification date older than the specified number of seconds.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_line_bytes": {
          "title": "The maximum number of bytes a line can contain before being discarded.",
          "description": "This protects against malformed lines or tailing incorrect files.",
          "default": 102400,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "The value will be the current hostname for wherever Vector is running.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "data_dir": {
          "title": "The directory used to persist file checkpoint positions.",
          "description": "By default, the global `data_dir` option is used. Please make sure the user Vector is running as has write permissions to this directory.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "offset_key": {
          "title": "Enables adding the file offset to each event and sets the name of the log field used.",
          "description": "The value will be the byte offset of the start of the line within the file.\n\nOff by default, the offset is only added to the event if this is set.",
          "type": [
            "string",
            "null"
          ]
        },
        "glob_minimum_cooldown_ms": {
          "title": "Delay between file discovery calls, in milliseconds.",
          "description": "This controls the interval at which Vector searches for files. Higher value result in greater chances of some short living files being missed between searches, but lower value increases the performance impact of file discovery.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "fingerprint": {
          "title": "Configuration for how files should be identified.",
          "description": "This is important for `checkpointing` when file rotation is used.",
          "$ref": "#/definitions/vector::sources::file::FingerprintConfig"
        },
        "ignore_not_found": {
          "title": "Ignore missing files when fingerprinting.",
          "description": "This may be useful when used with source directories containing dangling symlinks.",
          "type": "boolean"
        },
        "message_start_indicator": {
          "title": "String value used to identify the start of a multi-line message.",
          "description": "DEPRECATED: This is a deprecated option -- replaced by `multiline` -- and should be removed.",
          "deprecated": true,
          "type": [
            "string",
            "null"
          ]
        },
        "multi_line_timeout": {
          "title": "How long to wait for more data when aggregating a multi-line message, in milliseconds.",
          "description": "DEPRECATED: This is a deprecated option -- replaced by `multiline` -- and should be removed.",
          "deprecated": true,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "multiline": {
          "title": "Multiline aggregation configuration.",
          "description": "If not specified, multiline aggregation is disabled.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::multiline_config::MultilineConfig"
            }
          ]
        },
        "max_read_bytes": {
          "description": "An approximate limit on the amount of data read from a single file at a given time.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "oldest_first": {
          "description": "Instead of balancing read capacity fairly across all watched files, prioritize draining the oldest files before moving on to read data from younger files.",
          "type": "boolean"
        },
        "remove_after_secs": {
          "title": "Timeout from reaching `EOF` after which file will be removed from filesystem, unless new data is written in the meantime.",
          "description": "If not specified, files will not be removed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "line_delimiter": {
          "description": "String sequence used to separate one file line from another.",
          "type": "string"
        },
        "encoding": {
          "description": "Character set encoding.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::encoding_config::EncodingConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::file::ReadFromConfig": {
      "description": "File position to use when reading a new file.",
      "oneOf": [
        {
          "description": "Read from the beginning of the file.",
          "const": "beginning",
          "_metadata": {
            "logical_name": "Beginning"
          }
        },
        {
          "description": "Start reading from the current end of the file.",
          "const": "end",
          "_metadata": {
            "logical_name": "End"
          }
        }
      ]
    },
    "vector::sources::file::FingerprintConfig": {
      "title": "Configuration for how files should be identified.",
      "description": "This is important for `checkpointing` when file rotation is used.",
      "oneOf": [
        {
          "description": "Read lines from the beginning of the file and compute a checksum over them.",
          "type": "object",
          "required": [
            "ignored_header_bytes",
            "strategy"
          ],
          "properties": {
            "bytes": {
              "title": "Maximum number of bytes to use, from the lines that are read, for generating the checksum.",
              "description": "TODO: Should we properly expose this in the documentation? There could definitely be value in allowing more\n bytes to be used for the checksum generation, but we should commit to exposing it rather than hiding it.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "ignored_header_bytes": {
              "title": "The number of bytes to skip ahead (or ignore) when reading the data used for generating the checksum.",
              "description": "This can be helpful if all files share a common header that should be skipped.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "lines": {
              "title": "The number of lines to read for generating the checksum.",
              "description": "If your files share a common header that is not always a fixed size,\n\nIf the file has less than this amount of lines, it won’t be read at all.",
              "default": 1,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "strategy": {
              "description": "Read lines from the beginning of the file and compute a checksum over them.",
              "const": "checksum",
              "_metadata": {
                "logical_name": "Checksum"
              }
            }
          },
          "_metadata": {
            "logical_name": "Checksum"
          }
        },
        {
          "description": "Use the [device and inode](https://en.wikipedia.org/wiki/Inode) as the identifier.",
          "type": "object",
          "required": [
            "strategy"
          ],
          "properties": {
            "strategy": {
              "const": "device_and_inode"
            }
          },
          "_metadata": {
            "logical_name": "DevInode"
          }
        }
      ]
    },
    "vector::sources::util::encoding_config::EncodingConfig": {
      "description": "Character set encoding.",
      "type": "object",
      "required": [
        "charset"
      ],
      "properties": {
        "charset": {
          "title": "Encoding of the source messages.",
          "description": "Takes one of the encoding [label strings](https://encoding.spec.whatwg.org/#concept-encoding-get) defined as\n part of the [Encoding Standard](https://encoding.spec.whatwg.org/).\n\nWhen set, the messages are transcoded from the specified encoding to UTF-8, which is the encoding that Vector\n assumes internally for string-like data. You should enable this transcoding operation if you need your data to\n be in UTF-8 for further processing. At the time of transcoding, any malformed sequences (that can’t be mapped to\n UTF-8) will be replaced with the Unicode [REPLACEMENT\n CHARACTER](https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character) and warnings will be\n logged.",
          "$ref": "#/definitions/encoding_rs::Encoding"
        }
      }
    },
    "encoding_rs::Encoding": {
      "description": "An encoding as defined in the [Encoding Standard](https://encoding.spec.whatwg.org/).",
      "type": "string"
    },
    "vector::sources::file_descriptors::file_descriptor::FileDescriptorSourceConfig": {
      "description": "Configuration for the `file_descriptor` source.",
      "type": "object",
      "required": [
        "fd"
      ],
      "properties": {
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "default": 102400,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "The value will be the current hostname for wherever Vector is running.\n\nBy default, the [global `host_key` option](https://vector.dev/docs/reference/configuration//global-options#log_schema.host_key) is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            }
          ]
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        },
        "fd": {
          "description": "The file descriptor number to read from.",
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::fluent::FluentConfig": {
      "description": "Configuration for the `fluent` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/vector::sources::util::tcp::SocketListenAddr"
        },
        "connection_limit": {
          "description": "The maximum number of TCP connections that will be allowed at any given time.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "keepalive": {
          "description": "TCP keepalive settings for socket-based components.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
            }
          ]
        },
        "receive_buffer_bytes": {
          "title": "The size, in bytes, of the receive buffer used for each connection.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "tls": {
          "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsSourceConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::util::tcp::SocketListenAddr": {
      "description": "A listening address that can be given directly or be managed via `systemd` socket activation.",
      "oneOf": [
        {
          "description": "An IPv4/IPv6 address and port.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "logical_name": "SocketAddr"
          }
        },
        {
          "description": "A file descriptor identifier that is given from, and managed by, the socket activation feature of `systemd`.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "logical_name": "SystemdFd"
          }
        }
      ]
    },
    "vector_core::tcp::TcpKeepaliveConfig": {
      "description": "TCP keepalive settings for socket-based components.",
      "type": "object",
      "properties": {
        "time_secs": {
          "description": "The time to wait, in seconds, before starting to send TCP keepalive probes on an idle connection.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector_core::tls::settings::TlsSourceConfig": {
      "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "client_metadata_key": {
              "description": "Event field for client certificate metadata.",
              "type": [
                "string",
                "null"
              ]
            }
          }
        },
        {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
        }
      ]
    },
    "vector::sources::gcp_pubsub::PubsubConfig": {
      "description": "Configuration for the `gcp_pubsub` source.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "project",
            "subscription"
          ],
          "properties": {
            "project": {
              "description": "The project name from which to pull logs.",
              "type": "string"
            },
            "subscription": {
              "description": "The subscription within the project which is configured to receive logs.",
              "type": "string"
            },
            "endpoint": {
              "description": "The endpoint from which to pull data.",
              "type": [
                "string",
                "null"
              ]
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "max_concurrency": {
              "description": "The maximum number of concurrent stream connections to open at once.",
              "default": 10,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "full_response_size": {
              "description": "The number of messages in a response to mark a stream as\n \"busy\". This is used to determine if more streams should be\n started.",
              "default": 100,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "poll_time_seconds": {
              "description": "How often to poll the currently active streams to see if they\n are all busy and so open a new stream.",
              "default": 2.0,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0
            },
            "ack_deadline_secs": {
              "title": "The acknowledgement deadline, in seconds, to use for this stream.",
              "description": "Messages that are not acknowledged when this deadline expires may be retransmitted.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 2147483647.0,
              "minimum": -2147483648.0
            },
            "ack_deadline_seconds": {
              "description": "Deprecated, old name of `ack_deadline_secs`.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 2147483647.0,
              "minimum": -2147483648.0
            },
            "retry_delay_secs": {
              "description": "The amount of time, in seconds, to wait between retry attempts after an error.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0
            },
            "retry_delay_seconds": {
              "description": "Deprecated, old name of `retry_delay_secs`.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0
            },
            "keepalive_secs": {
              "description": "The amount of time, in seconds, with no received activity\n before sending a keepalive request. If this is set larger than\n `60`, you may see periodic errors sent from the server.",
              "default": 60.0,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0
            },
            "framing": {
              "description": "Configuration for building a `Framer`.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            },
            "decoding": {
              "description": "Configuration for building a `Deserializer`.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::gcp::GcpAuthConfig": {
      "description": "Configuration of the authentication strategy for interacting with GCP services.",
      "type": "object",
      "properties": {
        "api_key": {
          "title": "An API key. ([documentation](https://cloud.google.com/docs/authentication/api-keys))",
          "description": "Either an API key, or a path to a service account credentials JSON file can be specified.\n\nIf both are unset, Vector checks the `GOOGLE_APPLICATION_CREDENTIALS` environment variable for a filename. If no\n filename is named, Vector will attempt to fetch an instance service account for the compute instance the program is\n running on. If Vector is not running on a GCE instance, then you must define eith an API key or service account\n credentials JSON file.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "credentials_path": {
          "title": "Path to a service account credentials JSON file. ([documentation](https://cloud.google.com/docs/authentication/production#manually))",
          "description": "Either an API key, or a path to a service account credentials JSON file can be specified.\n\nIf both are unset, Vector checks the `GOOGLE_APPLICATION_CREDENTIALS` environment variable for a filename. If no\n filename is named, Vector will attempt to fetch an instance service account for the compute instance the program is\n running on. If Vector is not running on a GCE instance, then you must define eith an API key or service account\n credentials JSON file.",
          "type": [
            "string",
            "null"
          ]
        },
        "skip_authentication": {
          "description": "Skip all authentication handling. For use with integration tests only.",
          "default": false,
          "type": "boolean"
        }
      }
    },
    "vector::sources::heroku_logs::LogplexConfig": {
      "description": "Configuration for `heroku_logs` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "query_parameters": {
          "title": "A list of URL query parameters to include in the log event.",
          "description": "These will override any values included in the body with conflicting names.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "auth": {
          "description": "HTTP Basic authentication configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::http::auth::HttpSourceAuthConfig"
            }
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::util::http::auth::HttpSourceAuthConfig": {
      "description": "HTTP Basic authentication configuration.",
      "type": "object",
      "required": [
        "password",
        "username"
      ],
      "properties": {
        "username": {
          "description": "The username for basic authentication.",
          "type": "string"
        },
        "password": {
          "description": "The password for basic authentication.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        }
      }
    },
    "vector::sources::host_metrics::HostMetricsConfig": {
      "description": "Configuration for the `host_metrics` source.",
      "type": "object",
      "properties": {
        "scrape_interval_secs": {
          "description": "The interval between metric gathering, in seconds.",
          "default": 15.0,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "collectors": {
          "title": "The list of host metric collector services to use.",
          "description": "Defaults to all collectors.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector::sources::host_metrics::Collector"
          }
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "By default, `host` is used.",
          "default": "host",
          "type": [
            "string",
            "null"
          ]
        },
        "disk": {
          "description": "Options for the “disk” metrics collector.",
          "default": {
            "devices": {
              "includes": null,
              "excludes": null
            }
          },
          "$ref": "#/definitions/vector::sources::host_metrics::disk::DiskConfig"
        },
        "filesystem": {
          "description": "Options for the “filesystem” metrics collector.",
          "default": {
            "devices": {
              "includes": null,
              "excludes": null
            },
            "filesystems": {
              "includes": null,
              "excludes": null
            },
            "mountpoints": {
              "includes": null,
              "excludes": null
            }
          },
          "$ref": "#/definitions/vector::sources::host_metrics::filesystem::FilesystemConfig"
        },
        "network": {
          "description": "Options for the “network” metrics collector.",
          "default": {
            "devices": {
              "includes": null,
              "excludes": null
            }
          },
          "$ref": "#/definitions/vector::sources::host_metrics::network::NetworkConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::host_metrics::Collector": {
      "description": "Collector types.",
      "oneOf": [
        {
          "description": "CPU.",
          "const": "cpu",
          "_metadata": {
            "logical_name": "Cpu"
          }
        },
        {
          "description": "Disk.",
          "const": "disk",
          "_metadata": {
            "logical_name": "Disk"
          }
        },
        {
          "description": "Filesystem.",
          "const": "filesystem",
          "_metadata": {
            "logical_name": "Filesystem"
          }
        },
        {
          "description": "Load average.",
          "const": "load",
          "_metadata": {
            "logical_name": "Load"
          }
        },
        {
          "description": "Host.",
          "const": "host",
          "_metadata": {
            "logical_name": "Host"
          }
        },
        {
          "description": "Memory.",
          "const": "memory",
          "_metadata": {
            "logical_name": "Memory"
          }
        },
        {
          "description": "Network.",
          "const": "network",
          "_metadata": {
            "logical_name": "Network"
          }
        }
      ]
    },
    "vector::sources::host_metrics::disk::DiskConfig": {
      "description": "Options for the “disk” metrics collector.",
      "type": "object",
      "properties": {
        "devices": {
          "description": "Lists of device name patterns to include or exclude.",
          "default": {
            "includes": null,
            "excludes": null
          },
          "$ref": "#/definitions/vector::sources::host_metrics::FilterList"
        }
      }
    },
    "vector::sources::host_metrics::FilterList": {
      "description": "Filtering configuration.",
      "type": "object",
      "properties": {
        "includes": {
          "description": "Any patterns which should be included.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector::sources::host_metrics::PatternWrapper"
          }
        },
        "excludes": {
          "description": "Any patterns which should be excluded.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector::sources::host_metrics::PatternWrapper"
          }
        }
      }
    },
    "vector::sources::host_metrics::PatternWrapper": {
      "title": "A compiled Unix shell-style pattern.",
      "description": "- `?` matches any single character.\n - `*` matches any (possibly empty) sequence of characters.\n - `**` matches the current directory and arbitrary subdirectories. This sequence must form a single path component,\n   so both `**a` and `b**` are invalid and will result in an error. A sequence of more than two consecutive `*`\n   characters is also invalid.\n - `[...]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as\n   ordered by Unicode, so e.g. `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed bracket is\n   invalid.\n - `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the brackets.\n\nThe metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`). When a `]` occurs immediately\n following `[` or `[!` then it is interpreted as being part of, rather then ending, the character set, so `]` and NOT\n `]` can be matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a character sequence\n pattern by placing it at the start or the end, e.g. `[abc-]`.",
      "type": "string"
    },
    "vector::sources::host_metrics::filesystem::FilesystemConfig": {
      "description": "Options for the “filesystem” metrics collector.",
      "type": "object",
      "properties": {
        "devices": {
          "description": "Lists of device name patterns to include or exclude.",
          "default": {
            "includes": null,
            "excludes": null
          },
          "$ref": "#/definitions/vector::sources::host_metrics::FilterList"
        },
        "filesystems": {
          "description": "Lists of filesystem name patterns to include or exclude.",
          "default": {
            "includes": null,
            "excludes": null
          },
          "$ref": "#/definitions/vector::sources::host_metrics::FilterList"
        },
        "mountpoints": {
          "description": "Lists of mount point path patterns to include or exclude.",
          "default": {
            "includes": null,
            "excludes": null
          },
          "$ref": "#/definitions/vector::sources::host_metrics::FilterList"
        }
      }
    },
    "vector::sources::host_metrics::network::NetworkConfig": {
      "description": "Options for the “network” metrics collector.",
      "type": "object",
      "properties": {
        "devices": {
          "description": "Lists of device name patterns to include or exclude.",
          "default": {
            "includes": null,
            "excludes": null
          },
          "$ref": "#/definitions/vector::sources::host_metrics::FilterList"
        }
      }
    },
    "vector::sources::http::SimpleHttpConfig": {
      "description": "Configuration for the `http` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "encoding": {
          "title": "The expected encoding of received data.",
          "description": "Note that for `json` and `ndjson` encodings, the fields of the JSON objects are output as separate fields.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::body_decoding::Encoding"
            }
          ]
        },
        "headers": {
          "title": "A list of HTTP headers to include in the log event.",
          "description": "These will override any values included in the JSON payload with conflicting names.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "query_parameters": {
          "title": "A list of URL query parameters to include in the log event.",
          "description": "These will override any values included in the body with conflicting names.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "auth": {
          "description": "HTTP Basic authentication configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::http::auth::HttpSourceAuthConfig"
            }
          ]
        },
        "strict_path": {
          "title": "Whether or not to treat the configured `path` as an absolute path.",
          "description": "If set to `true`, only requests using the exact URL path specified in `path` will be accepted. Otherwise,\n requests sent to a URL path that starts with the value of `path` will be accepted.\n\nWith `strict_path` set to `false` and `path` set to `\"\"`, the configured HTTP source will accept requests from\n any URL path.",
          "default": true,
          "type": "boolean"
        },
        "path": {
          "description": "The URL path on which log event POST requests shall be sent.",
          "default": "/",
          "type": "string"
        },
        "path_key": {
          "description": "The event key in which the requested URL path used to send the request will be stored.",
          "default": "path",
          "type": "string"
        },
        "method": {
          "description": "Specifies the action of the HTTP request.",
          "default": "POST",
          "$ref": "#/definitions/vector::sources::http::HttpMethod"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            }
          ]
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::util::body_decoding::Encoding": {
      "description": "Content encoding.",
      "oneOf": [
        {
          "description": "Plaintext.",
          "const": "text",
          "_metadata": {
            "logical_name": "Text"
          }
        },
        {
          "description": "Newline-delimited JSON.",
          "const": "ndjson",
          "_metadata": {
            "logical_name": "Ndjson"
          }
        },
        {
          "description": "JSON.",
          "const": "json",
          "_metadata": {
            "logical_name": "Json"
          }
        },
        {
          "description": "Binary.",
          "const": "binary",
          "_metadata": {
            "logical_name": "Binary"
          }
        }
      ]
    },
    "vector::sources::http::HttpMethod": {
      "description": "HTTP method.",
      "oneOf": [
        {
          "description": "HTTP HEAD method.",
          "const": "HEAD",
          "_metadata": {
            "logical_name": "Head"
          }
        },
        {
          "description": "HTTP GET method.",
          "const": "GET",
          "_metadata": {
            "logical_name": "Get"
          }
        },
        {
          "description": "HTTP POST method.",
          "const": "POST",
          "_metadata": {
            "logical_name": "Post"
          }
        },
        {
          "description": "HTTP Put method.",
          "const": "PUT",
          "_metadata": {
            "logical_name": "Put"
          }
        },
        {
          "description": "HTTP PATCH method.",
          "const": "PATCH",
          "_metadata": {
            "logical_name": "Patch"
          }
        },
        {
          "description": "HTTP DELETE method.",
          "const": "DELETE",
          "_metadata": {
            "logical_name": "Delete"
          }
        }
      ]
    },
    "vector::sources::http_scrape::scrape::HttpScrapeConfig": {
      "description": "Configuration for the `http_scrape` source.",
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "description": "Endpoint to scrape events from. The full path must be specified.\n Example: \"http://127.0.0.1:9898/logs\"",
          "type": "string"
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "query": {
          "title": "Custom parameters for the scrape request query string.",
          "description": "One or more values for the same parameter key can be provided. The parameters provided in this option are\n appended to any parameters manually provided in the `endpoint` option.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "decoding": {
          "description": "Decoder to use on the HTTP responses.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        },
        "framing": {
          "description": "Framing to use in the decoding.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "headers": {
          "description": "Headers to apply to the HTTP requests.\n One or more values for the same header can be provided.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "tls": {
          "description": "TLS configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP Authentication.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting",
          "default": null,
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::http::Auth": {
      "title": "Configuration of the authentication strategy for HTTP requests.",
      "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
      "oneOf": [
        {
          "title": "Basic authentication.",
          "description": "The username and password are concatenated and encoded via base64.",
          "type": "object",
          "required": [
            "password",
            "strategy",
            "user"
          ],
          "properties": {
            "user": {
              "description": "The username to send.",
              "type": "string"
            },
            "password": {
              "description": "The password to send.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            },
            "strategy": {
              "title": "Basic authentication.",
              "description": "The username and password are concatenated and encoded via base64.",
              "const": "basic",
              "_metadata": {
                "logical_name": "Basic"
              }
            }
          },
          "_metadata": {
            "logical_name": "Basic"
          }
        },
        {
          "title": "Bearer authentication.",
          "description": "A bearer token (OAuth2, JWT, etc) is passed as-is.",
          "type": "object",
          "required": [
            "strategy",
            "token"
          ],
          "properties": {
            "token": {
              "description": "The bearer token to send.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            },
            "strategy": {
              "title": "Bearer authentication.",
              "description": "A bearer token (OAuth2, JWT, etc) is passed as-is.",
              "const": "bearer",
              "_metadata": {
                "logical_name": "Bearer"
              }
            }
          },
          "_metadata": {
            "logical_name": "Bearer"
          }
        }
      ]
    },
    "vector::sources::internal_logs::InternalLogsConfig": {
      "description": "Configuration for the `internal_logs` source.",
      "type": "object",
      "properties": {
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "The value will be the current hostname for wherever Vector is running.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "pid_key": {
          "title": "Overrides the name of the log field used to add the current process ID to each event.",
          "description": "The value will be the current process ID for Vector itself.\n\nBy default, `\"pid\"` is used.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::internal_metrics::InternalMetricsConfig": {
      "description": "Configuration for the `internal_metrics` source.",
      "default": {
        "scrape_interval_secs": 2.0,
        "tags": {
          "host_key": null,
          "pid_key": null
        },
        "namespace": null
      },
      "type": "object",
      "properties": {
        "scrape_interval_secs": {
          "description": "The interval between metric gathering, in seconds.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "tags": {
          "description": "Tag configuration for the `internal_metrics` source.",
          "default": {
            "host_key": null,
            "pid_key": null
          },
          "$ref": "#/definitions/vector::sources::internal_metrics::TagsConfig"
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "By default, `vector` is used.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::internal_metrics::TagsConfig": {
      "description": "Tag configuration for the `internal_metrics` source.",
      "default": {
        "host_key": null,
        "pid_key": null
      },
      "type": "object",
      "properties": {
        "host_key": {
          "title": "Sets the name of the tag to use to add the current hostname to each metric.",
          "description": "The value will be the current hostname for wherever Vector is running.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "pid_key": {
          "title": "Sets the name of the tag to use to add the current process ID to each metric.",
          "description": "The value will be the current process ID for Vector itself.\n\nBy default, this is not set and the tag will not be automatically added.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::sources::journald::JournaldConfig": {
      "description": "Configuration for the `journald` source.",
      "default": {
        "since_now": null,
        "current_boot_only": null,
        "units": [],
        "include_units": [],
        "exclude_units": [],
        "include_matches": {},
        "exclude_matches": {},
        "data_dir": null,
        "batch_size": null,
        "journalctl_path": null,
        "journal_directory": null,
        "acknowledgements": {
          "enabled": null
        },
        "remap_priority": false
      },
      "type": "object",
      "properties": {
        "since_now": {
          "description": "Only include entries that appended to the journal after Vector starts reading it.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "current_boot_only": {
          "description": "Only include entries that occurred after the current boot of the system.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "units": {
          "title": "The list of unit names to monitor.",
          "description": "If empty or not present, all units are accepted. Unit names lacking a \".\" will have \".service\" appended to make them a valid service unit name.",
          "deprecated": true,
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "include_units": {
          "title": "A list of unit names to monitor.",
          "description": "If empty or not present, all units are accepted. Unit names lacking a \".\" will have \".service\" appended to make them a valid service unit name.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "exclude_units": {
          "title": "A list of unit names to exclude from monitoring.",
          "description": "Unit names lacking a \".\" will have \".service\" appended to make them a valid service unit name.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "include_matches": {
          "title": "A list of sets of field/value pairs to monitor.",
          "description": "If empty or not present, all journal fields are accepted. If `include_units` is specified, it will be merged into this list.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          }
        },
        "exclude_matches": {
          "title": "A list of sets of field/value pairs that, if any are present in a journal entry, will cause the entry to be excluded from this source.",
          "description": "If `exclude_units` is specified, it will be merged into this list.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          }
        },
        "data_dir": {
          "title": "The directory used to persist file checkpoint positions.",
          "description": "By default, the global `data_dir` option is used. Please make sure the user Vector is running as has write permissions to this directory.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "batch_size": {
          "description": "The `systemd` journal is read in batches, and a checkpoint is set at the end of each batch. This option limits the size of the batch.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "journalctl_path": {
          "title": "The full path of the `journalctl` executable.",
          "description": "If not set, Vector will search the path for `journalctl`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "journal_directory": {
          "title": "The full path of the journal directory.",
          "description": "If not set, `journalctl` will use the default system journal paths.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "remap_priority": {
          "title": "Enables remapping the `PRIORITY` field from an integer to string value.",
          "description": "Has no effect unless the value of the field is already an integer.",
          "default": false,
          "deprecated": true,
          "type": "boolean"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::kafka::KafkaSourceConfig": {
      "description": "Configuration for the `kafka` source.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bootstrap_servers",
            "group_id",
            "topics"
          ],
          "properties": {
            "bootstrap_servers": {
              "title": "A comma-separated list of Kafka bootstrap servers.",
              "description": "These are the servers in a Kafka cluster that a client should use to \"bootstrap\" its connection to the cluster,\n allowing discovering all other hosts in the cluster.\n\nMust be in the form of `host:port`, and comma-separated.",
              "type": "string"
            },
            "topics": {
              "title": "The Kafka topics names to read events from.",
              "description": "Regular expression syntax is supported if the topic begins with `^`.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "group_id": {
              "description": "The consumer group name to be used to consume events from Kafka.",
              "type": "string"
            },
            "auto_offset_reset": {
              "title": "If offsets for consumer group do not exist, set them using this strategy.",
              "description": "See the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for the `auto.offset.reset` option for further clarification.",
              "default": "largest",
              "type": "string"
            },
            "session_timeout_ms": {
              "description": "The Kafka session timeout, in milliseconds.",
              "default": 10000,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "socket_timeout_ms": {
              "description": "Timeout for network requests, in milliseconds.",
              "default": 60000,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "fetch_wait_max_ms": {
              "description": "Maximum time the broker may wait to fill the response, in milliseconds.",
              "default": 100,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "commit_interval_ms": {
              "description": "The frequency that the consumer offsets are committed (written) to offset storage, in milliseconds.",
              "default": 5000,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "key_field": {
              "title": "Overrides the name of the log field used to add the message key to each event.",
              "description": "The value will be the message key of the Kafka message itself.\n\nBy default, `\"message_key\"` is used.",
              "default": "message_key",
              "type": "string"
            },
            "topic_key": {
              "title": "Overrides the name of the log field used to add the topic to each event.",
              "description": "The value will be the topic from which the Kafka message was consumed from.\n\nBy default, `\"topic\"` is used.",
              "default": "topic",
              "type": "string"
            },
            "partition_key": {
              "title": "Overrides the name of the log field used to add the partition to each event.",
              "description": "The value will be the partition from which the Kafka message was consumed from.\n\nBy default, `\"partition\"` is used.",
              "default": "partition",
              "type": "string"
            },
            "offset_key": {
              "title": "Overrides the name of the log field used to add the offset to each event.",
              "description": "The value will be the offset of the Kafka message itself.\n\nBy default, `\"offset\"` is used.",
              "default": "offset",
              "type": "string"
            },
            "headers_key": {
              "title": "Overrides the name of the log field used to add the headers to each event.",
              "description": "The value will be the headers of the Kafka message itself.\n\nBy default, `\"headers\"` is used.",
              "default": "headers",
              "type": "string"
            },
            "librdkafka_options": {
              "title": "Advanced options set directly on the underlying `librdkafka` client.",
              "description": "See the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for details.",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              }
            },
            "framing": {
              "description": "Configuration for building a `Framer`.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            },
            "decoding": {
              "description": "Configuration for building a `Deserializer`.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Kafka authentication configuration.",
          "$ref": "#/definitions/vector::kafka::KafkaAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::kafka::KafkaAuthConfig": {
      "description": "Kafka authentication configuration.",
      "type": "object",
      "properties": {
        "sasl": {
          "description": "Configuration for SASL authentication when interacting with Kafka.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::kafka::KafkaSaslConfig"
            }
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        }
      }
    },
    "vector::kafka::KafkaSaslConfig": {
      "description": "Configuration for SASL authentication when interacting with Kafka.",
      "type": "object",
      "properties": {
        "enabled": {
          "title": "Enables SASL authentication.",
          "description": "Only `PLAIN` and `SCRAM`-based mechanisms are supported when configuring SASL authentication via `sasl.*`. For\n other mechanisms, `librdkafka_options.*` must be used directly to configure other `librdkafka`-specific values\n i.e. `sasl.kerberos.*` and so on.\n\nSee the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for details.\n\nSASL authentication is not supported on Windows.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "username": {
          "description": "The SASL username.",
          "type": [
            "string",
            "null"
          ]
        },
        "password": {
          "description": "The SASL password.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "mechanism": {
          "description": "The SASL mechanism to use.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::sources::kubernetes_logs::Config": {
      "description": "Configuration for the `kubernetes_logs` source.",
      "default": {
        "extra_label_selector": "",
        "extra_namespace_label_selector": "",
        "self_node_name": "${VECTOR_SELF_NODE_NAME}",
        "extra_field_selector": "",
        "auto_partial_merge": true,
        "data_dir": null,
        "pod_annotation_fields": {
          "pod_name": "kubernetes.pod_name",
          "pod_namespace": "kubernetes.pod_namespace",
          "pod_uid": "kubernetes.pod_uid",
          "pod_ip": "kubernetes.pod_ip",
          "pod_ips": "kubernetes.pod_ips",
          "pod_labels": "kubernetes.pod_labels",
          "pod_annotations": "kubernetes.pod_annotations",
          "pod_node_name": "kubernetes.pod_node_name",
          "pod_owner": "kubernetes.pod_owner",
          "container_name": "kubernetes.container_name",
          "container_id": "kubernetes.container_id",
          "container_image": "kubernetes.container_image"
        },
        "namespace_annotation_fields": {
          "namespace_labels": "kubernetes.namespace_labels"
        },
        "node_annotation_fields": {
          "node_labels": "kubernetes.node_labels"
        },
        "exclude_paths_glob_patterns": [
          "**/*.gz",
          "**/*.tmp"
        ],
        "max_read_bytes": 2048,
        "max_line_bytes": 32768,
        "fingerprint_lines": 1,
        "glob_minimum_cooldown_ms": 60000,
        "ingestion_timestamp_field": null,
        "timezone": null,
        "kube_config_file": null,
        "delay_deletion_ms": 60000
      },
      "type": "object",
      "properties": {
        "extra_label_selector": {
          "description": "Specifies the label selector to filter `Pod`s with, to be used in addition to the built-in `vector.dev/exclude` filter.",
          "type": "string"
        },
        "extra_namespace_label_selector": {
          "description": "Specifies the label selector to filter `Namespace`s with, to be used in  addition to the built-in `vector.dev/exclude` filter.",
          "type": "string"
        },
        "self_node_name": {
          "title": "The `name` of the Kubernetes `Node` that Vector runs at.",
          "description": "Configured to use an environment var by default, to be evaluated to a value provided by Kubernetes at `Pod` deploy time.",
          "type": "string"
        },
        "extra_field_selector": {
          "description": "Specifies the field selector to filter `Pod`s with, to be used in addition to the built-in `Node` filter.",
          "type": "string"
        },
        "auto_partial_merge": {
          "description": "Whether or not to automatically merge partial events.",
          "type": "boolean"
        },
        "data_dir": {
          "title": "The directory used to persist file checkpoint positions.",
          "description": "By default, the global `data_dir` option is used. Please make sure the user Vector is running as has write permissions to this directory.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "pod_annotation_fields": {
          "description": "Configuration for how the events are annotated with `Pod` metadata.",
          "default": {
            "pod_name": "kubernetes.pod_name",
            "pod_namespace": "kubernetes.pod_namespace",
            "pod_uid": "kubernetes.pod_uid",
            "pod_ip": "kubernetes.pod_ip",
            "pod_ips": "kubernetes.pod_ips",
            "pod_labels": "kubernetes.pod_labels",
            "pod_annotations": "kubernetes.pod_annotations",
            "pod_node_name": "kubernetes.pod_node_name",
            "pod_owner": "kubernetes.pod_owner",
            "container_name": "kubernetes.container_name",
            "container_id": "kubernetes.container_id",
            "container_image": "kubernetes.container_image"
          },
          "$ref": "#/definitions/vector::sources::kubernetes_logs::pod_metadata_annotator::FieldsSpec"
        },
        "namespace_annotation_fields": {
          "description": "Configuration for how the events are annotated with Namespace metadata.",
          "default": {
            "namespace_labels": "kubernetes.namespace_labels"
          },
          "$ref": "#/definitions/vector::sources::kubernetes_logs::namespace_metadata_annotator::FieldsSpec"
        },
        "node_annotation_fields": {
          "description": "Configuration for how the events are annotated with Node metadata.",
          "default": {
            "node_labels": "kubernetes.node_labels"
          },
          "$ref": "#/definitions/vector::sources::kubernetes_logs::node_metadata_annotator::FieldsSpec"
        },
        "exclude_paths_glob_patterns": {
          "description": "A list of glob patterns to exclude from reading the files.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          }
        },
        "max_read_bytes": {
          "description": "Max amount of bytes to read from a single file before switching over\n to the next file.\n This allows distributing the reads more or less evenly across\n the files.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_line_bytes": {
          "description": "The maximum number of bytes a line can contain before being discarded. This protects\n against malformed lines or tailing incorrect files.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "fingerprint_lines": {
          "description": "How many first lines in a file are used for fingerprinting.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "glob_minimum_cooldown_ms": {
          "description": "This value specifies not exactly the globbing, but interval\n between the polling the files to watch from the `paths_provider`.\n This is quite efficient, yet might still create some load of the\n file system; in addition, it is currently coupled with chechsum dumping\n in the underlying file server, so setting it too low may introduce\n a significant overhead.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "ingestion_timestamp_field": {
          "description": "A field to use to set the timestamp when Vector ingested the event.\n This is useful to compute the latency between important event processing\n stages, i.e. the time delta between log line was written and when it was\n processed by the `kubernetes_logs` source.",
          "type": [
            "string",
            "null"
          ]
        },
        "timezone": {
          "title": "Timezone reference.",
          "description": "The default time zone for timestamps without an explicit zone.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Timezone reference.",
              "$ref": "#/definitions/vector_common::datetime::TimeZone"
            }
          ]
        },
        "kube_config_file": {
          "description": "Optional path to a kubeconfig file readable by Vector. If not set,\n Vector will try to connect to Kubernetes using in-cluster configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "delay_deletion_ms": {
          "description": "How long to delay removing entries from our map when we receive a deletion\n event from the watched stream.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::kubernetes_logs::pod_metadata_annotator::FieldsSpec": {
      "description": "Configuration for how the events are annotated with `Pod` metadata.",
      "default": {
        "pod_name": "kubernetes.pod_name",
        "pod_namespace": "kubernetes.pod_namespace",
        "pod_uid": "kubernetes.pod_uid",
        "pod_ip": "kubernetes.pod_ip",
        "pod_ips": "kubernetes.pod_ips",
        "pod_labels": "kubernetes.pod_labels",
        "pod_annotations": "kubernetes.pod_annotations",
        "pod_node_name": "kubernetes.pod_node_name",
        "pod_owner": "kubernetes.pod_owner",
        "container_name": "kubernetes.container_name",
        "container_id": "kubernetes.container_id",
        "container_image": "kubernetes.container_image"
      },
      "type": "object",
      "properties": {
        "pod_name": {
          "description": "Event field for Pod name.",
          "type": "string"
        },
        "pod_namespace": {
          "description": "Event field for Pod namespace.",
          "type": "string"
        },
        "pod_uid": {
          "description": "Event field for Pod uid.",
          "type": "string"
        },
        "pod_ip": {
          "description": "Event field for Pod IPv4 address.",
          "type": "string"
        },
        "pod_ips": {
          "description": "Event field for Pod IPv4 and IPv6 addresses.",
          "type": "string"
        },
        "pod_labels": {
          "description": "Event field for Pod labels.",
          "type": "string"
        },
        "pod_annotations": {
          "description": "Event field for Pod annotations.",
          "type": "string"
        },
        "pod_node_name": {
          "description": "Event field for Pod node_name.",
          "type": "string"
        },
        "pod_owner": {
          "description": "Event field for Pod owner reference.",
          "type": "string"
        },
        "container_name": {
          "description": "Event field for container name.",
          "type": "string"
        },
        "container_id": {
          "description": "Event field for container ID.",
          "type": "string"
        },
        "container_image": {
          "description": "Event field for container image.",
          "type": "string"
        }
      }
    },
    "vector::sources::kubernetes_logs::namespace_metadata_annotator::FieldsSpec": {
      "description": "Configuration for how the events are annotated with Namespace metadata.",
      "default": {
        "namespace_labels": "kubernetes.namespace_labels"
      },
      "type": "object",
      "properties": {
        "namespace_labels": {
          "description": "Event field for Namespace labels.",
          "type": "string"
        }
      }
    },
    "vector::sources::kubernetes_logs::node_metadata_annotator::FieldsSpec": {
      "description": "Configuration for how the events are annotated with Node metadata.",
      "default": {
        "node_labels": "kubernetes.node_labels"
      },
      "type": "object",
      "properties": {
        "node_labels": {
          "description": "Event field for Node labels.",
          "type": "string"
        }
      }
    },
    "vector::sources::logstash::LogstashConfig": {
      "description": "Configuration for the `logstash` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/vector::sources::util::tcp::SocketListenAddr"
        },
        "keepalive": {
          "description": "TCP keepalive settings for socket-based components.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
            }
          ]
        },
        "tls": {
          "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsSourceConfig"
            }
          ]
        },
        "receive_buffer_bytes": {
          "title": "The size, in bytes, of the receive buffer used for each connection.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "connection_limit": {
          "description": "The maximum number of TCP connections that will be allowed at any given time.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::mongodb_metrics::MongoDbMetricsConfig": {
      "description": "Configuration for the `mongodb_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "title": "A list of MongoDB instances to scrape.",
          "description": "Each endpoint must be in the [Connection String URI Format](https://www.mongodb.com/docs/manual/reference/connection-string/).",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "If set to an empty string, no namespace is added to the metrics.\n\nBy default, `mongodb` is used.",
          "default": "mongodb",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::nats::NatsSourceConfig": {
      "description": "Configuration for the `nats` source.",
      "type": "object",
      "required": [
        "connection_name",
        "subject",
        "url"
      ],
      "properties": {
        "url": {
          "title": "The NATS URL to connect to.",
          "description": "The URL must take the form of `nats://server:port`.",
          "type": "string"
        },
        "connection_name": {
          "description": "A name assigned to the NATS connection.",
          "type": "string"
        },
        "subject": {
          "description": "The NATS subject to publish messages to.",
          "type": "string",
          "_metadata": {
            "templateable": true
          }
        },
        "queue": {
          "description": "NATS Queue Group to join.",
          "type": [
            "string",
            "null"
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "auth": {
          "description": "Configuration of the authentication strategy when interacting with NATS.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::nats::NatsAuthConfig"
            }
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::nats::NatsAuthConfig": {
      "description": "Configuration of the authentication strategy when interacting with NATS.",
      "oneOf": [
        {
          "description": "Username and password authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/username_password))",
          "type": "object",
          "required": [
            "strategy",
            "user_password"
          ],
          "properties": {
            "user_password": {
              "description": "Username and password configuration.",
              "$ref": "#/definitions/vector::nats::NatsAuthUserPassword"
            },
            "strategy": {
              "description": "Username and password authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/username_password))",
              "const": "user_password",
              "_metadata": {
                "logical_name": "UserPassword"
              }
            }
          },
          "_metadata": {
            "logical_name": "UserPassword"
          }
        },
        {
          "description": "Token authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/tokens))",
          "type": "object",
          "required": [
            "strategy",
            "token"
          ],
          "properties": {
            "token": {
              "description": "Token configuration.",
              "$ref": "#/definitions/vector::nats::NatsAuthToken"
            },
            "strategy": {
              "description": "Token authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/tokens))",
              "const": "token",
              "_metadata": {
                "logical_name": "Token"
              }
            }
          },
          "_metadata": {
            "logical_name": "Token"
          }
        },
        {
          "description": "Credentials file authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/jwt))",
          "type": "object",
          "required": [
            "credentials_file",
            "strategy"
          ],
          "properties": {
            "credentials_file": {
              "description": "Credentials file configuration.",
              "$ref": "#/definitions/vector::nats::NatsAuthCredentialsFile"
            },
            "strategy": {
              "description": "Credentials file authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/jwt))",
              "const": "credentials_file",
              "_metadata": {
                "logical_name": "CredentialsFile"
              }
            }
          },
          "_metadata": {
            "logical_name": "CredentialsFile"
          }
        },
        {
          "description": "NKey authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth))",
          "type": "object",
          "required": [
            "nkey",
            "strategy"
          ],
          "properties": {
            "nkey": {
              "description": "NKeys configuration.",
              "$ref": "#/definitions/vector::nats::NatsAuthNKey"
            },
            "strategy": {
              "description": "NKey authentication.\n ([documentation](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth))",
              "const": "nkey",
              "_metadata": {
                "logical_name": "Nkey"
              }
            }
          },
          "_metadata": {
            "logical_name": "Nkey"
          }
        }
      ]
    },
    "vector::nats::NatsAuthUserPassword": {
      "description": "Username and password configuration.",
      "type": "object",
      "required": [
        "password",
        "user"
      ],
      "properties": {
        "user": {
          "description": "Username.",
          "type": "string"
        },
        "password": {
          "description": "Password.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        }
      }
    },
    "vector::nats::NatsAuthToken": {
      "description": "Token configuration.",
      "type": "object",
      "required": [
        "value"
      ],
      "properties": {
        "value": {
          "description": "Token.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        }
      }
    },
    "vector::nats::NatsAuthCredentialsFile": {
      "description": "Credentials file configuration.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "Path to credentials file.",
          "type": "string"
        }
      }
    },
    "vector::nats::NatsAuthNKey": {
      "description": "NKeys configuration.",
      "type": "object",
      "required": [
        "nkey",
        "seed"
      ],
      "properties": {
        "nkey": {
          "title": "User.",
          "description": "Conceptually, this is equivalent to a public key.",
          "type": "string"
        },
        "seed": {
          "title": "Seed.",
          "description": "Conceptually, this is equivalent to a private key.",
          "type": "string"
        }
      }
    },
    "vector::sources::nginx_metrics::NginxMetricsConfig": {
      "description": "Configuration for the `nginx_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "title": "A list of NGINX instances to scrape.",
          "description": "Each endpoint must be a valid HTTP/HTTPS URI pointing to an NGINX instance that has the\n `ngx_http_stub_status_module` module enabled.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "If set to an empty string, no namespace is added to the metrics.\n\nBy default, `nginx` is used.",
          "default": "nginx",
          "type": "string"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::opentelemetry::OpentelemetryConfig": {
      "description": "Configuration for the `opentelemetry` source.",
      "type": "object",
      "required": [
        "grpc",
        "http"
      ],
      "properties": {
        "grpc": {
          "description": "Configuration for the `opentelemetry` gRPC server.",
          "$ref": "#/definitions/vector::sources::opentelemetry::GrpcConfig"
        },
        "http": {
          "description": "Configuration for the `opentelemetry` HTTP server.",
          "$ref": "#/definitions/vector::sources::opentelemetry::HttpConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::opentelemetry::GrpcConfig": {
      "description": "Configuration for the `opentelemetry` gRPC server.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "title": "The address to listen for connections on.",
          "description": "It _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        }
      }
    },
    "vector::sources::opentelemetry::HttpConfig": {
      "description": "Configuration for the `opentelemetry` HTTP server.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "title": "The address to listen for connections on.",
          "description": "It _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        }
      }
    },
    "vector::sources::postgresql_metrics::PostgresqlMetricsConfig": {
      "description": "Configuration for the `postgresql_metrics` source.",
      "default": {
        "endpoints": [],
        "include_databases": null,
        "exclude_databases": null,
        "scrape_interval_secs": 15,
        "namespace": "postgresql",
        "tls": null
      },
      "type": "object",
      "properties": {
        "endpoints": {
          "title": "A list of PostgreSQL instances to scrape.",
          "description": "Each endpoint must be in the [Connection URI\n format](https://www.postgresql.org/docs/current/libpq-connect.html#id-1.7.3.8.3.6).",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "include_databases": {
          "title": "A list of databases to match (by using [POSIX Regular\n Expressions](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP)) against\n the `datname` column for which you want to collect metrics from.",
          "description": "If not set, metrics are collected from all databases. Specifying `\"\"` will include metrics where `datname` is\n `NULL`.\n\nThis can be used in conjunction with `exclude_databases`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "exclude_databases": {
          "title": "A list of databases to match (by using [POSIX Regular\n Expressions](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP)) against\n the `datname` column for which you don’t want to collect metrics from.",
          "description": "Specifying `\"\"` will include metrics where `datname` is `NULL`.\n\nThis can be used in conjunction with `include_databases`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "By default, `postgresql` is used.",
          "type": "string"
        },
        "tls": {
          "description": "Configuration of TLS when connecting to PostgreSQL.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::postgresql_metrics::PostgresqlMetricsTlsConfig"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::postgresql_metrics::PostgresqlMetricsTlsConfig": {
      "description": "Configuration of TLS when connecting to PostgreSQL.",
      "type": "object",
      "required": [
        "ca_file"
      ],
      "properties": {
        "ca_file": {
          "title": "Absolute path to an additional CA certificate file.",
          "description": "The certficate must be in the DER or PEM (X.509) format.",
          "$ref": "#/definitions/stdlib::PathBuf"
        }
      }
    },
    "vector::sources::prometheus::scrape::PrometheusScrapeConfig": {
      "description": "Configuration for the `prometheus_scrape` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "description": "Endpoints to scrape metrics from.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "instance_tag": {
          "title": "Overrides the name of the tag used to add the instance to each metric.",
          "description": "The tag value will be the host/port of the scraped instance.\n\nBy default, `\"instance\"` is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "endpoint_tag": {
          "title": "Overrides the name of the tag used to add the endpoint to each metric.",
          "description": "The tag value will be the endpoint of the scraped instance.\n\nBy default, `\"endpoint\"` is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "honor_labels": {
          "title": "Controls how tag conflicts are handled if the scraped source has tags that Vector would add.",
          "description": "If `true`, Vector will not add the new tag if the scraped metric has the tag already. If `false`, Vector will\n rename the conflicting tag by prepending `exported_` to the name.\n\nThis matches Prometheus’ `honor_labels` configuration.",
          "default": false,
          "type": "boolean"
        },
        "query": {
          "title": "Custom parameters for the scrape request query string.",
          "description": "One or more values for the same parameter key can be provided. The parameters provided in this option are\n appended to any parameters manually provided in the `endpoints` option. This option is especially useful when\n scraping the `/federate` endpoint.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::prometheus::remote_write::PrometheusRemoteWriteConfig": {
      "description": "Configuration for the `prometheus_remote_write` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "title": "The address to accept connections on.",
          "description": "The address _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "auth": {
          "description": "HTTP Basic authentication configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::util::http::auth::HttpSourceAuthConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::redis::RedisSourceConfig": {
      "description": "Configuration for the `redis` source.",
      "type": "object",
      "required": [
        "key",
        "url"
      ],
      "properties": {
        "data_type": {
          "description": "The Redis data type (`list` or `channel`) to use.",
          "default": "list",
          "$ref": "#/definitions/vector::sources::redis::DataTypeConfig"
        },
        "list": {
          "description": "Options for the Redis `list` data type.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::redis::ListOption"
            }
          ]
        },
        "url": {
          "title": "The Redis URL to connect to.",
          "description": "The URL must take the form of `protocol://server:port/db` where the `protocol` can either be `redis` or `rediss` for connections secured via TLS.",
          "type": "string"
        },
        "key": {
          "description": "The Redis key to read messages from.",
          "type": "string"
        },
        "redis_key": {
          "title": "Sets the name of the log field to use to add the key to each event.",
          "description": "The value will be the Redis key that the event was read from.\n\nBy default, this is not set and the field will not be automatically added.",
          "type": [
            "string",
            "null"
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::redis::DataTypeConfig": {
      "description": "Data type to use for reading messages from Redis.",
      "oneOf": [
        {
          "description": "The `list` data type.",
          "const": "list",
          "_metadata": {
            "logical_name": "List"
          }
        },
        {
          "title": "The `channel` data type.",
          "description": "This is based on Redis' Pub/Sub capabilities.",
          "const": "channel",
          "_metadata": {
            "logical_name": "Channel"
          }
        }
      ]
    },
    "vector::sources::redis::ListOption": {
      "description": "Options for the Redis `list` data type.",
      "type": "object",
      "required": [
        "method"
      ],
      "properties": {
        "method": {
          "description": "Method for getting events from the `list` data type.",
          "$ref": "#/definitions/vector::sources::redis::Method"
        }
      }
    },
    "vector::sources::redis::Method": {
      "description": "Method for getting events from the `list` data type.",
      "oneOf": [
        {
          "description": "Pop messages from the head of the list.",
          "const": "lpop",
          "_metadata": {
            "logical_name": "Lpop"
          }
        },
        {
          "description": "Pop messages from the tail of the list.",
          "const": "rpop",
          "_metadata": {
            "logical_name": "Rpop"
          }
        }
      ]
    },
    "vector::sources::socket::SocketConfig": {
      "description": "Configuration for the `socket` source.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "description": "Listening mode for the `socket` source.",
          "$ref": "#/definitions/vector::sources::socket::Mode"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::socket::Mode": {
      "description": "Listening mode for the `socket` source.",
      "oneOf": [
        {
          "description": "Listen on TCP.",
          "allOf": [
            {
              "description": "TCP configuration for the `socket` source.",
              "$ref": "#/definitions/vector::sources::socket::tcp::TcpConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "tcp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Tcp"
          }
        },
        {
          "description": "Listen on UDP.",
          "allOf": [
            {
              "description": "UDP configuration for the `socket` source.",
              "$ref": "#/definitions/vector::sources::socket::udp::UdpConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "udp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Udp"
          }
        },
        {
          "description": "Listen on UDS, in datagram mode. (Unix domain socket)",
          "allOf": [
            {
              "description": "Unix domain socket configuration for the `socket` source.",
              "$ref": "#/definitions/vector::sources::socket::unix::UnixConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "unix_datagram"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "UnixDatagram"
          }
        },
        {
          "description": "Listen on UDS, in stream mode. (Unix domain socket)",
          "allOf": [
            {
              "description": "Unix domain socket configuration for the `socket` source.",
              "$ref": "#/definitions/vector::sources::socket::unix::UnixConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "unix_stream"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "UnixStream"
          }
        }
      ]
    },
    "vector::sources::socket::tcp::TcpConfig": {
      "description": "TCP configuration for the `socket` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/vector::sources::util::tcp::SocketListenAddr"
        },
        "keepalive": {
          "description": "TCP keepalive settings for socket-based components.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
            }
          ]
        },
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "shutdown_timeout_secs": {
          "description": "The timeout, in seconds, before a connection is forcefully closed during shutdown.",
          "default": 30,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the peer host to each event.",
          "description": "The value will be the peer host's address, including the port i.e. `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "port_key": {
          "title": "Overrides the name of the log field used to add the peer host's port to each event.",
          "description": "The value will be the peer host's port i.e. `9000`.\n\nBy default, `\"port\"` is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "tls": {
          "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsSourceConfig"
            }
          ]
        },
        "receive_buffer_bytes": {
          "title": "The size, in bytes, of the receive buffer used for each connection.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "connection_limit": {
          "description": "The maximum number of TCP connections that will be allowed at any given time.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            }
          ]
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      }
    },
    "vector::sources::socket::udp::UdpConfig": {
      "description": "UDP configuration for the `socket` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for messages on.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "default": 102400,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the peer host to each event.",
          "description": "The value will be the peer host's address, including the port i.e. `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "port_key": {
          "title": "Overrides the name of the log field used to add the peer host's port to each event.",
          "description": "The value will be the peer host's port i.e. `9000`.\n\nBy default, `\"port\"` is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "receive_buffer_bytes": {
          "title": "The size, in bytes, of the receive buffer used for the listening socket.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig"
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      }
    },
    "vector::sources::socket::unix::UnixConfig": {
      "description": "Unix domain socket configuration for the `socket` source.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "title": "The Unix socket path.",
          "description": "This should be an absolute path.",
          "$ref": "#/definitions/stdlib::PathBuf"
        },
        "socket_file_mode": {
          "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
          "description": "Note that the file mode value can be specified in any numeric format supported by your configuration\n language, but it is most intuitive to use an octal number.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the peer host to each event.",
          "description": "The value will be the socket path itself.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            }
          ]
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      }
    },
    "vector::sources::splunk_hec::SplunkConfig": {
      "description": "Configuration for the `splunk_hec` source.",
      "default": {
        "address": "0.0.0.0:8088",
        "token": null,
        "valid_tokens": null,
        "store_hec_token": false,
        "tls": null,
        "acknowledgements": {
          "enabled": null,
          "max_pending_acks": 10000000,
          "max_number_of_ack_channels": 1000000,
          "max_pending_acks_per_channel": 1000000,
          "ack_idle_cleanup": false,
          "max_idle_time": 300
        }
      },
      "type": "object",
      "properties": {
        "address": {
          "title": "The address to listen for connections on.",
          "description": "The address _must_ include a port.",
          "default": "0.0.0.0:8088",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "token": {
          "title": "Optional authorization token.",
          "description": "If supplied, incoming requests must supply this token in the `Authorization` header, just as a client would if\n it was communicating with the Splunk HEC endpoint directly.\n\nIf _not_ supplied, the `Authorization` header will be ignored and requests will not be authenticated.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "valid_tokens": {
          "title": "Optional list of valid authorization tokens.",
          "description": "If supplied, incoming requests must supply one of these tokens in the `Authorization` header, just as a client\n would if it was communicating with the Splunk HEC endpoint directly.\n\nIf _not_ supplied, the `Authorization` header will be ignored and requests will not be authenticated.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
          }
        },
        "store_hec_token": {
          "title": "Whether or not to forward the Splunk HEC authentication token with events.",
          "description": "If set to `true`, when incoming requests contain a Splunk HEC token, the token used will kept in the\n event metadata and be preferentially used if the event is sent to a Splunk HEC sink.",
          "type": "boolean"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Acknowledgement configuration for the `splunk_hec` source.",
          "default": {
            "enabled": null,
            "max_pending_acks": 10000000,
            "max_number_of_ack_channels": 1000000,
            "max_pending_acks_per_channel": 1000000,
            "ack_idle_cleanup": false,
            "max_idle_time": 300
          },
          "$ref": "#/definitions/vector::sources::splunk_hec::acknowledgements::HecAcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::splunk_hec::acknowledgements::HecAcknowledgementsConfig": {
      "description": "Acknowledgement configuration for the `splunk_hec` source.",
      "default": {
        "enabled": null,
        "max_pending_acks": 10000000,
        "max_number_of_ack_channels": 1000000,
        "max_pending_acks_per_channel": 1000000,
        "ack_idle_cleanup": false,
        "max_idle_time": 300
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "max_pending_acks": {
              "title": "The maximum number of ack statuses pending query across all channels.",
              "description": "Equivalent to the `max_number_of_acked_requests_pending_query` Splunk HEC setting.\n\nMinimum of `1`.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            },
            "max_number_of_ack_channels": {
              "title": "The maximum number of Splunk HEC channels clients can use with this source.",
              "description": "Minimum of `1`.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            },
            "max_pending_acks_per_channel": {
              "title": "The maximum number of ack statuses pending query for a single channel.",
              "description": "Equivalent to the `max_number_of_acked_requests_pending_query_per_ack_channel` Splunk HEC setting.\n\nMinimum of `1`.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            },
            "ack_idle_cleanup": {
              "title": "Whether or not to remove channels after idling for `max_idle_time` seconds.",
              "description": "A channel is idling if it is not used for sending data or querying ack statuses.",
              "type": "boolean"
            },
            "max_idle_time": {
              "title": "The amount of time, in seconds, a channel is allowed to idle before removal.",
              "description": "Channels can potentially idle for longer than this setting but clients should not rely on such behavior.\n\nMinimum of `1`.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            }
          }
        },
        {
          "description": "Configuration of acknowledgement behavior.",
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      ]
    },
    "vector::sources::statsd::StatsdConfig": {
      "description": "Configuration for the `statsd` source.",
      "oneOf": [
        {
          "description": "Listen on TCP.",
          "allOf": [
            {
              "description": "TCP configuration for the `statsd` source.",
              "$ref": "#/definitions/vector::sources::statsd::TcpConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "tcp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Tcp"
          }
        },
        {
          "description": "Listen on UDP.",
          "allOf": [
            {
              "description": "UDP configuration for the `statsd` source.",
              "$ref": "#/definitions/vector::sources::statsd::UdpConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "udp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Udp"
          }
        },
        {
          "description": "Listen on UDS. (Unix domain socket)",
          "allOf": [
            {
              "description": "Unix domain socket configuration for the `statsd` source.",
              "$ref": "#/definitions/vector::sources::statsd::unix::UnixConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "unix"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Unix"
          }
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::statsd::TcpConfig": {
      "description": "TCP configuration for the `statsd` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for connections on.",
          "$ref": "#/definitions/vector::sources::util::tcp::SocketListenAddr"
        },
        "keepalive": {
          "description": "TCP keepalive settings for socket-based components.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
            }
          ]
        },
        "tls": {
          "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsSourceConfig"
            }
          ]
        },
        "shutdown_timeout_secs": {
          "description": "The timeout before a connection is forcefully closed during shutdown.",
          "default": 30,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "receive_buffer_bytes": {
          "title": "The size, in bytes, of the receive buffer used for each connection.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "connection_limit": {
          "description": "The maximum number of TCP connections that will be allowed at any given time.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sources::statsd::UdpConfig": {
      "description": "UDP configuration for the `statsd` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "The address to listen for messages on.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "receive_buffer_bytes": {
          "title": "The size, in bytes, of the receive buffer used for each connection.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sources::statsd::unix::UnixConfig": {
      "description": "Unix domain socket configuration for the `statsd` source.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "title": "The Unix socket path.",
          "description": "This should be an absolute path.",
          "$ref": "#/definitions/stdlib::PathBuf"
        }
      }
    },
    "vector::sources::file_descriptors::stdin::StdinConfig": {
      "description": "Configuration for the `stdin` source.",
      "default": {
        "max_length": 102400,
        "host_key": null,
        "framing": null,
        "decoding": {
          "codec": "bytes"
        }
      },
      "type": "object",
      "properties": {
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "default": 102400,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "The value will be the current hostname for wherever Vector is running.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "framing": {
          "description": "Configuration for building a `Framer`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::decoding::FramingConfig"
            }
          ]
        },
        "decoding": {
          "description": "Configuration for building a `Deserializer`.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::syslog::SyslogConfig": {
      "description": "Configuration for the `syslog` source.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "max_length": {
              "title": "The maximum buffer size of incoming messages, in bytes.",
              "description": "Messages larger than this are truncated.",
              "default": 102400,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "host_key": {
              "title": "Overrides the name of the log field used to add the peer host to each event.",
              "description": "If using TCP or UDP, the value will be the peer host's address, including the port i.e. `1.2.3.4:9000`. If using\n UDS, the value will be the socket path itself.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "type": [
                "string",
                "null"
              ]
            }
          }
        },
        {
          "description": "Listener mode for the `syslog` source.",
          "$ref": "#/definitions/vector::sources::syslog::Mode"
        }
      ],
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::syslog::Mode": {
      "description": "Listener mode for the `syslog` source.",
      "oneOf": [
        {
          "description": "Listen on TCP.",
          "type": "object",
          "required": [
            "address",
            "mode"
          ],
          "properties": {
            "address": {
              "description": "The address to listen for connections on.",
              "$ref": "#/definitions/vector::sources::util::tcp::SocketListenAddr"
            },
            "keepalive": {
              "description": "TCP keepalive settings for socket-based components.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
                }
              ]
            },
            "tls": {
              "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsSourceConfig"
                }
              ]
            },
            "receive_buffer_bytes": {
              "title": "The size, in bytes, of the receive buffer used for each connection.",
              "description": "This should not typically needed to be changed.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "connection_limit": {
              "description": "The maximum number of TCP connections that will be allowed at any given time.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 4294967295.0,
              "minimum": 0.0
            },
            "mode": {
              "description": "Listen on TCP.",
              "const": "tcp",
              "_metadata": {
                "logical_name": "Tcp"
              }
            }
          },
          "_metadata": {
            "logical_name": "Tcp"
          }
        },
        {
          "description": "Listen on UDP.",
          "type": "object",
          "required": [
            "address",
            "mode"
          ],
          "properties": {
            "address": {
              "description": "The address to listen for messages on.",
              "$ref": "#/definitions/stdlib::SocketAddr"
            },
            "receive_buffer_bytes": {
              "title": "The size, in bytes, of the receive buffer used for the listening socket.",
              "description": "This should not typically needed to be changed.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "mode": {
              "description": "Listen on UDP.",
              "const": "udp",
              "_metadata": {
                "logical_name": "Udp"
              }
            }
          },
          "_metadata": {
            "logical_name": "Udp"
          }
        },
        {
          "description": "Listen on UDS. (Unix domain socket)",
          "type": "object",
          "required": [
            "mode",
            "path"
          ],
          "properties": {
            "path": {
              "title": "The Unix socket path.",
              "description": "This should be an absolute path.",
              "$ref": "#/definitions/stdlib::PathBuf"
            },
            "socket_file_mode": {
              "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
              "description": "Note that the file mode value can be specified in any numeric format supported by your configuration\n language, but it is most intuitive to use an octal number.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 4294967295.0,
              "minimum": 0.0
            },
            "mode": {
              "description": "Listen on UDS. (Unix domain socket)",
              "const": "unix",
              "_metadata": {
                "logical_name": "Unix"
              }
            }
          },
          "_metadata": {
            "logical_name": "Unix"
          }
        }
      ]
    },
    "vector::config::unit_test::unit_test_components::UnitTestSourceConfig": {
      "description": "Configuration for the `unit_test` source.",
      "type": "object",
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestStreamSourceConfig": {
      "description": "Configuration for the `unit_test_stream` source.",
      "type": "object",
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::vector::VectorConfig": {
      "description": "Configuration for the `vector` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "version": {
          "description": "Version of the configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sources::vector::VectorConfigVersion"
            }
          ]
        },
        "address": {
          "title": "The address to listen for connections on.",
          "description": "It _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "source"
      }
    },
    "vector::sources::vector::VectorConfigVersion": {
      "description": "Marker type for the version two of the configuration for the `vector` source.",
      "oneOf": [
        {
          "description": "Marker value for version two.",
          "const": "2",
          "_metadata": {
            "logical_name": "V2"
          }
        }
      ]
    },
    "vector::config::sink::SinkOuter<alloc::string::String>": {
      "description": "Fully resolved sink component.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "inputs": {
              "description": "Inputs to the sinks.",
              "default": [],
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "healthcheck_uri": {
              "title": "The full URI to make HTTP healthcheck requests to.",
              "description": "This must be a valid URI, which requires at least the scheme and host. All other\n components -- port, path, etc -- are allowed as well.",
              "deprecated": true,
              "format": "uri",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "The URI component of a request.",
                  "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
                }
              ]
            },
            "healthcheck": {
              "description": "Healthcheck configuration.",
              "default": {
                "enabled": true,
                "uri": null
              },
              "$ref": "#/definitions/vector::config::sink::SinkHealthcheckOptions"
            },
            "buffer": {
              "title": "Buffer configuration.",
              "description": "Buffers are compromised of stages(*) that form a buffer _topology_, with input items being\n subject to configurable behavior when each stage reaches configured limits.  Buffers are\n configured for sinks, where backpressure from the sink can be handled by the buffer.  This\n allows absorbing temporary load, or potentially adding write-ahead-log behavior to a sink to\n increase the durability of a given Vector pipeline.\n\nWhile we use the term \"buffer topology\" here, a buffer topology is referred to by the more\n common \"buffer\" or \"buffers\" shorthand.  This is related to buffers originally being a single\n component, where you could only choose which buffer type to use.  As we expand buffer\n functionality to allow chaining buffers together, you'll see \"buffer topology\" used in internal\n documentation to correctly reflect the internal structure.",
              "default": {
                "type": "memory",
                "max_events": 500,
                "when_full": "block"
              },
              "$ref": "#/definitions/vector_buffers::config::BufferConfig"
            },
            "proxy": {
              "title": "Proxy configuration.",
              "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig"
            }
          }
        },
        {
          "description": "Configurable sinks in Vector.",
          "$ref": "#/definitions/vector::sinks::Sinks"
        }
      ]
    },
    "vector::sinks::util::uri::UriSerde": {
      "title": "The URI component of a request.",
      "description": "",
      "type": "string"
    },
    "vector::config::sink::SinkHealthcheckOptions": {
      "description": "Healthcheck configuration.",
      "default": {
        "enabled": true,
        "uri": null
      },
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Whether or not to check the health of the sink when Vector starts up.",
          "type": "boolean"
        },
        "uri": {
          "title": "The full URI to make HTTP healthcheck requests to.",
          "description": "This must be a valid URI, which requires at least the scheme and host. All other\n components -- port, path, etc -- are allowed as well.",
          "format": "uri",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "The URI component of a request.",
              "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
            }
          ]
        }
      }
    },
    "vector_buffers::config::BufferConfig": {
      "title": "Buffer configuration.",
      "description": "Buffers are compromised of stages(*) that form a buffer _topology_, with input items being\n subject to configurable behavior when each stage reaches configured limits.  Buffers are\n configured for sinks, where backpressure from the sink can be handled by the buffer.  This\n allows absorbing temporary load, or potentially adding write-ahead-log behavior to a sink to\n increase the durability of a given Vector pipeline.\n\nWhile we use the term \"buffer topology\" here, a buffer topology is referred to by the more\n common \"buffer\" or \"buffers\" shorthand.  This is related to buffers originally being a single\n component, where you could only choose which buffer type to use.  As we expand buffer\n functionality to allow chaining buffers together, you'll see \"buffer topology\" used in internal\n documentation to correctly reflect the internal structure.",
      "oneOf": [
        {
          "description": "A single stage buffer topology.",
          "$ref": "#/definitions/vector_buffers::config::BufferType",
          "_metadata": {
            "logical_name": "Single"
          }
        },
        {
          "description": "A chained buffer topology.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector_buffers::config::BufferType"
          },
          "_metadata": {
            "logical_name": "Chained"
          }
        }
      ]
    },
    "vector_buffers::config::BufferType": {
      "description": "A specific type of buffer stage.",
      "oneOf": [
        {
          "description": "A buffer stage backed by an in-memory channel provided by `tokio`.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "max_events": {
              "description": "The maximum number of events allowed in the buffer.",
              "default": 500,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            },
            "when_full": {
              "description": "Event handling behavior when a buffer is full.",
              "default": "block",
              "$ref": "#/definitions/vector_buffers::WhenFull"
            },
            "type": {
              "description": "A buffer stage backed by an in-memory channel provided by `tokio`.",
              "const": "memory",
              "_metadata": {
                "logical_name": "Memory"
              }
            }
          },
          "_metadata": {
            "logical_name": "Memory"
          }
        },
        {
          "description": "A buffer stage backed by an on-disk database, powered by LevelDB.",
          "deprecated": true,
          "type": "object",
          "required": [
            "max_size",
            "type"
          ],
          "properties": {
            "max_size": {
              "title": "The maximum size of the buffer on disk.",
              "description": "Must be at least ~256 megabytes (268435488 bytes).",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            },
            "when_full": {
              "description": "Event handling behavior when a buffer is full.",
              "default": "block",
              "$ref": "#/definitions/vector_buffers::WhenFull"
            },
            "type": {
              "description": "A buffer stage backed by an on-disk database, powered by LevelDB.",
              "deprecated": true,
              "const": "disk_v1",
              "_metadata": {
                "logical_name": "DiskV1"
              }
            }
          },
          "_metadata": {
            "logical_name": "DiskV1"
          }
        },
        {
          "description": "A buffer stage backed by disk.",
          "type": "object",
          "required": [
            "max_size",
            "type"
          ],
          "properties": {
            "max_size": {
              "title": "The maximum size of the buffer on disk.",
              "description": "Must be at least ~256 megabytes (268435488 bytes).",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            },
            "when_full": {
              "description": "Event handling behavior when a buffer is full.",
              "default": "block",
              "$ref": "#/definitions/vector_buffers::WhenFull"
            },
            "type": {
              "description": "A buffer stage backed by disk.",
              "const": "disk",
              "_metadata": {
                "logical_name": "DiskV2"
              }
            }
          },
          "_metadata": {
            "logical_name": "DiskV2"
          }
        }
      ]
    },
    "vector_buffers::WhenFull": {
      "description": "Event handling behavior when a buffer is full.",
      "oneOf": [
        {
          "title": "Wait for free space in the buffer.",
          "description": "This applies backpressure up the topology, signalling that sources should slow down\n the acceptance/consumption of events. This means that while no data is lost, data will pile\n up at the edge.",
          "const": "block",
          "_metadata": {
            "logical_name": "Block"
          }
        },
        {
          "title": "Drops the event instead of waiting for free space in buffer.",
          "description": "The event will be intentionally dropped. This mode is typically used when performance is the\n highest priority, and it is preferable to temporarily lose events rather than cause a\n slowdown in the acceptance/consumption of events.",
          "const": "drop_newest",
          "_metadata": {
            "logical_name": "DropNewest"
          }
        },
        {
          "title": "Overflows to the next stage in the buffer topology.",
          "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\n That stage may also be configured overflow, and so on, but ultimately the last stage in a\n buffer topology must use one of the other handling behaviors. This means that next stage may\n potentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
          "const": "overflow",
          "_metadata": {
            "hidden": true,
            "logical_name": "Overflow"
          }
        }
      ]
    },
    "vector::sinks::Sinks": {
      "description": "Configurable sinks in Vector.",
      "oneOf": [
        {
          "description": "AMQP.",
          "allOf": [
            {
              "title": "Configuration for the `amqp` sink.",
              "description": "Supports AMQP version 0.9.1",
              "$ref": "#/definitions/vector::sinks::amqp::config::AmqpSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "amqp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Amqp"
          }
        },
        {
          "description": "Apex Logs.",
          "allOf": [
            {
              "description": "Configuration for the `apex` sink.",
              "$ref": "#/definitions/vector::sinks::apex::ApexSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "apex"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Apex"
          }
        },
        {
          "description": "AWS CloudWatch Logs.",
          "allOf": [
            {
              "description": "Configuration for the `aws_cloudwatch_logs` sink.",
              "$ref": "#/definitions/vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_cloudwatch_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsCloudwatchLogs"
          }
        },
        {
          "description": "AWS CloudWatch Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_cloudwatch_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_cloudwatch_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsCloudwatchMetrics"
          }
        },
        {
          "description": "AWS Kinesis Firehose.",
          "allOf": [
            {
              "description": "Configuration for the `aws_kinesis_firehose` sink.",
              "$ref": "#/definitions/vector::sinks::aws_kinesis_firehose::config::KinesisFirehoseSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_kinesis_firehose"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsKinesisFirehose"
          }
        },
        {
          "description": "AWS Kinesis Streams.",
          "allOf": [
            {
              "description": "Configuration for the `aws_kinesis_streams` sink.",
              "$ref": "#/definitions/vector::sinks::aws_kinesis_streams::config::KinesisSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_kinesis_streams"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsKinesisStreams"
          }
        },
        {
          "description": "AWS S3.",
          "allOf": [
            {
              "description": "Configuration for the `aws_s3` sink.",
              "$ref": "#/definitions/vector::sinks::aws_s3::config::S3SinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_s3"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsS3"
          }
        },
        {
          "description": "AWS SQS.",
          "allOf": [
            {
              "description": "Configuration for the `aws_sqs` sink.",
              "$ref": "#/definitions/vector::sinks::aws_sqs::config::SqsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_sqs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsSqs"
          }
        },
        {
          "description": "Axiom.",
          "allOf": [
            {
              "description": "Configuration for the `axiom` sink.",
              "$ref": "#/definitions/vector::sinks::axiom::AxiomConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "axiom"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Axiom"
          }
        },
        {
          "description": "Azure Blob Storage.",
          "allOf": [
            {
              "description": "Configuration for the `azure_blob` sink.",
              "$ref": "#/definitions/vector::sinks::azure_blob::config::AzureBlobSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "azure_blob"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AzureBlob"
          }
        },
        {
          "description": "Azure Monitor Logs.",
          "allOf": [
            {
              "description": "Configuration for the `azure_monitor_logs` sink.",
              "$ref": "#/definitions/vector::sinks::azure_monitor_logs::AzureMonitorLogsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "azure_monitor_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AzureMonitorLogs"
          }
        },
        {
          "description": "Blackhole.",
          "allOf": [
            {
              "description": "Configuration for the `blackhole` sink.",
              "default": {
                "print_interval_secs": 1,
                "rate": null
              },
              "$ref": "#/definitions/vector::sinks::blackhole::config::BlackholeConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "blackhole"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Blackhole"
          }
        },
        {
          "description": "Clickhouse.",
          "allOf": [
            {
              "description": "Configuration for the `clickhouse` sink.",
              "$ref": "#/definitions/vector::sinks::clickhouse::config::ClickhouseConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "clickhouse"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Clickhouse"
          }
        },
        {
          "description": "Console.",
          "allOf": [
            {
              "description": "Configuration for the `console` sink.",
              "$ref": "#/definitions/vector::sinks::console::config::ConsoleSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "console"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Console"
          }
        },
        {
          "description": "Datadog Events.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_events` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::events::config::DatadogEventsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "datadog_events"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DatadogEvents"
          }
        },
        {
          "description": "Datadog Logs.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_logs` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::logs::config::DatadogLogsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "datadog_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DatadogLogs"
          }
        },
        {
          "description": "Datadog Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::metrics::config::DatadogMetricsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "datadog_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DatadogMetrics"
          }
        },
        {
          "description": "Datadog Traces.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_traces` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::traces::config::DatadogTracesConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "datadog_traces"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DatadogTraces"
          }
        },
        {
          "description": "Elasticsearch.",
          "allOf": [
            {
              "description": "Configuration for the `elasticsearch` sink.",
              "$ref": "#/definitions/vector::sinks::elasticsearch::config::ElasticsearchConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "elasticsearch"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Elasticsearch"
          }
        },
        {
          "description": "File.",
          "allOf": [
            {
              "description": "Configuration for the `file` sink.",
              "$ref": "#/definitions/vector::sinks::file::FileSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "file"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "File"
          }
        },
        {
          "description": "Google Chronicle (unstructured).",
          "allOf": [
            {
              "description": "Configuration for the `gcp_chronicle_unstructured` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gcp_chronicle_unstructured"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "GcpChronicleUnstructured"
          }
        },
        {
          "description": "GCP Stackdriver Logs.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_stackdriver_logs` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver_logs::StackdriverConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gcp_stackdriver_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "GcpStackdriverLogs"
          }
        },
        {
          "description": "GCP Stackdriver Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_stackdriver_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver_metrics::StackdriverConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gcp_stackdriver_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "GcpStackdriverMetrics"
          }
        },
        {
          "description": "GCP Cloud Storage.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_cloud_storage` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::cloud_storage::GcsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gcp_cloud_storage"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "GcpCloudStorage"
          }
        },
        {
          "description": "GCP Pub/Sub.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_pubsub` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::pubsub::PubsubConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gcp_pubsub"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "GcpPubsub"
          }
        },
        {
          "description": "Honeycomb.",
          "allOf": [
            {
              "description": "Configuration for the `honeycomb` sink.",
              "$ref": "#/definitions/vector::sinks::honeycomb::HoneycombConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "honeycomb"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Honeycomb"
          }
        },
        {
          "description": "HTTP.",
          "allOf": [
            {
              "description": "Configuration for the `http` sink.",
              "$ref": "#/definitions/vector::sinks::http::HttpSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "http"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Http"
          }
        },
        {
          "description": "Humio Logs.",
          "allOf": [
            {
              "description": "Configuration for the `humio_logs` sink.",
              "$ref": "#/definitions/vector::sinks::humio::logs::HumioLogsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "humio_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "HumioLogs"
          }
        },
        {
          "description": "Humio Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `humio_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::humio::metrics::HumioMetricsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "humio_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "HumioMetrics"
          }
        },
        {
          "description": "InfluxDB Logs.",
          "allOf": [
            {
              "description": "Configuration for the `influxdb_logs` sink.",
              "$ref": "#/definitions/vector::sinks::influxdb::logs::InfluxDbLogsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "influxdb_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "InfluxdbLogs"
          }
        },
        {
          "description": "InfluxDB Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `influxdb_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::influxdb::metrics::InfluxDbConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "influxdb_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "InfluxdbMetrics"
          }
        },
        {
          "description": "Kafka.",
          "allOf": [
            {
              "description": "Configuration for the `kafka` sink.",
              "$ref": "#/definitions/vector::sinks::kafka::config::KafkaSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "kafka"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Kafka"
          }
        },
        {
          "description": "LogDNA.",
          "allOf": [
            {
              "description": "Configuration for the `logdna` sink.",
              "$ref": "#/definitions/vector::sinks::logdna::LogdnaConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "logdna"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Logdna"
          }
        },
        {
          "description": "Loki.",
          "allOf": [
            {
              "description": "Configuration for the `loki` sink.",
              "$ref": "#/definitions/vector::sinks::loki::config::LokiConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "loki"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Loki"
          }
        },
        {
          "description": "NATS.",
          "allOf": [
            {
              "description": "* Code dealing with the SinkConfig struct.\n \n Configuration for the `nats` sink.",
              "$ref": "#/definitions/vector::sinks::nats::NatsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "nats"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Nats"
          }
        },
        {
          "description": "New Relic.",
          "allOf": [
            {
              "description": "Configuration for the `new_relic` sink.",
              "$ref": "#/definitions/vector::sinks::new_relic::config::NewRelicConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "new_relic"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "NewRelic"
          }
        },
        {
          "description": "Papertrail.",
          "allOf": [
            {
              "description": "Configuration for the `papertrail` sink.",
              "$ref": "#/definitions/vector::sinks::papertrail::PapertrailConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "papertrail"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Papertrail"
          }
        },
        {
          "description": "Prometheus Exporter.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_exporter` sink.",
              "$ref": "#/definitions/vector::sinks::prometheus::exporter::PrometheusExporterConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "prometheus_exporter"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "PrometheusExporter"
          }
        },
        {
          "description": "Prometheus Remote Write.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_remote_write` sink.",
              "$ref": "#/definitions/vector::sinks::prometheus::remote_write::RemoteWriteConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "prometheus_remote_write"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "PrometheusRemoteWrite"
          }
        },
        {
          "description": "Apache Pulsar.",
          "allOf": [
            {
              "description": "Configuration for the `pulsar` sink.",
              "$ref": "#/definitions/vector::sinks::pulsar::PulsarSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "pulsar"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Pulsar"
          }
        },
        {
          "description": "Redis.",
          "allOf": [
            {
              "description": "Configuration for the `redis` sink.",
              "$ref": "#/definitions/vector::sinks::redis::RedisSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "redis"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Redis"
          }
        },
        {
          "description": "Sematext Logs.",
          "allOf": [
            {
              "description": "Configuration for the `sematext_logs` sink.",
              "$ref": "#/definitions/vector::sinks::sematext::logs::SematextLogsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "sematext_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "SematextLogs"
          }
        },
        {
          "description": "Sematext Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `sematext_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::sematext::metrics::SematextMetricsConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "sematext_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "SematextMetrics"
          }
        },
        {
          "description": "Socket.",
          "allOf": [
            {
              "description": "Configuration for the `socket` sink.",
              "$ref": "#/definitions/vector::sinks::socket::SocketSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "socket"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Socket"
          }
        },
        {
          "description": "Splunk HEC Logs.",
          "allOf": [
            {
              "description": "Configuration for the `splunk_hec_logs` sink.",
              "$ref": "#/definitions/vector::sinks::splunk_hec::logs::config::HecLogsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "splunk_hec_logs"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "SplunkHecLogs"
          }
        },
        {
          "description": "Splunk HEC Metrics.",
          "allOf": [
            {
              "description": "Configuration of the `splunk_hec_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::splunk_hec::metrics::config::HecMetricsSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "splunk_hec_metrics"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "SplunkHecMetrics"
          }
        },
        {
          "description": "StatsD.",
          "allOf": [
            {
              "description": "Configuration for the `statsd` sink.",
              "$ref": "#/definitions/vector::sinks::statsd::StatsdSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "statsd"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Statsd"
          }
        },
        {
          "description": "Unit test.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test` sink.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "unit_test"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "UnitTest"
          }
        },
        {
          "description": "Unit test stream.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test_stream` sink.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestStreamSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "unit_test_stream"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "UnitTestStream"
          }
        },
        {
          "description": "Vector.",
          "allOf": [
            {
              "description": "Configuration for the `vector` sink.",
              "$ref": "#/definitions/vector::sinks::vector::config::VectorConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "vector"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Vector"
          }
        },
        {
          "description": "Websocket.",
          "allOf": [
            {
              "description": "Configuration for the `websocket` sink.",
              "$ref": "#/definitions/vector::sinks::websocket::config::WebSocketSinkConfig",
              "_metadata": {
                "component_type": "sink"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "websocket"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Websocket"
          }
        }
      ]
    },
    "vector::sinks::amqp::config::AmqpSinkConfig": {
      "title": "Configuration for the `amqp` sink.",
      "description": "Supports AMQP version 0.9.1",
      "type": "object",
      "required": [
        "connection",
        "encoding",
        "exchange"
      ],
      "properties": {
        "exchange": {
          "title": "A templated field.",
          "description": "The exchange to publish messages to.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "templateable": true
          }
        },
        "routing_key": {
          "title": "A templated field.",
          "description": "Template used to generate a routing key which corresponds to a queue binding.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "connection": {
          "description": "Connection options for the `amqp` sink.",
          "$ref": "#/definitions/vector::amqp::AmqpConfig"
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::template::Template": {
      "title": "A templated field.",
      "description": "In many cases, components can be configured in such a way where some portion of the component's functionality can be\n customized on a per-event basis. An example of this might be a sink that writes events to a file, where we want to\n provide the flexibility to specify which file an event should go to by using an event field itself as part of the\n input to the filename we use.\n\nBy using `Template`, users can specify either fixed strings or \"templated\" strings, which use a common syntax to\n refer to fields in an event that will serve as the input data when rendering the template.  While a fixed string may\n look something like `my-file.log`, a template string could look something like `my-file-{{key}}.log`, and the `key`\n field of the event being processed would serve as the value when rendering the template into a string.",
      "type": "string"
    },
    "vector::codecs::encoding::config::EncodingConfig": {
      "description": "Encoding configuration.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "description": "Configuration for building a `Serializer`.",
          "$ref": "#/definitions/codecs::encoding::SerializerConfig"
        },
        {
          "description": "Transformations to prepare an event for serialization.",
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        }
      ]
    },
    "codecs::encoding::SerializerConfig": {
      "description": "Configuration for building a `Serializer`.",
      "oneOf": [
        {
          "description": "Apache Avro serialization.",
          "type": "object",
          "required": [
            "avro",
            "codec"
          ],
          "properties": {
            "avro": {
              "description": "Apache Avro serializer options.",
              "$ref": "#/definitions/codecs::encoding::format::avro::AvroSerializerOptions"
            },
            "codec": {
              "description": "Apache Avro serialization.",
              "const": "avro",
              "_metadata": {
                "logical_name": "Avro"
              }
            }
          },
          "_metadata": {
            "logical_name": "Avro"
          }
        },
        {
          "description": "GELF serialization.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "gelf"
            }
          },
          "_metadata": {
            "logical_name": "Gelf"
          }
        },
        {
          "description": "JSON serialization.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "json"
            }
          },
          "_metadata": {
            "logical_name": "Json"
          }
        },
        {
          "description": "Logfmt serialization.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "logfmt"
            }
          },
          "_metadata": {
            "logical_name": "Logfmt"
          }
        },
        {
          "description": "Native Vector serialization based on Protocol Buffers.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "native"
            }
          },
          "_metadata": {
            "logical_name": "Native"
          }
        },
        {
          "description": "Native Vector serialization based on JSON.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "native_json"
            }
          },
          "_metadata": {
            "logical_name": "NativeJson"
          }
        },
        {
          "title": "No serialization.",
          "description": "This encoding, specifically, will only encode the `message` field of a log event. Users should take care if\n they're modifying their log events (such as by using a `remap` transform, etc) and removing the message field\n while doing additional parsing on it, as this could lead to the encoding emitting empty strings for the given\n event.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "raw_message"
            }
          },
          "_metadata": {
            "logical_name": "RawMessage"
          }
        },
        {
          "title": "Plaintext serialization.",
          "description": "This encoding, specifically, will only encode the `message` field of a log event. Users should take care if\n they're modifying their log events (such as by using a `remap` transform, etc) and removing the message field\n while doing additional parsing on it, as this could lead to the encoding emitting empty strings for the given\n event.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "const": "text"
            }
          },
          "_metadata": {
            "logical_name": "Text"
          }
        }
      ]
    },
    "codecs::encoding::format::avro::AvroSerializerOptions": {
      "description": "Apache Avro serializer options.",
      "type": "object",
      "required": [
        "schema"
      ],
      "properties": {
        "schema": {
          "description": "The Avro schema.",
          "type": "string"
        }
      }
    },
    "vector::codecs::encoding::transformer::Transformer": {
      "description": "Transformations to prepare an event for serialization.",
      "type": "object",
      "properties": {
        "only_fields": {
          "description": "List of fields that will be included in the encoded event.",
          "default": null,
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/lookup::lookup_v2::owned::OwnedValuePath"
          }
        },
        "except_fields": {
          "description": "List of fields that will be excluded from the encoded event.",
          "default": null,
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "timestamp_format": {
          "description": "Format used for timestamp fields.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::codecs::encoding::transformer::TimestampFormat"
            }
          ]
        }
      }
    },
    "lookup::lookup_v2::owned::OwnedValuePath": {
      "description": "A lookup path.",
      "type": "string"
    },
    "vector::codecs::encoding::transformer::TimestampFormat": {
      "description": "The format in which a timestamp should be represented.",
      "oneOf": [
        {
          "description": "Represent the timestamp as a Unix timestamp.",
          "const": "unix",
          "_metadata": {
            "logical_name": "Unix"
          }
        },
        {
          "description": "Represent the timestamp as a RFC 3339 timestamp.",
          "const": "rfc3339",
          "_metadata": {
            "logical_name": "Rfc3339"
          }
        }
      ]
    },
    "vector::sinks::apex::ApexSinkConfig": {
      "description": "Configuration for the `apex` sink.",
      "type": "object",
      "required": [
        "api_token",
        "project_id",
        "uri"
      ],
      "properties": {
        "uri": {
          "title": "The base URI of the Apex instance.",
          "description": "Vector will append `/add_events` to this.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
        },
        "project_id": {
          "description": "The ID of the project to associate reported logs with.",
          "type": "string"
        },
        "api_token": {
          "description": "The API token to use to authenticate with Apex.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::util::service::TowerRequestConfig": {
      "title": "Middleware settings for outbound requests.",
      "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
      "type": "object",
      "properties": {
        "concurrency": {
          "description": "Configuration for outbound request concurrency.",
          "default": "none",
          "$ref": "#/definitions/vector::sinks::util::service::concurrency::Concurrency"
        },
        "timeout_secs": {
          "title": "The maximum time a request can take before being aborted.",
          "description": "It is highly recommended that you do not lower this value below the service’s internal timeout, as this could\n create orphaned requests, pile on retries, and result in duplicate data downstream.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "rate_limit_duration_secs": {
          "description": "The time window, in seconds, used for the `rate_limit_num` option.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "rate_limit_num": {
          "description": "The maximum number of requests allowed within the `rate_limit_duration_secs` time window.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "retry_attempts": {
          "title": "The maximum number of retries to make for failed requests.",
          "description": "The default, for all intents and purposes, represents an infinite number of retries.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "retry_max_duration_secs": {
          "description": "The maximum amount of time, in seconds, to wait between retries.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "retry_initial_backoff_secs": {
          "title": "The amount of time to wait before attempting the first retry for a failed request.",
          "description": "After the first retry has failed, the fibonacci sequence will be used to select future backoffs.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "adaptive_concurrency": {
          "title": "Configuration of adaptive concurrency parameters.",
          "description": "These parameters typically do not require changes from the default, and incorrect values can lead to meta-stable or\n unstable performance and sink behavior. Proceed with caution.",
          "default": {
            "decrease_ratio": 0.9,
            "ewma_alpha": 0.4,
            "rtt_deviation_scale": 2.5
          },
          "$ref": "#/definitions/vector::sinks::util::adaptive_concurrency::AdaptiveConcurrencySettings"
        }
      }
    },
    "vector::sinks::util::service::concurrency::Concurrency": {
      "description": "Configuration for outbound request concurrency.",
      "oneOf": [
        {
          "title": "A fixed concurrency of 1.",
          "description": "Only one request can be outstanding at any given time.",
          "const": "none",
          "_metadata": {
            "logical_name": "None"
          }
        },
        {
          "title": "Concurrency will be managed by Vector's [Adaptive Request Concurrency][arc] feature.",
          "description": "[arc]: https://vector.dev/docs/about/under-the-hood/networking/arc/",
          "const": "adaptive",
          "_metadata": {
            "logical_name": "Adaptive"
          }
        },
        {
          "description": "A fixed amount of concurrency will be allowed.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "logical_name": "Fixed"
          }
        }
      ]
    },
    "vector::sinks::util::adaptive_concurrency::AdaptiveConcurrencySettings": {
      "title": "Configuration of adaptive concurrency parameters.",
      "description": "These parameters typically do not require changes from the default, and incorrect values can lead to meta-stable or\n unstable performance and sink behavior. Proceed with caution.",
      "default": {
        "decrease_ratio": 0.9,
        "ewma_alpha": 0.4,
        "rtt_deviation_scale": 2.5
      },
      "type": "object",
      "properties": {
        "decrease_ratio": {
          "title": "The fraction of the current value to set the new concurrency limit when decreasing the limit.",
          "description": "Valid values are greater than `0` and less than `1`. Smaller values cause the algorithm to scale back rapidly\n when latency increases.\n\nNote that the new limit is rounded down after applying this ratio.",
          "type": "number",
          "maximum": 1.0,
          "minimum": 0.0
        },
        "ewma_alpha": {
          "title": "The weighting of new measurements compared to older measurements.",
          "description": "Valid values are greater than `0` and less than `1`.\n\nARC uses an exponentially weighted moving average (EWMA) of past RTT measurements as a reference to compare with\n the current RTT. Smaller values cause this reference to adjust more slowly, which may be useful if a service has\n unusually high response variability.",
          "type": "number",
          "maximum": 1.0,
          "minimum": 0.0
        },
        "rtt_deviation_scale": {
          "title": "Scale of RTT deviations which are not considered anomalous.",
          "description": "Valid values are greater than or equal to `0`, and we expect reasonable values to range from `1.0` to `3.0`.\n\nWhen calculating the past RTT average, we also compute a secondary “deviation” value that indicates how variable\n those values are. We use that deviation when comparing the past RTT average to the current measurements, so we\n can ignore increases in RTT that are within an expected range. This factor is used to scale up the deviation to\n an appropriate range.  Larger values cause the algorithm to ignore larger increases in the RTT.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsSinkConfig": {
      "description": "Configuration for the `aws_cloudwatch_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "group_name",
            "stream_name"
          ],
          "properties": {
            "group_name": {
              "title": "The [group name][group_name] of the target CloudWatch Logs stream.",
              "description": "[group_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "$ref": "#/definitions/vector::template::Template"
            },
            "stream_name": {
              "title": "The [stream name][stream_name] of the target CloudWatch Logs stream.",
              "description": "Note that there can only be one writer to a log stream at a time. If you have multiple\n instances of Vector writing to the same log group, you must include an identifier in the\n stream name that is guaranteed to be unique per Vector instance.\n\nFor example, you might choose `host`.\n\n[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "$ref": "#/definitions/vector::template::Template"
            },
            "create_missing_group": {
              "title": "Dynamically create a [log group][log_group] if it does not already exist.",
              "description": "This will ignore `create_missing_stream` directly after creating the group and will create\n the first stream.\n\n[log_group]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "type": [
                "boolean",
                "null"
              ]
            },
            "create_missing_stream": {
              "title": "Dynamically create a [log stream][log_stream] if it does not already exist.",
              "description": "[log_stream]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "type": [
                "boolean",
                "null"
              ]
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsDefaultBatchSettings>"
            },
            "request": {
              "description": "Outbound HTTP request settings.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {}
              },
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "title": "The [AWS region][aws_region] of the target service.",
          "description": "[aws_region]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::buffer::compression::Compression": {
      "description": "Compression configuration.",
      "oneOf": [
        {
          "enum": [
            "none",
            "gzip",
            "zlib"
          ]
        },
        {
          "description": "No compression.",
          "type": "object",
          "required": [
            "algorithm"
          ],
          "properties": {
            "algorithm": {
              "const": "none"
            }
          },
          "_metadata": {
            "logical_name": "None"
          }
        },
        {
          "title": "[Gzip][gzip] compression.",
          "description": "[gzip]: https://en.wikipedia.org/wiki/Gzip",
          "type": "object",
          "required": [
            "algorithm"
          ],
          "properties": {
            "algorithm": {
              "const": "gzip"
            },
            "level": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::CompressionLevel"
            }
          },
          "_metadata": {
            "logical_name": "Gzip"
          }
        },
        {
          "title": "[Zlib]][zlib] compression.",
          "description": "[zlib]: https://en.wikipedia.org/wiki/Zlib",
          "type": "object",
          "required": [
            "algorithm"
          ],
          "properties": {
            "algorithm": {
              "const": "zlib"
            },
            "level": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::CompressionLevel"
            }
          },
          "_metadata": {
            "logical_name": "Zlib"
          }
        }
      ]
    },
    "vector::sinks::util::buffer::compression::CompressionLevel": {
      "description": "Compression level.",
      "enum": [
        "none",
        "fast",
        "best",
        "default",
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::util::http::RequestConfig": {
      "description": "Outbound HTTP request settings.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "headers": {
              "description": "Additional HTTP headers to add to every HTTP request.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        }
      ]
    },
    "vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsSinkConfig": {
      "description": "Configuration for the `aws_cloudwatch_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "default_namespace"
          ],
          "properties": {
            "default_namespace": {
              "title": "The default namespace to use for metrics that do not have one.",
              "description": "Metrics with the same name can only be differentiated by their namespace, and not all\n metrics have their own namespace.",
              "type": "string"
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "title": "The [AWS region][aws_region] of the target service.",
          "description": "[aws_region]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::aws_kinesis_firehose::config::KinesisFirehoseSinkConfig": {
      "description": "Configuration for the `aws_kinesis_firehose` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "stream_name"
          ],
          "properties": {
            "stream_name": {
              "title": "The [stream name][stream_name] of the target Kinesis Firehose delivery stream.",
              "description": "[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "type": "string"
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::aws_kinesis_firehose::config::KinesisFirehoseDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::aws_kinesis_firehose::config::KinesisFirehoseDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::aws_kinesis_streams::config::KinesisSinkConfig": {
      "description": "Configuration for the `aws_kinesis_streams` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "stream_name"
          ],
          "properties": {
            "stream_name": {
              "title": "The [stream name][stream_name] of the target Kinesis Logs stream.",
              "description": "[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "type": "string"
            },
            "partition_key_field": {
              "title": "The log field used as the Kinesis record’s partition key value.",
              "description": "If not specified, a unique partition key will be generated for each Kinesis record.",
              "type": [
                "string",
                "null"
              ]
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::aws_kinesis_streams::config::KinesisDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::aws_kinesis_streams::config::KinesisDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::aws_s3::config::S3SinkConfig": {
      "description": "Configuration for the `aws_s3` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bucket"
          ],
          "properties": {
            "bucket": {
              "title": "The S3 bucket name.",
              "description": "This must not include a leading `s3://` or a trailing `/`.",
              "type": "string"
            },
            "key_prefix": {
              "title": "A prefix to apply to all object keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\n stores objects under a particular \"directory\". If using a prefix for this purpose, it must end\n in `/` in order to act as a directory path: Vector will **not** add a trailing `/` automatically.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "templateable": true
              }
            },
            "filename_time_format": {
              "title": "The timestamp format for the time component of the object key.",
              "description": "By default, object keys are appended with a timestamp that reflects when the objects are\n sent to S3, such that the resulting object key is functionally equivalent to joining the key\n prefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `key_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n 20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\n timestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\n languages.\n\nWhen set to an empty string, no timestamp will be appended to the key prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "type": [
                "string",
                "null"
              ]
            },
            "filename_append_uuid": {
              "title": "Whether or not to append a UUID v4 token to the end of the object key.",
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the object key\n being generated was `date=2022-07-18/1658176486`, setting this field to `true` would result\n in an object key that looked like `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\n object keys must be unique.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "filename_extension": {
              "description": "The filename extension to use in the object key.",
              "type": [
                "string",
                "null"
              ]
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "gzip"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Per-operation configuration when writing objects to S3.",
          "$ref": "#/definitions/vector::sinks::s3_common::config::S3Options"
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::s3_common::config::S3Options": {
      "description": "Per-operation configuration when writing objects to S3.",
      "type": "object",
      "properties": {
        "acl": {
          "title": "Canned ACL to apply to the created objects.",
          "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "S3 Canned ACLs.",
              "$ref": "#/definitions/vector::sinks::s3_common::config::S3CannedAcl"
            }
          ]
        },
        "grant_full_control": {
          "title": "Grants `READ`, `READ_ACP`, and `WRITE_ACP` permissions on the created objects to the named [grantee].",
          "description": "This allows the grantee to read the created objects and their metadata, as well as read and\n modify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
          "type": [
            "string",
            "null"
          ]
        },
        "grant_read": {
          "title": "Grants `READ` permissions on the created objects to the named [grantee].",
          "description": "This allows the grantee to read the created objects and their metadata.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
          "type": [
            "string",
            "null"
          ]
        },
        "grant_read_acp": {
          "title": "Grants `READ_ACP` permissions on the created objects to the named [grantee].",
          "description": "This allows the grantee to read the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
          "type": [
            "string",
            "null"
          ]
        },
        "grant_write_acp": {
          "title": "Grants `WRITE_ACP` permissions on the created objects to the named [grantee].",
          "description": "This allows the grantee to modify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
          "type": [
            "string",
            "null"
          ]
        },
        "server_side_encryption": {
          "title": "AWS S3 Server-Side Encryption algorithms.",
          "description": "The Server-side Encryption algorithm used when storing these objects.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "AWS S3 Server-Side Encryption algorithms.",
              "$ref": "#/definitions/vector::sinks::s3_common::config::S3ServerSideEncryption"
            }
          ]
        },
        "ssekms_key_id": {
          "title": "Specifies the ID of the AWS Key Management Service (AWS KMS) symmetrical customer managed\n customer master key (CMK) that will used for the created objects.",
          "description": "Only applies when `server_side_encryption` is configured to use KMS.\n\nIf not specified, Amazon S3 uses the AWS managed CMK in AWS to protect the data.",
          "type": [
            "string",
            "null"
          ]
        },
        "storage_class": {
          "title": "The storage class for the created objects.",
          "description": "See the [S3 Storage Classes][s3_storage_classes] for more details.\n\n[s3_storage_classes]: https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "S3 storage classes.",
              "$ref": "#/definitions/vector::sinks::s3_common::config::S3StorageClass"
            }
          ]
        },
        "tags": {
          "description": "The tag-set for the object.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        },
        "content_encoding": {
          "title": "Specifies what content encoding has been applied to the object.",
          "description": "Directly comparable to the `Content-Encoding` HTTP header.\n\nBy default, the compression scheme used dictates this value.",
          "type": [
            "string",
            "null"
          ]
        },
        "content_type": {
          "title": "Specifies the MIME type of the object.",
          "description": "Directly comparable to the `Content-Type` HTTP header.\n\nBy default, `text/x-log` is used.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::sinks::s3_common::config::S3CannedAcl": {
      "title": "S3 Canned ACLs.",
      "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
      "oneOf": [
        {
          "title": "Bucket/object are private.",
          "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and no one else has\n access.\n\nThis is the default.",
          "const": "private",
          "_metadata": {
            "logical_name": "Private"
          }
        },
        {
          "title": "Bucket/object can be read publically.",
          "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n `AllUsers` grantee group is granted the `READ` permission.",
          "const": "public-read",
          "_metadata": {
            "logical_name": "PublicRead"
          }
        },
        {
          "title": "Bucket/object can be read and written publically.",
          "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n `AllUsers` grantee group is granted the `READ` and `WRITE` permissions.\n\nThis is generally not recommended.",
          "const": "public-read-write",
          "_metadata": {
            "logical_name": "PublicReadWrite"
          }
        },
        {
          "title": "Bucket/object are private, and readable by EC2.",
          "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and the AWS EC2 service is\n granted the `READ` permission for the purpose of reading Amazon Machine Image (AMI) bundles\n from the given bucket.",
          "const": "aws-exec-read",
          "_metadata": {
            "logical_name": "AwsExecRead"
          }
        },
        {
          "title": "Bucket/object can be read by authenticated users.",
          "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n `AuthenticatedUsers` grantee group is granted the `READ` permission.",
          "const": "authenticated-read",
          "_metadata": {
            "logical_name": "AuthenticatedRead"
          }
        },
        {
          "title": "Object is private, except to the bucket owner.",
          "description": "The object owner is granted the `FULL_CONTROL` permission, and the bucket owner is granted the `READ` permission.\n\nOnly relevant when specified for an object: this canned ACL is otherwise ignored when\n specified for a bucket.",
          "const": "bucket-owner-read",
          "_metadata": {
            "logical_name": "BucketOwnerRead"
          }
        },
        {
          "title": "Object is semi-private.",
          "description": "Both the object owner and bucket owner are granted the `FULL_CONTROL` permission.\n\nOnly relevant when specified for an object: this canned ACL is otherwise ignored when\n specified for a bucket.",
          "const": "bucket-owner-full-control",
          "_metadata": {
            "logical_name": "BucketOwnerFullControl"
          }
        },
        {
          "title": "Bucket can have logs written.",
          "description": "The `LogDelivery` grantee group is granted `WRITE` and `READ_ACP` permissions.\n\nOnly relevant when specified for a bucket: this canned ACL is otherwise ignored when\n specified for an object.",
          "const": "log-delivery-write",
          "_metadata": {
            "logical_name": "LogDeliveryWrite"
          }
        }
      ]
    },
    "vector::sinks::s3_common::config::S3ServerSideEncryption": {
      "title": "AWS S3 Server-Side Encryption algorithms.",
      "description": "More information on each algorithm can be found in the [AWS documentation][aws_docs].\n\n[aws_docs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html",
      "oneOf": [
        {
          "title": "Each object is encrypted with AES-256 using a unique key.",
          "description": "This corresponds to the `SSE-S3` option.",
          "const": "AES256",
          "_metadata": {
            "logical_name": "Aes256"
          }
        },
        {
          "title": "Each object is encrypted with AES-256 using keys managed by AWS KMS.",
          "description": "Depending on whether or not a KMS key ID is specified, this will correspond either to the\n `SSE-KMS` option (keys generated/managed by KMS) or the `SSE-C` option (keys generated by\n the customer, managed by KMS).",
          "const": "aws:kms",
          "_metadata": {
            "logical_name": "AwsKms"
          }
        }
      ]
    },
    "vector::sinks::s3_common::config::S3StorageClass": {
      "title": "S3 storage classes.",
      "description": "More information on each storage class can be found in the [AWS documentation][aws_docs].\n\n[aws_docs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage-class-intro.html",
      "oneOf": [
        {
          "title": "Standard Redundancy.",
          "description": "This is the default.",
          "const": "STANDARD",
          "_metadata": {
            "logical_name": "Standard"
          }
        },
        {
          "description": "Reduced Redundancy.",
          "const": "REDUCED_REDUNDANCY",
          "_metadata": {
            "logical_name": "ReducedRedundancy"
          }
        },
        {
          "description": "Intelligent Tiering.",
          "const": "INTELLIGENT_TIERING",
          "_metadata": {
            "logical_name": "IntelligentTiering"
          }
        },
        {
          "description": "Infrequently Accessed.",
          "const": "STANDARD_IA",
          "_metadata": {
            "logical_name": "StandardIa"
          }
        },
        {
          "description": "Infrequently Accessed (single Availability zone).",
          "const": "ONEZONE_IA",
          "_metadata": {
            "logical_name": "OnezoneIa"
          }
        },
        {
          "description": "Glacier Flexible Retrieval.",
          "const": "GLACIER",
          "_metadata": {
            "logical_name": "Glacier"
          }
        },
        {
          "description": "Glacier Deep Archive.",
          "const": "DEEP_ARCHIVE",
          "_metadata": {
            "logical_name": "DeepArchive"
          }
        }
      ]
    },
    "vector::codecs::encoding::config::EncodingConfigWithFraming": {
      "description": "Encoding configuration.",
      "type": "object",
      "required": [
        "encoding"
      ],
      "properties": {
        "framing": {
          "description": "Framing configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/codecs::encoding::FramingConfig"
            }
          ]
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        }
      }
    },
    "codecs::encoding::FramingConfig": {
      "description": "Framing configuration.",
      "oneOf": [
        {
          "description": "Event data is not delimited at all.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "const": "bytes"
            }
          },
          "_metadata": {
            "logical_name": "Bytes"
          }
        },
        {
          "description": "Event data is delimited by a single ASCII (7-bit) character.",
          "type": "object",
          "required": [
            "character_delimited",
            "method"
          ],
          "properties": {
            "character_delimited": {
              "description": "Options for the character delimited encoder.",
              "$ref": "#/definitions/codecs::encoding::framing::character_delimited::CharacterDelimitedEncoderOptions"
            },
            "method": {
              "description": "Event data is delimited by a single ASCII (7-bit) character.",
              "const": "character_delimited",
              "_metadata": {
                "logical_name": "CharacterDelimited"
              }
            }
          },
          "_metadata": {
            "logical_name": "CharacterDelimited"
          }
        },
        {
          "title": "Event data is prefixed with its length in bytes.",
          "description": "The prefix is a 32-bit unsigned integer, little endian.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "const": "length_delimited"
            }
          },
          "_metadata": {
            "logical_name": "LengthDelimited"
          }
        },
        {
          "description": "Event data is delimited by a newline (LF) character.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "const": "newline_delimited"
            }
          },
          "_metadata": {
            "logical_name": "NewlineDelimited"
          }
        }
      ]
    },
    "codecs::encoding::framing::character_delimited::CharacterDelimitedEncoderOptions": {
      "description": "Configuration for character-delimited framing.",
      "type": "object",
      "required": [
        "delimiter"
      ],
      "properties": {
        "delimiter": {
          "description": "The ASCII (7-bit) character that delimits byte sequences.",
          "type": "number",
          "maximum": 255.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::aws_sqs::config::SqsSinkConfig": {
      "description": "Configuration for the `aws_sqs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "queue_url"
          ],
          "properties": {
            "queue_url": {
              "description": "The URL of the Amazon SQS queue to which messages are sent.",
              "type": "string",
              "format": "uri"
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "message_group_id": {
              "title": "The tag that specifies that a message belongs to a specific message group.",
              "description": "Can be applied only to FIFO queues.",
              "type": [
                "string",
                "null"
              ]
            },
            "message_deduplication_id": {
              "title": "The message deduplication ID value to allow AWS to identify duplicate messages.",
              "description": "This value is a template which should result in a unique string for each event. See the [AWS\n documentation][deduplication_id_docs] for more about how AWS does message deduplication.\n\n[deduplication_id_docs]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html",
              "type": [
                "string",
                "null"
              ]
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "default": {
            "region": null,
            "endpoint": null
          },
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::axiom::AxiomConfig": {
      "description": "Configuration for the `axiom` sink.",
      "type": "object",
      "required": [
        "dataset",
        "token"
      ],
      "properties": {
        "url": {
          "title": "URI of the Axiom endpoint to send data to.",
          "description": "Only required if not using Axiom Cloud.",
          "type": [
            "string",
            "null"
          ],
          "format": "uri"
        },
        "org_id": {
          "title": "The Axiom organization ID.",
          "description": "Only required when using personal tokens.",
          "type": [
            "string",
            "null"
          ]
        },
        "token": {
          "description": "The Axiom API token.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "dataset": {
          "description": "The Axiom dataset to write to.",
          "type": "string"
        },
        "request": {
          "description": "Outbound HTTP request settings.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            },
            "headers": {}
          },
          "$ref": "#/definitions/vector::sinks::util::http::RequestConfig"
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "none"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::azure_blob::config::AzureBlobSinkConfig": {
      "description": "Configuration for the `azure_blob` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "container_name"
          ],
          "properties": {
            "connection_string": {
              "title": "The Azure Blob Storage Account connection string.",
              "description": "Authentication with access key is the only supported authentication method.\n\nEither `storage_account`, or this field, must be specified.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                  "_metadata": {
                    "sensitive": true
                  }
                }
              ],
              "_metadata": {
                "sensitive": true
              }
            },
            "storage_account": {
              "title": "The Azure Blob Storage Account name.",
              "description": "Attempts to load credentials for the account in the following ways, in order:\n\n- read from environment variables ([more information][env_cred_docs])\n - looks for a [Managed Identity][managed_ident_docs]\n - uses the `az` CLI tool to get an access token ([more information][az_cli_docs])\n\nEither `connection_string`, or this field, must be specified.\n\n[env_cred_docs]: https://docs.rs/azure_identity/latest/azure_identity/struct.EnvironmentCredential.html\n [managed_ident_docs]: https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview\n [az_cli_docs]: https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-get-access-token",
              "type": [
                "string",
                "null"
              ]
            },
            "container_name": {
              "description": "The Azure Blob Storage Account container name.",
              "type": "string"
            },
            "blob_prefix": {
              "title": "A prefix to apply to all blob keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating an blob key that\n stores blobs under a particular \"directory\". If using a prefix for this purpose, it must end\n in `/` in order to act as a directory path: Vector will **not** add a trailing `/` automatically.",
              "type": [
                "string",
                "null"
              ]
            },
            "blob_time_format": {
              "title": "The timestamp format for the time component of the blob key.",
              "description": "By default, blob keys are appended with a timestamp that reflects when the blob are sent to\n Azure Blob Storage, such that the resulting blob key is functionally equivalent to joining\n the blob prefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `blob_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n 20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\n timestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\n languages.\n\nWhen set to an empty string, no timestamp will be appended to the blob prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "type": [
                "string",
                "null"
              ]
            },
            "blob_append_uuid": {
              "title": "Whether or not to append a UUID v4 token to the end of the blob key.",
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the blob key\n being generated was `date=2022-07-18/1658176486`, setting this field to `true` would result\n in an blob key that looked like\n `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\n blob keys must be unique.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "gzip"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::azure_monitor_logs::AzureMonitorLogsConfig": {
      "description": "Configuration for the `azure_monitor_logs` sink.",
      "type": "object",
      "required": [
        "customer_id",
        "log_type",
        "shared_key"
      ],
      "properties": {
        "customer_id": {
          "title": "The [unique identifier][uniq_id] for the Log Analytics workspace.",
          "description": "[uniq_id]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-uri-parameters",
          "type": "string"
        },
        "shared_key": {
          "title": "The [primary or the secondary key][shared_key] for the Log Analytics workspace.",
          "description": "[shared_key]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#authorization",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "log_type": {
          "title": "The [record type][record_type] of the data that is being submitted.",
          "description": "Can only contain letters, numbers, and underscores (_), and may not exceed 100 characters.\n\n[record_type]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-headers",
          "type": "string",
          "pattern": "[a-zA-Z0-9_]{1,100}"
        },
        "azure_resource_id": {
          "title": "The [Resource ID][resource_id] of the Azure resource the data should be associated with.",
          "description": "[resource_id]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-headers",
          "type": [
            "string",
            "null"
          ]
        },
        "host": {
          "title": "[Alternative host][alt_host] for dedicated Azure regions.",
          "description": "[alt_host]: https://docs.azure.cn/en-us/articles/guidance/developerdifferences#check-endpoints-in-azure",
          "default": "ods.opinsights.azure.com",
          "type": "string"
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::blackhole::config::BlackholeConfig": {
      "description": "Configuration for the `blackhole` sink.",
      "default": {
        "print_interval_secs": 1,
        "rate": null
      },
      "type": "object",
      "properties": {
        "print_interval_secs": {
          "title": "The number of seconds between reporting a summary of activity.",
          "description": "Set to `0` to disable reporting.",
          "default": 1,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "rate": {
          "title": "The number of events, per second, that the sink is allowed to consume.",
          "description": "By default, there is no limit.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::clickhouse::config::ClickhouseConfig": {
      "description": "Configuration for the `clickhouse` sink.",
      "type": "object",
      "required": [
        "endpoint",
        "table"
      ],
      "properties": {
        "endpoint": {
          "title": "The URI component of a request.",
          "description": "The endpoint of the Clickhouse server.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
        },
        "table": {
          "description": "The table that data will be inserted into.",
          "type": "string"
        },
        "database": {
          "description": "The database that contains the table that data will be inserted into.",
          "type": [
            "string",
            "null"
          ]
        },
        "skip_unknown_fields": {
          "description": "Sets `input_format_skip_unknown_fields`, allowing Clickhouse to discard fields not present in the table schema.",
          "default": false,
          "type": "boolean"
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "gzip"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::console::config::ConsoleSinkConfig": {
      "description": "Configuration for the `console` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "target": {
              "description": "Output target.",
              "default": "stdout",
              "$ref": "#/definitions/vector::sinks::console::config::Target"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::console::config::Target": {
      "description": "Output target.",
      "oneOf": [
        {
          "description": "Standard output.",
          "const": "stdout",
          "_metadata": {
            "logical_name": "Stdout"
          }
        },
        {
          "description": "Standard error.",
          "const": "stderr",
          "_metadata": {
            "logical_name": "Stderr"
          }
        }
      ]
    },
    "vector::sinks::datadog::events::config::DatadogEventsConfig": {
      "description": "Configuration for the `datadog_events` sink.",
      "type": "object",
      "required": [
        "default_api_key"
      ],
      "properties": {
        "endpoint": {
          "description": "The endpoint to send events to.",
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "title": "The Datadog region to send events to.",
          "description": "This option is deprecated, and the `site` field should be used instead.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::common::datadog::Region"
            }
          ]
        },
        "site": {
          "title": "The Datadog [site][dd_site] to send events to.",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "type": [
            "string",
            "null"
          ]
        },
        "default_api_key": {
          "title": "The default Datadog [API key][api_key] to send events with.",
          "description": "If an event has a Datadog [API key][api_key] set explicitly in its metadata, it will take\n precedence over the default.\n\n[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::datadog::logs::config::DatadogLogsConfig": {
      "description": "Configuration for the `datadog_logs` sink.",
      "type": "object",
      "required": [
        "default_api_key"
      ],
      "properties": {
        "endpoint": {
          "description": "The endpoint to send logs to.",
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "title": "The Datadog region to send logs to.",
          "description": "This option is deprecated, and the `site` field should be used instead.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::common::datadog::Region"
            }
          ]
        },
        "site": {
          "title": "The Datadog [site][dd_site] to send logs to.",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "type": [
            "string",
            "null"
          ]
        },
        "default_api_key": {
          "title": "The default Datadog [API key][api_key] to send logs with.",
          "description": "If a log has a Datadog [API key][api_key] set explicitly in its metadata, it will take\n precedence over the default.\n\n[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "compression": {
          "description": "Compression configuration.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            }
          ]
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::datadog::logs::config::DatadogLogsDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::datadog::logs::config::DatadogLogsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::datadog::metrics::config::DatadogMetricsConfig": {
      "description": "Configuration for the `datadog_metrics` sink.",
      "type": "object",
      "required": [
        "default_api_key"
      ],
      "properties": {
        "default_namespace": {
          "title": "Sets the default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "type": [
            "string",
            "null"
          ]
        },
        "endpoint": {
          "description": "The endpoint to send metrics to.",
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "title": "The Datadog region to send metrics to.",
          "description": "This option is deprecated, and the `site` field should be used instead.",
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::common::datadog::Region"
            }
          ]
        },
        "site": {
          "title": "The Datadog [site][dd_site] to send metrics to.",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "type": [
            "string",
            "null"
          ]
        },
        "default_api_key": {
          "title": "The default Datadog [API key][api_key] to send metrics with.",
          "description": "If a metric has a Datadog [API key][api_key] set explicitly in its metadata, it will take\n precedence over the default.\n\n[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::datadog::metrics::config::DatadogMetricsDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::datadog::metrics::config::DatadogMetricsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::datadog::traces::config::DatadogTracesConfig": {
      "description": "Configuration for the `datadog_traces` sink.",
      "type": "object",
      "required": [
        "default_api_key"
      ],
      "properties": {
        "endpoint": {
          "description": "The endpoint to send traces to.",
          "type": [
            "string",
            "null"
          ]
        },
        "site": {
          "title": "The Datadog [site][dd_site] to send traces to.",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "type": [
            "string",
            "null"
          ]
        },
        "default_api_key": {
          "title": "The default Datadog [API key][api_key] to send traces with.",
          "description": "If a trace has a Datadog [API key][api_key] set explicitly in its metadata, it will take\n precedence over the default.\n\n[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "compression": {
          "description": "Compression configuration.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            }
          ]
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::datadog::traces::config::DatadogTracesDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::datadog::traces::config::DatadogTracesDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::elasticsearch::config::ElasticsearchConfig": {
      "description": "Configuration for the `elasticsearch` sink.",
      "type": "object",
      "properties": {
        "endpoint": {
          "title": "The Elasticsearch endpoint to send logs to.",
          "description": "This should be the full URL as shown in the example.",
          "deprecated": true,
          "type": [
            "string",
            "null"
          ]
        },
        "endpoints": {
          "title": "The Elasticsearch endpoints to send logs to.",
          "description": "Each endpoint should be the full URL as shown in the example.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "doc_type": {
          "title": "The `doc_type` for your index data.",
          "description": "This is only relevant for Elasticsearch <= 6.X. If you are using >= 7.0 you do not need to\n set this option since Elasticsearch has removed it.",
          "type": [
            "string",
            "null"
          ]
        },
        "suppress_type_name": {
          "title": "Whether or not to send the `type` field to Elasticsearch.",
          "description": "`type` field was deprecated in Elasticsearch 7.x and removed in Elasticsearch 8.x.\n\nIf enabled, the `doc_type` option will be ignored.",
          "default": false,
          "type": "boolean"
        },
        "id_key": {
          "title": "The name of the event key that should map to Elasticsearch’s [`_id` field][es_id].",
          "description": "By default, Vector does not set the `_id` field, which allows Elasticsearch to set this\n automatically. You should think carefully about setting your own Elasticsearch IDs, since\n this can [hinder performance][perf_doc].\n\n[es_id]: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html\n [perf_doc]: https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_use_auto_generated_ids",
          "type": [
            "string",
            "null"
          ]
        },
        "pipeline": {
          "description": "The name of the pipeline to apply.",
          "type": [
            "string",
            "null"
          ]
        },
        "mode": {
          "description": "Indexing mode.",
          "default": "bulk",
          "$ref": "#/definitions/vector::sinks::elasticsearch::ElasticsearchMode"
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "none"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
        },
        "request": {
          "description": "Outbound HTTP request settings.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            },
            "headers": {}
          },
          "$ref": "#/definitions/vector::sinks::util::http::RequestConfig"
        },
        "auth": {
          "description": "Authentication strategies.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::elasticsearch::ElasticsearchAuth"
            }
          ]
        },
        "query": {
          "description": "Custom parameters to add to the query string of each request sent to Elasticsearch.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        },
        "aws": {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "default": {
                "region": null,
                "endpoint": null
              },
              "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
            }
          ]
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "distribution": {
          "description": "Options for determining health of an endpoint.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::util::service::health::HealthConfig"
            }
          ]
        },
        "bulk": {
          "description": "Bulk mode configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::elasticsearch::config::BulkConfig"
            }
          ]
        },
        "data_stream": {
          "description": "Data stream mode configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::elasticsearch::config::DataStreamConfig"
            }
          ]
        },
        "metrics": {
          "description": "Configuration for the `metric_to_log` transform.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "default": {
                "host_tag": null,
                "timezone": null
              },
              "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig",
              "_metadata": {
                "component_type": "transform"
              }
            }
          ],
          "_metadata": {
            "component_type": "transform"
          }
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::elasticsearch::ElasticsearchMode": {
      "description": "Indexing mode.",
      "oneOf": [
        {
          "description": "Ingests documents in bulk, via the bulk API `index` action.",
          "const": "bulk",
          "_metadata": {
            "logical_name": "Bulk"
          }
        },
        {
          "title": "Ingests documents in bulk, via the bulk API `create` action.",
          "description": "Elasticsearch Data Streams only support the `create` action.",
          "const": "data_stream",
          "_metadata": {
            "logical_name": "DataStream"
          }
        }
      ]
    },
    "vector::sinks::elasticsearch::ElasticsearchAuth": {
      "description": "Authentication strategies.",
      "oneOf": [
        {
          "description": "HTTP Basic Authentication.",
          "type": "object",
          "required": [
            "password",
            "strategy",
            "user"
          ],
          "properties": {
            "user": {
              "description": "Basic authentication username.",
              "type": "string"
            },
            "password": {
              "description": "Basic authentication password.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            },
            "strategy": {
              "description": "HTTP Basic Authentication.",
              "const": "basic",
              "_metadata": {
                "logical_name": "Basic"
              }
            }
          },
          "_metadata": {
            "logical_name": "Basic"
          }
        },
        {
          "description": "Amazon OpenSearch Service-specific authentication.",
          "allOf": [
            {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            {
              "type": "object",
              "required": [
                "strategy"
              ],
              "properties": {
                "strategy": {
                  "const": "aws"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Aws"
          }
        }
      ]
    },
    "vector::sinks::util::service::health::HealthConfig": {
      "description": "Options for determining health of an endpoint.",
      "type": "object",
      "properties": {
        "retry_initial_backoff_secs": {
          "description": "Initial timeout, in seconds, between attempts to reactivate endpoints once they become unhealthy.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "retry_max_duration_secs": {
          "description": "Maximum timeout, in seconds, between attempts to reactivate endpoints once they become unhealthy.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sinks::elasticsearch::config::BulkConfig": {
      "description": "Bulk mode configuration.",
      "type": "object",
      "properties": {
        "action": {
          "description": "The bulk action to use.",
          "type": [
            "string",
            "null"
          ]
        },
        "index": {
          "description": "The name of the index to use.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::sinks::elasticsearch::config::DataStreamConfig": {
      "description": "Data stream mode configuration.",
      "type": "object",
      "properties": {
        "type": {
          "title": "A templated field.",
          "description": "The data stream type used to construct the data stream at index time.",
          "default": "logs",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "templateable": true
          }
        },
        "dataset": {
          "title": "A templated field.",
          "description": "The data stream dataset used to construct the data stream at index time.",
          "default": "generic",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "templateable": true
          }
        },
        "namespace": {
          "title": "A templated field.",
          "description": "The data stream namespace used to construct the data stream at index time.",
          "default": "default",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "templateable": true
          }
        },
        "auto_routing": {
          "title": "Automatically routes events by deriving the data stream name using specific event fields.",
          "description": "The format of the data stream name is `<type>-<dataset>-<namespace>`, where each value comes\n from the `data_stream` configuration field of the same name.\n\nIf enabled, the value of the `data_stream.type`, `data_stream.dataset`, and\n `data_stream.namespace` event fields will be used if they are present. Otherwise, the values\n set here in the configuration will be used.",
          "default": true,
          "type": "boolean"
        },
        "sync_fields": {
          "title": "Automatically adds and syncs the `data_stream.*` event fields if they are missing from the event.",
          "description": "This ensures that fields match the name of the data stream that is receiving events.",
          "default": true,
          "type": "boolean"
        }
      }
    },
    "vector::transforms::metric_to_log::MetricToLogConfig": {
      "description": "Configuration for the `metric_to_log` transform.",
      "default": {
        "host_tag": null,
        "timezone": null
      },
      "type": "object",
      "properties": {
        "host_tag": {
          "title": "Name of the tag in the metric to use for the source host.",
          "description": "If present, the value of the tag is set on the generated log event in the \"host\" field,\n where the field key will use the [global `host_key` option][global_log_schema_host_key].\n\n[global_log_schema_host_key]: https://vector.dev/docs/reference/configuration//global-options#log_schema.host_key",
          "type": [
            "string",
            "null"
          ]
        },
        "timezone": {
          "title": "The name of the timezone to apply to timestamp conversions that do not contain an explicit\n time zone.",
          "description": "This overrides the [global `timezone`][global_timezone] option. The time zone name may be\n any name in the [TZ database][tz_database], or `local` to indicate system local time.\n\n[global_timezone]: https://vector.dev/docs/reference/configuration//global-options#timezone\n [tz_database]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Timezone reference.",
              "$ref": "#/definitions/vector_common::datetime::TimeZone"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::sinks::file::FileSinkConfig": {
      "description": "Configuration for the `file` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "path"
          ],
          "properties": {
            "path": {
              "title": "A templated field.",
              "description": "File name to write events to.",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "templateable": true
              }
            },
            "idle_timeout_secs": {
              "title": "The amount of time, in seconds, that a file can be idle and stay open.",
              "description": "After not receiving any events in this amount of time, the file will be flushed and closed.",
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "compression": {
              "description": "Compression algorithm.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::file::Compression"
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::file::Compression": {
      "description": "Compression algorithm.",
      "oneOf": [
        {
          "description": "Gzip compression.",
          "const": "gzip",
          "_metadata": {
            "logical_name": "Gzip"
          }
        },
        {
          "description": "Zstandard compression.",
          "const": "zstd",
          "_metadata": {
            "logical_name": "Zstd"
          }
        },
        {
          "description": "No compression.",
          "const": "none",
          "_metadata": {
            "logical_name": "None"
          }
        }
      ]
    },
    "vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredConfig": {
      "description": "Configuration for the `gcp_chronicle_unstructured` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "customer_id",
            "encoding",
            "log_type"
          ],
          "properties": {
            "endpoint": {
              "description": "The endpoint to send data to.",
              "type": [
                "string",
                "null"
              ]
            },
            "region": {
              "description": "Google Chronicle regions.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector::sinks::gcp::chronicle_unstructured::Region"
                }
              ]
            },
            "customer_id": {
              "description": "The Unique identifier (UUID) corresponding to the Chronicle instance.",
              "type": "string",
              "format": "uuid"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredDefaultBatchSettings>"
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "log_type": {
              "title": "The type of log entries in a request.",
              "description": "This must be one of the [supported log types][unstructured_log_types_doc], otherwise\n Chronicle will reject the entry with an error.\n\n[unstructured_log_types_doc]: https://cloud.google.com/chronicle/docs/ingestion/parser-list/supported-default-parsers",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "templateable": true
              }
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::gcp::chronicle_unstructured::Region": {
      "description": "Google Chronicle regions.",
      "oneOf": [
        {
          "description": "EU region.",
          "const": "eu",
          "_metadata": {
            "logical_name": "Eu"
          }
        },
        {
          "description": "US region.",
          "const": "us",
          "_metadata": {
            "logical_name": "Us"
          }
        },
        {
          "description": "APAC region.",
          "const": "asia",
          "_metadata": {
            "logical_name": "Asia"
          }
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::gcp::stackdriver_logs::StackdriverConfig": {
      "description": "Configuration for the `gcp_stackdriver_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "log_id",
            "resource"
          ],
          "properties": {
            "log_id": {
              "title": "The log ID to which to publish logs.",
              "description": "This is a name you create to identify this log stream.",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "templateable": true
              }
            },
            "resource": {
              "title": "A monitored resource.",
              "description": "The monitored resource to associate the logs with.",
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver_logs::StackdriverResource"
            },
            "severity_key": {
              "title": "The field of the log event from which to take the outgoing log’s `severity` field.",
              "description": "The named field is removed from the log event if present, and must be either an integer\n between 0 and 800 or a string containing one of the [severity level names][sev_names] (case\n is ignored) or a common prefix such as `err`.\n\nIf no severity key is specified, the severity of outgoing records is set to 0 (`DEFAULT`).\n\nSee the [GCP Stackdriver Logging LogSeverity description][logsev_docs] for more details on\n the value of the `severity` field.\n\n[sev_names]: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity\n [logsev_docs]: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity",
              "type": [
                "string",
                "null"
              ]
            },
            "encoding": {
              "description": "Transformations to prepare an event for serialization.",
              "default": {},
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Logging locations.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver_logs::StackdriverLogName"
            }
          ]
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::gcp::stackdriver_logs::StackdriverLogName": {
      "description": "Logging locations.",
      "oneOf": [
        {
          "description": "The billing account ID to which to publish logs.",
          "type": "object",
          "required": [
            "billing_account_id"
          ],
          "properties": {
            "billing_account_id": {
              "type": "string"
            }
          },
          "_metadata": {
            "logical_name": "BillingAccount"
          }
        },
        {
          "title": "The folder ID to which to publish logs.",
          "description": "See the [Google Cloud Platform folder documentation][folder_docs] for more details.\n\n[folder_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-folders",
          "type": "object",
          "required": [
            "folder_id"
          ],
          "properties": {
            "folder_id": {
              "type": "string"
            }
          },
          "_metadata": {
            "logical_name": "Folder"
          }
        },
        {
          "title": "The organization ID to which to publish logs.",
          "description": "This would be the identifier assigned to your organization on Google Cloud Platform.",
          "type": "object",
          "required": [
            "organization_id"
          ],
          "properties": {
            "organization_id": {
              "type": "string"
            }
          },
          "_metadata": {
            "logical_name": "Organization"
          }
        },
        {
          "title": "The project ID to which to publish logs.",
          "description": "See the [Google Cloud Platform project management documentation][project_docs] for more details.\n\n[project_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-projects",
          "type": "object",
          "required": [
            "project_id"
          ],
          "properties": {
            "project_id": {
              "type": "string"
            }
          },
          "_metadata": {
            "logical_name": "Project"
          }
        }
      ]
    },
    "vector::sinks::gcp::stackdriver_logs::StackdriverResource": {
      "title": "A monitored resource.",
      "description": "Monitored resources in GCP allow associating logs and metrics specifically with native resources\n within Google Cloud Platform. This takes the form of a \"type\" field which identifies the\n resource, and a set of type-specific labels to uniquely identify a resource of that type.\n\nSee [Monitored resource types][mon_docs] for more information.\n\n[mon_docs]: https://cloud.google.com/monitoring/api/resources",
      "allOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "title": "The monitored resource type.",
              "description": "For example, the type of a Compute Engine VM instance is `gce_instance`.",
              "type": "string"
            }
          }
        },
        {
          "description": "Type-specific labels.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::template::Template"
          }
        }
      ]
    },
    "vector::sinks::gcp::stackdriver_metrics::StackdriverConfig": {
      "description": "Configuration for the `gcp_stackdriver_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "project_id",
            "resource"
          ],
          "properties": {
            "project_id": {
              "title": "The project ID to which to publish metrics.",
              "description": "See the [Google Cloud Platform project management documentation][project_docs] for more details.\n\n[project_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-projects",
              "type": "string"
            },
            "resource": {
              "title": "A monitored resource.",
              "description": "The monitored resource to associate the metrics with.",
              "$ref": "#/definitions/vector::sinks::gcp::GcpTypedResource"
            },
            "default_namespace": {
              "title": "The default namespace to use for metrics that do not have one.",
              "description": "Metrics with the same name can only be differentiated by their namespace, and not all\n metrics have their own namespace.",
              "default": "namespace",
              "type": "string"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::gcp::stackdriver_metrics::StackdriverMetricsDefaultBatchSettings>"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::gcp::GcpTypedResource": {
      "title": "A monitored resource.",
      "description": "Monitored resources in GCP allow associating logs and metrics specifically with native resources\n within Google Cloud Platform. This takes the form of a \"type\" field which identifies the\n resource, and a set of type-specific labels to uniquely identify a resource of that type.\n\nSee [Monitored resource types][mon_docs] for more information.\n\n[mon_docs]: https://cloud.google.com/monitoring/api/resources",
      "allOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "title": "The monitored resource type.",
              "description": "For example, the type of a Compute Engine VM instance is `gce_instance`.",
              "type": "string"
            }
          }
        },
        {
          "description": "Type-specific labels.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::gcp::stackdriver_metrics::StackdriverMetricsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::gcp::cloud_storage::GcsSinkConfig": {
      "description": "Configuration for the `gcp_cloud_storage` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bucket"
          ],
          "properties": {
            "bucket": {
              "description": "The GCS bucket name.",
              "type": "string"
            },
            "acl": {
              "title": "The Predefined ACL to apply to created objects.",
              "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "GCS Predefined ACLs.",
                  "$ref": "#/definitions/vector::sinks::gcs_common::config::GcsPredefinedAcl"
                }
              ]
            },
            "storage_class": {
              "title": "The storage class for created objects.",
              "description": "For more information, see [Storage classes][storage_classes].\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "GCS storage classes.",
                  "$ref": "#/definitions/vector::sinks::gcs_common::config::GcsStorageClass"
                }
              ]
            },
            "metadata": {
              "title": "The set of metadata `key:value` pairs for the created objects.",
              "description": "For more information, see [Custom metadata][custom_metadata].\n\n[custom_metadata]: https://cloud.google.com/storage/docs/metadata#custom-metadata",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              }
            },
            "key_prefix": {
              "title": "A prefix to apply to all object keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\n stores objects under a particular \"directory\". If using a prefix for this purpose, it must end\n in `/` in order to act as a directory path: Vector will **not** add a trailing `/` automatically.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "templateable": true
              }
            },
            "filename_time_format": {
              "title": "The timestamp format for the time component of the object key.",
              "description": "By default, object keys are appended with a timestamp that reflects when the objects are\n sent to S3, such that the resulting object key is functionally equivalent to joining the key\n prefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `key_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n 20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\n timestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\n languages.\n\nWhen set to an empty string, no timestamp will be appended to the key prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "type": [
                "string",
                "null"
              ]
            },
            "filename_append_uuid": {
              "title": "Whether or not to append a UUID v4 token to the end of the object key.",
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the object key\n being generated was `date=2022-07-18/1658176486`, setting this field to `true` would result\n in an object key that looked like `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\n object keys must be unique.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "filename_extension": {
              "description": "The filename extension to use in the object key.",
              "type": [
                "string",
                "null"
              ]
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::gcs_common::config::GcsPredefinedAcl": {
      "title": "GCS Predefined ACLs.",
      "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
      "oneOf": [
        {
          "title": "Bucket/object can be read by authenticated users.",
          "description": "The bucket/object owner is granted the `OWNER` permission, and anyone authenticated Google\n account holder is granted the `READER` permission.",
          "const": "authenticated-read",
          "_metadata": {
            "logical_name": "AuthenticatedRead"
          }
        },
        {
          "title": "Object is semi-private.",
          "description": "Both the object owner and bucket owner are granted the `OWNER` permission.\n\nOnly relevant when specified for an object: this predefined ACL is otherwise ignored when\n specified for a bucket.",
          "const": "bucket-owner-full-control",
          "_metadata": {
            "logical_name": "BucketOwnerFullControl"
          }
        },
        {
          "title": "Object is private, except to the bucket owner.",
          "description": "The object owner is granted the `OWNER` permission, and the bucket owner is granted the\n `READER` permission.\n\nOnly relevant when specified for an object: this predefined ACL is otherwise ignored when\n specified for a bucket.",
          "const": "bucket-owner-read",
          "_metadata": {
            "logical_name": "BucketOwnerRead"
          }
        },
        {
          "title": "Bucket/object are private.",
          "description": "The bucket/object owner is granted the `OWNER` permission, and no one else has\n access.",
          "const": "private",
          "_metadata": {
            "logical_name": "Private"
          }
        },
        {
          "title": "Bucket/object are private within the project.",
          "description": "Project owners and project editors are granted the `OWNER` permission, and anyone who is\n part of the project team is granted the `READER` permission.\n\nThis is the default.",
          "const": "project-private",
          "_metadata": {
            "logical_name": "ProjectPrivate"
          }
        },
        {
          "title": "Bucket/object can be read publically.",
          "description": "The bucket/object owner is granted the `OWNER` permission, and all other users, whether\n authenticated or anonymous, are granted the `READER` permission.",
          "const": "public-read",
          "_metadata": {
            "logical_name": "PublicRead"
          }
        }
      ]
    },
    "vector::sinks::gcs_common::config::GcsStorageClass": {
      "title": "GCS storage classes.",
      "description": "For more information, see [Storage classes][storage_classes].\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
      "oneOf": [
        {
          "title": "Standard storage.",
          "description": "This is the default.",
          "const": "STANDARD",
          "_metadata": {
            "logical_name": "Standard"
          }
        },
        {
          "description": "Nearline storage.",
          "const": "NEARLINE",
          "_metadata": {
            "logical_name": "Nearline"
          }
        },
        {
          "description": "Coldline storage.",
          "const": "COLDLINE",
          "_metadata": {
            "logical_name": "Coldline"
          }
        },
        {
          "description": "Archive storage.",
          "const": "ARCHIVE",
          "_metadata": {
            "logical_name": "Archive"
          }
        }
      ]
    },
    "vector::sinks::gcp::pubsub::PubsubConfig": {
      "description": "Configuration for the `gcp_pubsub` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "project",
            "topic"
          ],
          "properties": {
            "project": {
              "description": "The project name to which to publish events.",
              "type": "string"
            },
            "topic": {
              "description": "The topic within the project to which to publish events.",
              "type": "string"
            },
            "endpoint": {
              "description": "The endpoint to which to publish events.",
              "default": null,
              "type": [
                "string",
                "null"
              ]
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::gcp::pubsub::PubsubDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "default": null,
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "default": {
            "api_key": null,
            "credentials_path": null
          },
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::gcp::pubsub::PubsubDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::honeycomb::HoneycombConfig": {
      "description": "Configuration for the `honeycomb` sink.",
      "type": "object",
      "required": [
        "api_key",
        "dataset"
      ],
      "properties": {
        "api_key": {
          "description": "The team key that will be used to authenticate against Honeycomb.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "dataset": {
          "description": "The dataset that Vector will send logs to.",
          "type": "string"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::honeycomb::HoneycombDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::honeycomb::HoneycombDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::http::HttpSinkConfig": {
      "description": "Configuration for the `http` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "uri"
          ],
          "properties": {
            "uri": {
              "title": "The full URI to make HTTP requests to.",
              "description": "This should include the protocol and host, but can also include the port, path, and any other valid part of a URI.",
              "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
            },
            "method": {
              "title": "HTTP method.",
              "description": "The HTTP method to use when making the request.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "HTTP method.",
                  "$ref": "#/definitions/vector::sinks::http::HttpMethod"
                }
              ]
            },
            "auth": {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "Configuration of the authentication strategy for HTTP requests.",
                  "$ref": "#/definitions/vector::http::Auth"
                }
              ]
            },
            "headers": {
              "description": "A list of custom headers to add to each request.",
              "deprecated": true,
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              }
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
            },
            "request": {
              "description": "Outbound HTTP request settings.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {}
              },
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::http::HttpMethod": {
      "title": "HTTP method.",
      "description": "A subset of the HTTP methods described in [RFC 9110, section 9.1][rfc9110] are supported.\n\n[rfc9110]: https://datatracker.ietf.org/doc/html/rfc9110#section-9.1",
      "oneOf": [
        {
          "title": "GET.",
          "description": "This is the default.",
          "const": "get",
          "_metadata": {
            "logical_name": "Get"
          }
        },
        {
          "description": "HEAD.",
          "const": "head",
          "_metadata": {
            "logical_name": "Head"
          }
        },
        {
          "description": "POST.",
          "const": "post",
          "_metadata": {
            "logical_name": "Post"
          }
        },
        {
          "description": "PUT.",
          "const": "put",
          "_metadata": {
            "logical_name": "Put"
          }
        },
        {
          "description": "DELETE.",
          "const": "delete",
          "_metadata": {
            "logical_name": "Delete"
          }
        },
        {
          "description": "OPTIONS.",
          "const": "options",
          "_metadata": {
            "logical_name": "Options"
          }
        },
        {
          "description": "TRACE.",
          "const": "trace",
          "_metadata": {
            "logical_name": "Trace"
          }
        },
        {
          "description": "PATCH.",
          "const": "patch",
          "_metadata": {
            "logical_name": "Patch"
          }
        }
      ]
    },
    "vector::sinks::humio::logs::HumioLogsConfig": {
      "description": "Configuration for the `humio_logs` sink.",
      "type": "object",
      "required": [
        "encoding",
        "token"
      ],
      "properties": {
        "token": {
          "description": "The Humio ingestion token.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "endpoint": {
          "description": "The base URL of the Humio instance.",
          "type": [
            "string",
            "null"
          ]
        },
        "source": {
          "title": "The source of events sent to this sink.",
          "description": "Typically the filename the logs originated from. Maps to `@source` in Humio.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "event_type": {
          "title": "The type of events sent to this sink. Humio uses this as the name of the parser to use to ingest the data.",
          "description": "If unset, Humio will default it to none.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to grab the hostname to send to Humio.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "type": "string"
        },
        "indexed_fields": {
          "title": "Event fields to be added to Humio’s extra fields.",
          "description": "Can be used to tag events by specifying fields starting with `#`.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "index": {
          "title": "Optional name of the repository to ingest into.",
          "description": "In public-facing APIs, this must (if present) be equal to the repository used to create the ingest token used for authentication.\n\nIn private cluster setups, Humio can be configured to allow these to be different.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "none"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "timestamp_nanos_key": {
          "title": "Overrides the name of the log field used to grab the nanosecond-enabled timestamp to send to Humio.",
          "description": "By default, `@timestamp.nanos` is used.",
          "default": "@timestamp.nanos",
          "type": [
            "string",
            "null"
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "timestamp_key": {
          "title": "Overrides the name of the log field used to grab the timestamp to send to Humio.",
          "description": "By default, the [global `log_schema.timestamp_key` option][global_timestamp_key] is used.\n\n[global_timestamp_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.timestamp_key",
          "default": "timestamp",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::humio::metrics::HumioMetricsConfig": {
      "description": "Configuration for the `humio_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "token"
          ],
          "properties": {
            "token": {
              "description": "The Humio ingestion token.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            },
            "endpoint": {
              "description": "The base URL of the Humio instance.",
              "type": [
                "string",
                "null"
              ]
            },
            "source": {
              "title": "The source of events sent to this sink.",
              "description": "Typically the filename the metrics originated from. Maps to `@source` in Humio.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "A templated field.",
                  "$ref": "#/definitions/vector::template::Template"
                }
              ],
              "_metadata": {
                "templateable": true
              }
            },
            "event_type": {
              "title": "The type of events sent to this sink. Humio uses this as the name of the parser to use to ingest the data.",
              "description": "If unset, Humio will default it to none.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "A templated field.",
                  "$ref": "#/definitions/vector::template::Template"
                }
              ],
              "_metadata": {
                "templateable": true
              }
            },
            "host_key": {
              "title": "Overrides the name of the log field used to grab the hostname to send to Humio.",
              "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "default": "host",
              "type": "string"
            },
            "indexed_fields": {
              "title": "Event fields to be added to Humio’s extra fields.",
              "description": "Can be used to tag events by specifying fields starting with `#`.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
              "default": [],
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "index": {
              "title": "Optional name of the repository to ingest into.",
              "description": "In public-facing APIs, this must (if present) be equal to the repository used to create the ingest token used for authentication.\n\nIn private cluster setups, Humio can be configured to allow these to be different.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
              "default": null,
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "A templated field.",
                  "$ref": "#/definitions/vector::template::Template"
                }
              ],
              "_metadata": {
                "templateable": true
              }
            },
            "compression": {
              "description": "Compression configuration.",
              "default": {
                "algorithm": "none"
              },
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration for the `metric_to_log` transform.",
          "default": {
            "host_tag": null,
            "timezone": null
          },
          "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig",
          "_metadata": {
            "component_type": "transform"
          }
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::influxdb::logs::InfluxDbLogsConfig": {
      "description": "Configuration for the `influxdb_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "endpoint"
          ],
          "properties": {
            "namespace": {
              "title": "The namespace of the measurement name to use.",
              "description": "When specified, the measurement name will be `<namespace>.vector`.\n\nThis field is deprecated, and `measurement` should be used instead.",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ]
            },
            "measurement": {
              "description": "The name of the InfluxDB measurement that will be written to.",
              "type": [
                "string",
                "null"
              ]
            },
            "endpoint": {
              "description": "The endpoint to send data to.",
              "type": "string"
            },
            "tags": {
              "description": "The list of names of log fields that should be added as tags to each measurement.",
              "default": [],
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "encoding": {
              "description": "Transformations to prepare an event for serialization.",
              "default": {},
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::influxdb::logs::InfluxDbLogsDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration settings for InfluxDB v0.x/v1.x.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::influxdb::InfluxDb1Settings"
            }
          ]
        },
        {
          "description": "Configuration settings for InfluxDB v2.x.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::influxdb::InfluxDb2Settings"
            }
          ]
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::influxdb::InfluxDb1Settings": {
      "description": "Configuration settings for InfluxDB v0.x/v1.x.",
      "type": "object",
      "required": [
        "database"
      ],
      "properties": {
        "database": {
          "title": "The name of the database to write into.",
          "description": "Only relevant when using InfluxDB v0.x/v1.x.",
          "type": "string"
        },
        "consistency": {
          "title": "The consistency level to use for writes.",
          "description": "Only relevant when using InfluxDB v0.x/v1.x.",
          "type": [
            "string",
            "null"
          ]
        },
        "retention_policy_name": {
          "title": "The target retention policy for writes.",
          "description": "Only relevant when using InfluxDB v0.x/v1.x.",
          "type": [
            "string",
            "null"
          ]
        },
        "username": {
          "title": "The username to authenticate with.",
          "description": "Only relevant when using InfluxDB v0.x/v1.x.",
          "type": [
            "string",
            "null"
          ]
        },
        "password": {
          "title": "The password to authenticate with.",
          "description": "Only relevant when using InfluxDB v0.x/v1.x.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        }
      }
    },
    "vector::sinks::influxdb::InfluxDb2Settings": {
      "description": "Configuration settings for InfluxDB v2.x.",
      "type": "object",
      "required": [
        "bucket",
        "org",
        "token"
      ],
      "properties": {
        "org": {
          "title": "The name of the organization to write into.",
          "description": "Only relevant when using InfluxDB v2.x and above.",
          "type": "string"
        },
        "bucket": {
          "title": "The name of the bucket to write into.",
          "description": "Only relevant when using InfluxDB v2.x and above.",
          "type": "string"
        },
        "token": {
          "title": "The [token][token_docs] to authenticate with.",
          "description": "Only relevant when using InfluxDB v2.x and above.\n\n[token_docs]: https://v2.docs.influxdata.com/v2.0/security/tokens/",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        }
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::influxdb::logs::InfluxDbLogsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::influxdb::metrics::InfluxDbConfig": {
      "description": "Configuration for the `influxdb_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "endpoint"
          ],
          "properties": {
            "default_namespace": {
              "title": "Sets the default namespace for any metrics sent.",
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "type": [
                "string",
                "null"
              ]
            },
            "endpoint": {
              "description": "The endpoint to send data to.",
              "type": "string"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::influxdb::metrics::InfluxDbDefaultBatchSettings>"
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
            },
            "tags": {
              "description": "A map of additional tags, in the form of key/value pairs, to add to each measurement.",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              }
            },
            "tls": {
              "description": "Standard TLS options.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
                }
              ]
            },
            "quantiles": {
              "description": "The list of quantiles to calculate when sending distribution metrics.",
              "default": [
                0.5,
                0.75,
                0.9,
                0.95,
                0.99
              ],
              "type": "array",
              "items": {
                "type": "number",
                "maximum": 9007199254740991.0,
                "minimum": -9007199254740991.0
              }
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Configuration settings for InfluxDB v0.x/v1.x.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::influxdb::InfluxDb1Settings"
            }
          ]
        },
        {
          "description": "Configuration settings for InfluxDB v2.x.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::influxdb::InfluxDb2Settings"
            }
          ]
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::influxdb::metrics::InfluxDbDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::kafka::config::KafkaSinkConfig": {
      "description": "Configuration for the `kafka` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bootstrap_servers",
            "encoding",
            "topic"
          ],
          "properties": {
            "bootstrap_servers": {
              "title": "A comma-separated list of the initial Kafka brokers to connect to.",
              "description": "Each value must be in the form of `<host>` or `<host>:<port>`, and separated by a comma.",
              "type": "string"
            },
            "topic": {
              "description": "The Kafka topic name to write events to.",
              "type": "string",
              "_metadata": {
                "templateable": true
              }
            },
            "key_field": {
              "title": "The log field name or tags key to use for the topic key.",
              "description": "If the field does not exist in the log or in tags, a blank value will be used. If unspecified, the key is not sent.\n\nKafka uses a hash of the key to choose the partition or uses round-robin if the record has no key.",
              "type": [
                "string",
                "null"
              ]
            },
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::NoDefaultsBatchSettings>"
            },
            "compression": {
              "description": "Supported compression types for Kafka.",
              "default": "none",
              "$ref": "#/definitions/vector::kafka::KafkaCompression"
            },
            "socket_timeout_ms": {
              "description": "Default timeout, in milliseconds, for network requests.",
              "default": 60000,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "message_timeout_ms": {
              "description": "Local message timeout, in milliseconds.",
              "default": 300000,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "librdkafka_options": {
              "title": "A map of advanced options to pass directly to the underlying `librdkafka` client.",
              "description": "For more information on configuration options, see [Configuration properties][config_props_docs].\n\n[config_props_docs]: https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "headers_key": {
              "title": "The log field name to use for the Kafka headers.",
              "description": "If omitted, no headers will be written.",
              "type": [
                "string",
                "null"
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Kafka authentication configuration.",
          "$ref": "#/definitions/vector::kafka::KafkaAuthConfig"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::NoDefaultsBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::kafka::KafkaCompression": {
      "description": "Supported compression types for Kafka.",
      "oneOf": [
        {
          "description": "No compression.",
          "const": "none",
          "_metadata": {
            "logical_name": "None"
          }
        },
        {
          "description": "Gzip.",
          "const": "gzip",
          "_metadata": {
            "logical_name": "Gzip"
          }
        },
        {
          "description": "Snappy.",
          "const": "snappy",
          "_metadata": {
            "logical_name": "Snappy"
          }
        },
        {
          "description": "LZ4.",
          "const": "lz4",
          "_metadata": {
            "logical_name": "Lz4"
          }
        },
        {
          "description": "Zstandard.",
          "const": "zstd",
          "_metadata": {
            "logical_name": "Zstd"
          }
        }
      ]
    },
    "vector::sinks::logdna::LogdnaConfig": {
      "description": "Configuration for the `logdna` sink.",
      "type": "object",
      "required": [
        "api_key",
        "hostname"
      ],
      "properties": {
        "api_key": {
          "description": "The Ingestion API key.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "endpoint": {
          "title": "The URI component of a request.",
          "description": "The endpoint to send logs to.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "The URI component of a request.",
              "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
            }
          ]
        },
        "hostname": {
          "title": "A templated field.",
          "description": "The hostname that will be attached to each batch of events.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "templateable": true
          }
        },
        "mac": {
          "description": "The MAC address that will be attached to each batch of events.",
          "type": [
            "string",
            "null"
          ]
        },
        "ip": {
          "description": "The IP address that will be attached to each batch of events.",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "description": "The tags that will be attached to each batch of events.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector::template::Template"
          },
          "_metadata": {
            "templateable": true
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "default_app": {
          "description": "The default app that will be set for events that do not contain a `file` or `app` field.",
          "type": [
            "string",
            "null"
          ]
        },
        "default_env": {
          "description": "The default environment that will be set for events that do not contain an `env` field.",
          "type": [
            "string",
            "null"
          ]
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::loki::config::LokiConfig": {
      "description": "Configuration for the `loki` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "title": "The base URL of the Loki instance.",
          "description": "Vector will append `/loki/api/v1/push` to this.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "tenant_id": {
          "title": "The tenant ID to send.",
          "description": "By default, this is not required since a proxy should set this header.\n\nWhen running Loki locally, a tenant ID is not required.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ]
        },
        "labels": {
          "title": "A set of labels that are attached to each batch of events.",
          "description": "Both keys and values are templatable, which enables you to attach dynamic labels to events\n\nLabels can be suffixed with a “*” to allow the expansion of objects into multiple labels,\n see “How it works” for more information.\n\nNote: If the set of labels has high cardinality, this can cause drastic performance issues\n with Loki. To prevent this from happening, reduce the number of unique label keys and\n values.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::template::Template"
          },
          "_metadata": {
            "templateable": true
          }
        },
        "remove_label_fields": {
          "description": "Whether or not to delete fields from the event when they are used as labels.",
          "default": false,
          "type": "boolean"
        },
        "remove_timestamp": {
          "title": "Whether or not to remove the timestamp from the event payload.",
          "description": "The timestamp will still be sent as event metadata for Loki to use for indexing.",
          "default": true,
          "type": "boolean"
        },
        "compression": {
          "description": "Compose with basic compression and Loki-specific compression.",
          "default": "snappy",
          "$ref": "#/definitions/vector::sinks::loki::config::CompressionConfigAdapter"
        },
        "out_of_order_action": {
          "title": "Out-of-order event behavior.",
          "description": "Some sources may generate events with timestamps that aren’t in chronological order. While the\n sink will sort events before sending them to Loki, there is the chance another event comes in\n that is out-of-order with respective the latest events sent to Loki. Prior to Loki 2.4.0, this\n was not supported and would result in an error during the push request.\n\nIf you're using Loki 2.4.0 or newer, `Accept` is the preferred action, which lets Loki handle\n any necessary sorting/reordering. If you're using an earlier version, then you must use `Drop`\n or `RewriteTimestamp` depending on which option makes the most sense for your use case.",
          "default": "drop",
          "$ref": "#/definitions/vector::sinks::loki::config::OutOfOrderAction"
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::loki::config::LokiDefaultBatchSettings>"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::loki::config::CompressionConfigAdapter": {
      "description": "Compose with basic compression and Loki-specific compression.",
      "oneOf": [
        {
          "description": "Basic compression.",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "logical_name": "Original"
          }
        },
        {
          "description": "Loki-specific compression.",
          "$ref": "#/definitions/vector::sinks::loki::config::ExtendedCompression",
          "_metadata": {
            "logical_name": "Extended"
          }
        }
      ]
    },
    "vector::sinks::loki::config::ExtendedCompression": {
      "description": "Loki-specific compression.",
      "oneOf": [
        {
          "title": "Snappy compression.",
          "description": "This implies sending push requests as Protocol Buffers.",
          "const": "snappy",
          "_metadata": {
            "logical_name": "Snappy"
          }
        }
      ]
    },
    "vector::sinks::loki::config::OutOfOrderAction": {
      "title": "Out-of-order event behavior.",
      "description": "Some sources may generate events with timestamps that aren’t in chronological order. While the\n sink will sort events before sending them to Loki, there is the chance another event comes in\n that is out-of-order with respective the latest events sent to Loki. Prior to Loki 2.4.0, this\n was not supported and would result in an error during the push request.\n\nIf you're using Loki 2.4.0 or newer, `Accept` is the preferred action, which lets Loki handle\n any necessary sorting/reordering. If you're using an earlier version, then you must use `Drop`\n or `RewriteTimestamp` depending on which option makes the most sense for your use case.",
      "oneOf": [
        {
          "description": "Drop the event.",
          "const": "drop",
          "_metadata": {
            "logical_name": "Drop"
          }
        },
        {
          "description": "Rewrite the timestamp of the event to the timestamp of the latest event seen by the sink.",
          "const": "rewrite_timestamp",
          "_metadata": {
            "logical_name": "RewriteTimestamp"
          }
        },
        {
          "title": "Accept the event.",
          "description": "The event is not dropped and is sent without modification.\n\nRequires Loki 2.4.0 or newer.",
          "const": "accept",
          "_metadata": {
            "logical_name": "Accept"
          }
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::loki::config::LokiDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::nats::NatsSinkConfig": {
      "description": "* Code dealing with the SinkConfig struct.\n \n Configuration for the `nats` sink.",
      "type": "object",
      "required": [
        "encoding",
        "subject",
        "url"
      ],
      "properties": {
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "connection_name": {
          "description": "A name assigned to the NATS connection.",
          "default": "vector",
          "type": "string"
        },
        "subject": {
          "description": "The NATS subject to publish messages to.",
          "type": "string",
          "_metadata": {
            "templateable": true
          }
        },
        "url": {
          "title": "The NATS URL to connect to.",
          "description": "The URL must take the form of `nats://server:port`.",
          "type": "string"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "auth": {
          "description": "Configuration of the authentication strategy when interacting with NATS.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::nats::NatsAuthConfig"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::new_relic::config::NewRelicConfig": {
      "description": "Configuration for the `new_relic` sink.",
      "type": "object",
      "required": [
        "account_id",
        "api",
        "license_key"
      ],
      "properties": {
        "license_key": {
          "description": "A valid New Relic license key.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "account_id": {
          "description": "The New Relic account ID.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "region": {
          "description": "New Relic region.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::new_relic::config::NewRelicRegion"
            }
          ]
        },
        "api": {
          "description": "New Relic API endpoint.",
          "$ref": "#/definitions/vector::sinks::new_relic::config::NewRelicApi"
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "gzip"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::new_relic::config::NewRelicDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::new_relic::config::NewRelicRegion": {
      "description": "New Relic region.",
      "oneOf": [
        {
          "description": "US region.",
          "const": "us",
          "_metadata": {
            "logical_name": "Us"
          }
        },
        {
          "description": "EU region.",
          "const": "eu",
          "_metadata": {
            "logical_name": "Eu"
          }
        }
      ]
    },
    "vector::sinks::new_relic::config::NewRelicApi": {
      "description": "New Relic API endpoint.",
      "oneOf": [
        {
          "description": "Events API.",
          "const": "events",
          "_metadata": {
            "logical_name": "Events"
          }
        },
        {
          "description": "Metrics API.",
          "const": "metrics",
          "_metadata": {
            "logical_name": "Metrics"
          }
        },
        {
          "description": "Logs API.",
          "const": "logs",
          "_metadata": {
            "logical_name": "Logs"
          }
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::new_relic::config::NewRelicDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::papertrail::PapertrailConfig": {
      "description": "Configuration for the `papertrail` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "title": "The URI component of a request.",
          "description": "The endpoint to send logs to.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "keepalive": {
          "description": "TCP keepalive settings for socket-based components.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
            }
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "send_buffer_bytes": {
          "description": "Configures the send buffer size using the `SO_SNDBUF` option on the socket.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "process": {
          "title": "A templated field.",
          "description": "The value to use as the `process` in Papertrail.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::prometheus::exporter::PrometheusExporterConfig": {
      "description": "Configuration for the `prometheus_exporter` sink.",
      "type": "object",
      "properties": {
        "default_namespace": {
          "title": "The default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with an underscore (`_`).\n\nIt should follow the Prometheus [naming conventions][prom_naming_docs].\n\n[prom_naming_docs]: https://prometheus.io/docs/practices/naming/#metric-names",
          "type": [
            "string",
            "null"
          ]
        },
        "address": {
          "title": "The address to expose for scraping.",
          "description": "The metrics are exposed at the typical Prometheus exporter path, `/metrics`.",
          "default": "0.0.0.0:9598",
          "$ref": "#/definitions/stdlib::SocketAddr"
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "buckets": {
          "title": "Default buckets to use for aggregating [distribution][dist_metric_docs] metrics into histograms.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.005,
            0.01,
            0.025,
            0.05,
            0.1,
            0.25,
            0.5,
            1.0,
            2.5,
            5.0,
            10.0
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0
          }
        },
        "quantiles": {
          "title": "Quantiles to use for aggregating [distribution][dist_metric_docs] metrics into a summary.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.5,
            0.75,
            0.9,
            0.95,
            0.99
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0
          }
        },
        "distributions_as_summaries": {
          "title": "Whether or not to render [distributions][dist_metric_docs] as an [aggregated histogram][prom_agg_hist_docs] or  [aggregated summary][prom_agg_summ_docs].",
          "description": "While Vector supports distributions as a lossless way to represent a set of samples for a\n metric, Prometheus clients (the application being scraped, which is this sink) must\n aggregate locally into either an aggregated histogram or aggregated summary.\n\n[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution\n [prom_agg_hist_docs]: https://prometheus.io/docs/concepts/metric_types/#histogram\n [prom_agg_summ_docs]: https://prometheus.io/docs/concepts/metric_types/#summary",
          "default": false,
          "type": "boolean"
        },
        "flush_period_secs": {
          "title": "The interval, in seconds, on which metrics are flushed.",
          "description": "On the flush interval, if a metric has not been seen since the last flush interval, it is\n considered expired and is removed.\n\nBe sure to configure this value higher than your client’s scrape interval.",
          "default": 60,
          "$ref": "#/definitions/serde_with::DurationSeconds"
        },
        "suppress_timestamp": {
          "title": "Suppresses timestamps on the Prometheus output.",
          "description": "This can sometimes be useful when the source of metrics leads to their timestamps being too\n far in the past for Prometheus to allow them, such as when aggregating metrics over long\n time periods, or when replaying old metrics from a disk buffer.",
          "default": false,
          "type": "boolean"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "serde_with::DurationSeconds": {
      "description": "A span of time, in whole seconds.",
      "type": "number",
      "maximum": 9007199254740991.0,
      "minimum": 0.0
    },
    "vector::sinks::prometheus::remote_write::RemoteWriteConfig": {
      "description": "Configuration for the `prometheus_remote_write` sink.",
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "description": "The endpoint to send data to.",
          "type": "string"
        },
        "default_namespace": {
          "title": "The default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with an underscore (`_`).\n\nIt should follow the Prometheus [naming conventions][prom_naming_docs].\n\n[prom_naming_docs]: https://prometheus.io/docs/practices/naming/#metric-names",
          "type": [
            "string",
            "null"
          ]
        },
        "buckets": {
          "title": "Default buckets to use for aggregating [distribution][dist_metric_docs] metrics into histograms.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.005,
            0.01,
            0.025,
            0.05,
            0.1,
            0.25,
            0.5,
            1.0,
            2.5,
            5.0,
            10.0
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0
          }
        },
        "quantiles": {
          "title": "Quantiles to use for aggregating [distribution][dist_metric_docs] metrics into a summary.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.5,
            0.75,
            0.9,
            0.95,
            0.99
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::prometheus::remote_write::PrometheusRemoteWriteDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "tenant_id": {
          "title": "The tenant ID to send.",
          "description": "If set, a header named `X-Scope-OrgID` will be added to outgoing requests with the value of this setting.\n\nThis may be used by Cortex or other remote services to identify the tenant making the request.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "auth": {
          "description": "Authentication strategies.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::prometheus::PrometheusRemoteWriteAuth"
            }
          ]
        },
        "aws": {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "default": {
                "region": null,
                "endpoint": null
              },
              "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::prometheus::remote_write::PrometheusRemoteWriteDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::prometheus::PrometheusRemoteWriteAuth": {
      "description": "Authentication strategies.",
      "oneOf": [
        {
          "description": "HTTP Basic Authentication.",
          "type": "object",
          "required": [
            "password",
            "strategy",
            "user"
          ],
          "properties": {
            "user": {
              "description": "Basic authentication username.",
              "type": "string"
            },
            "password": {
              "description": "Basic authentication password.",
              "type": "string"
            },
            "strategy": {
              "description": "HTTP Basic Authentication.",
              "const": "basic",
              "_metadata": {
                "logical_name": "Basic"
              }
            }
          },
          "_metadata": {
            "logical_name": "Basic"
          }
        },
        {
          "description": "Amazon Prometheus Service-specific authentication.",
          "allOf": [
            {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication"
            },
            {
              "type": "object",
              "required": [
                "strategy"
              ],
              "properties": {
                "strategy": {
                  "const": "aws"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Aws"
          }
        }
      ]
    },
    "vector::sinks::pulsar::PulsarSinkConfig": {
      "description": "Configuration for the `pulsar` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint",
        "topic"
      ],
      "properties": {
        "endpoint": {
          "description": "The endpoint to which the Pulsar client should connect to.",
          "type": "string"
        },
        "topic": {
          "description": "The Pulsar topic name to write events to.",
          "type": "string"
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "auth": {
          "description": "Authentication configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::pulsar::AuthConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "partition_key_field": {
          "description": "Log field to use as Pulsar message key",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::pulsar::AuthConfig": {
      "description": "Authentication configuration.",
      "type": "object",
      "properties": {
        "name": {
          "title": "Basic authentication name/username.",
          "description": "This can be used either for basic authentication (username/password) or JWT authentication.\n When used for JWT, the value should be `token`.",
          "type": [
            "string",
            "null"
          ]
        },
        "token": {
          "title": "Basic authentication password/token.",
          "description": "This can be used either for basic authentication (username/password) or JWT authentication.\n When used for JWT, the value should be the signed JWT, in the compact representation.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "sensitive": true
              }
            }
          ],
          "_metadata": {
            "sensitive": true
          }
        },
        "oauth2": {
          "description": "OAuth2-specific authenticatgion configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::pulsar::OAuth2Config"
            }
          ]
        }
      }
    },
    "vector::sinks::pulsar::OAuth2Config": {
      "description": "OAuth2-specific authenticatgion configuration.",
      "type": "object",
      "required": [
        "credentials_url",
        "issuer_url"
      ],
      "properties": {
        "issuer_url": {
          "description": "The issuer URL.",
          "type": "string"
        },
        "credentials_url": {
          "title": "The credentials URL.",
          "description": "A data URL is also supported.",
          "type": "string"
        },
        "audience": {
          "description": "The OAuth2 audience.",
          "type": [
            "string",
            "null"
          ]
        },
        "scope": {
          "description": "The OAuth2 scope.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::sinks::redis::RedisSinkConfig": {
      "description": "Configuration for the `redis` sink.",
      "type": "object",
      "required": [
        "encoding",
        "key",
        "url"
      ],
      "properties": {
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "data_type": {
          "description": "Redis data type to store messages in.",
          "default": "list",
          "$ref": "#/definitions/vector::sinks::redis::DataTypeConfig"
        },
        "list_option": {
          "description": "List-specific options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::redis::ListOption"
            }
          ]
        },
        "url": {
          "title": "The Redis URL to connect to.",
          "description": "The URL _must_ take the form of `protocol://server:port/db` where the protocol can either be\n `redis` or `rediss` for connections secured via TLS.",
          "type": "string"
        },
        "key": {
          "title": "A templated field.",
          "description": "The Redis key to publish messages to.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "templateable": true
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::redis::RedisDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::redis::DataTypeConfig": {
      "description": "Redis data type to store messages in.",
      "oneOf": [
        {
          "title": "The Redis `list` type.",
          "description": "This resembles a deque, where messages can be popped and pushed from either end.\n\nThis is the default.",
          "const": "list",
          "_metadata": {
            "logical_name": "List"
          }
        },
        {
          "title": "The Redis `channel` type.",
          "description": "Redis channels function in a pub/sub fashion, allowing many-to-many broadcasting and receiving.",
          "const": "channel",
          "_metadata": {
            "logical_name": "Channel"
          }
        }
      ]
    },
    "vector::sinks::redis::ListOption": {
      "description": "List-specific options.",
      "type": "object",
      "required": [
        "method"
      ],
      "properties": {
        "method": {
          "description": "The method to use for pushing messages into a `list`.",
          "$ref": "#/definitions/vector::sinks::redis::Method"
        }
      }
    },
    "vector::sinks::redis::Method": {
      "description": "Method for pushing messages into a `list`.",
      "oneOf": [
        {
          "title": "Use the `rpush` method.",
          "description": "This pushes messages onto the tail of the list.\n\nThis is the default.",
          "const": "rpush",
          "_metadata": {
            "logical_name": "RPush"
          }
        },
        {
          "title": "Use the `lpush` method.",
          "description": "This pushes messages onto the head of the list.",
          "const": "lpush",
          "_metadata": {
            "logical_name": "LPush"
          }
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::redis::RedisDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::sematext::logs::SematextLogsConfig": {
      "description": "Configuration for the `sematext_logs` sink.",
      "type": "object",
      "required": [
        "token"
      ],
      "properties": {
        "region": {
          "description": "Sematext region.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::sematext::Region"
            }
          ]
        },
        "endpoint": {
          "description": "The endpoint to send data to.",
          "type": [
            "string",
            "null"
          ]
        },
        "token": {
          "description": "The token that will be used to write to Sematext.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::sematext::Region": {
      "description": "Sematext region.",
      "oneOf": [
        {
          "description": "US region.",
          "const": "us",
          "_metadata": {
            "logical_name": "Us"
          }
        },
        {
          "description": "EU region.",
          "const": "eu",
          "_metadata": {
            "logical_name": "Eu"
          }
        }
      ]
    },
    "vector::sinks::sematext::metrics::SematextMetricsConfig": {
      "description": "Configuration for the `sematext_metrics` sink.",
      "type": "object",
      "required": [
        "default_namespace",
        "token"
      ],
      "properties": {
        "default_namespace": {
          "title": "Sets the default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "type": "string"
        },
        "region": {
          "description": "Sematext region.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::sematext::Region"
            }
          ]
        },
        "endpoint": {
          "description": "The endpoint to send data to.",
          "type": [
            "string",
            "null"
          ]
        },
        "token": {
          "description": "The token that will be used to write to Sematext.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::sematext::metrics::SematextMetricsDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::sematext::metrics::SematextMetricsDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::socket::SocketSinkConfig": {
      "description": "Configuration for the `socket` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Socket mode.",
          "$ref": "#/definitions/vector::sinks::socket::Mode"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::socket::Mode": {
      "description": "Socket mode.",
      "oneOf": [
        {
          "description": "TCP.",
          "allOf": [
            {
              "description": "TCP configuration.",
              "$ref": "#/definitions/vector::sinks::socket::TcpMode"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "tcp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Tcp"
          }
        },
        {
          "description": "UDP.",
          "allOf": [
            {
              "description": "UDP configuration.",
              "$ref": "#/definitions/vector::sinks::socket::UdpMode"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "udp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Udp"
          }
        },
        {
          "description": "Unix Domain Socket.",
          "allOf": [
            {
              "description": "Unix Domain Socket configuration.",
              "$ref": "#/definitions/vector::sinks::socket::UnixMode"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "unix"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Unix"
          }
        }
      ]
    },
    "vector::sinks::socket::TcpMode": {
      "description": "TCP configuration.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "description": "A TCP sink.",
          "$ref": "#/definitions/vector::sinks::util::tcp::TcpSinkConfig"
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ]
    },
    "vector::sinks::util::tcp::TcpSinkConfig": {
      "description": "A TCP sink.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "title": "The address to connect to.",
          "description": "The address _must_ include a port.",
          "type": "string"
        },
        "keepalive": {
          "description": "TCP keepalive settings for socket-based components.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tcp::TcpKeepaliveConfig"
            }
          ]
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "send_buffer_bytes": {
          "title": "The size, in bytes, of the socket's send buffer.",
          "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sinks::socket::UdpMode": {
      "description": "UDP configuration.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding"
          ],
          "properties": {
            "encoding": {
              "description": "Encoding configuration.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
            }
          }
        },
        {
          "description": "A UDP sink.",
          "$ref": "#/definitions/vector::sinks::util::udp::UdpSinkConfig"
        }
      ]
    },
    "vector::sinks::util::udp::UdpSinkConfig": {
      "description": "A UDP sink.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "title": "The address to connect to.",
          "description": "The address _must_ include a port.",
          "type": "string"
        },
        "send_buffer_bytes": {
          "title": "The size, in bytes, of the socket's send buffer.",
          "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::sinks::socket::UnixMode": {
      "description": "Unix Domain Socket configuration.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "description": "A Unix Domain Socket sink.",
          "$ref": "#/definitions/vector::sinks::util::unix::UnixSinkConfig"
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ]
    },
    "vector::sinks::util::unix::UnixSinkConfig": {
      "description": "A Unix Domain Socket sink.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "title": "The Unix socket path.",
          "description": "This should be an absolute path.",
          "$ref": "#/definitions/stdlib::PathBuf"
        }
      }
    },
    "vector::sinks::splunk_hec::logs::config::HecLogsSinkConfig": {
      "description": "Configuration for the `splunk_hec_logs` sink.",
      "type": "object",
      "required": [
        "default_token",
        "encoding",
        "endpoint"
      ],
      "properties": {
        "default_token": {
          "title": "Default Splunk HEC token.",
          "description": "If an event has a token set in its metadata, it will prevail over the one set here.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "endpoint": {
          "description": "The base URL of the Splunk instance.",
          "type": "string"
        },
        "host_key": {
          "title": "Overrides the name of the log field used to grab the hostname to send to Splunk HEC.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "type": "string"
        },
        "indexed_fields": {
          "title": "Fields to be [added to Splunk index][splunk_field_index_docs].",
          "description": "[splunk_field_index_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/IFXandHEC",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "index": {
          "title": "The name of the index where to send the events to.",
          "description": "If not specified, the default index is used.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "sourcetype": {
          "title": "The sourcetype of events sent to this sink.",
          "description": "If unset, Splunk will default to `httpevent`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "source": {
          "title": "The source of events sent to this sink.",
          "description": "This is typically the filename the logs originated from.\n\nIf unset, the Splunk collector will set it.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "none"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Splunk HEC acknowledgement configuration.",
          "default": {
            "indexer_acknowledgements_enabled": true,
            "query_interval": 10,
            "retry_limit": 30,
            "max_pending_acks": 1000000
          },
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig"
        },
        "timestamp_key": {
          "title": "Overrides the name of the log field used to grab the timestamp to send to Splunk HEC.",
          "description": "By default, the [global `log_schema.timestamp_key` option][global_timestamp_key] is used.\n\n[global_timestamp_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.timestamp_key",
          "default": "timestamp",
          "type": "string"
        },
        "endpoint_target": {
          "description": "Splunk HEC endpoint configuration.",
          "default": "event",
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::EndpointTarget"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig": {
      "description": "Splunk HEC acknowledgement configuration.",
      "default": {
        "indexer_acknowledgements_enabled": true,
        "query_interval": 10,
        "retry_limit": 30,
        "max_pending_acks": 1000000
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "indexer_acknowledgements_enabled": {
              "title": "Controls if the sink will integrate with [Splunk HEC indexer acknowledgements][splunk_indexer_ack_docs] for end-to-end acknowledgements.",
              "description": "[splunk_indexer_ack_docs]: https://docs.splunk.com/Documentation/Splunk/8.2.3/Data/AboutHECIDXAck",
              "type": "boolean"
            },
            "query_interval": {
              "description": "The amount of time, in seconds, to wait in between queries to the Splunk HEC indexer acknowledgement endpoint.",
              "type": "number",
              "maximum": 255.0,
              "minimum": 1.0
            },
            "retry_limit": {
              "description": "The maximum number of times an acknowledgement ID will be queried for its status.",
              "type": "number",
              "maximum": 255.0,
              "minimum": 1.0
            },
            "max_pending_acks": {
              "title": "The maximum number of pending acknowledgements from events sent to the Splunk HEC collector.",
              "description": "Once reached, the sink will begin applying backpressure.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 1.0
            }
          }
        },
        {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      ]
    },
    "vector::sinks::splunk_hec::common::EndpointTarget": {
      "description": "Splunk HEC endpoint configuration.",
      "oneOf": [
        {
          "title": "Events are sent to the [raw endpoint][raw_endpoint_docs].",
          "description": "When the raw endpoint is used, configured [event metadata][event_metadata_docs] is sent as\n query parameters on the request, except for the `timestamp` field.\n\n[raw_endpoint_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/RESTREF/RESTinput#services.2Fcollector.2Fraw\n [event_metadata_docs]: https://docs.splunk.com/Documentation/Splunk/latest/Data/FormateventsforHTTPEventCollector#Event_metadata",
          "const": "raw",
          "_metadata": {
            "logical_name": "Raw"
          }
        },
        {
          "title": "Events are sent to the [event endpoint][event_endpoint_docs].",
          "description": "When the event endpoint is used, configured [event metadata][event_metadata_docs] is sent\n directly with each event.\n\n[event_endpoint_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/RESTREF/RESTinput#services.2Fcollector.2Fevent\n [event_metadata_docs]: https://docs.splunk.com/Documentation/Splunk/latest/Data/FormateventsforHTTPEventCollector#Event_metadata",
          "const": "event",
          "_metadata": {
            "logical_name": "Event"
          }
        }
      ]
    },
    "vector::sinks::splunk_hec::metrics::config::HecMetricsSinkConfig": {
      "description": "Configuration of the `splunk_hec_metrics` sink.",
      "type": "object",
      "required": [
        "default_token",
        "endpoint"
      ],
      "properties": {
        "default_namespace": {
          "title": "Sets the default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "type": [
            "string",
            "null"
          ]
        },
        "default_token": {
          "title": "Default Splunk HEC token.",
          "description": "If an event has a token set in its metadata, it will prevail over the one set here.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "sensitive": true
          }
        },
        "endpoint": {
          "description": "The base URL of the Splunk instance.",
          "type": "string"
        },
        "host_key": {
          "title": "Overrides the name of the log field used to grab the hostname to send to Splunk HEC.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "type": "string"
        },
        "index": {
          "title": "The name of the index where to send the events to.",
          "description": "If not specified, the default index is used.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "sourcetype": {
          "title": "The sourcetype of events sent to this sink.",
          "description": "If unset, Splunk will default to `httpevent`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "source": {
          "title": "The source of events sent to this sink.",
          "description": "This is typically the filename the logs originated from.\n\nIf unset, the Splunk collector will set it.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templateable": true
          }
        },
        "compression": {
          "description": "Compression configuration.",
          "default": {
            "algorithm": "none"
          },
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "tls": {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Splunk HEC acknowledgement configuration.",
          "default": {
            "indexer_acknowledgements_enabled": true,
            "query_interval": 10,
            "retry_limit": 30,
            "max_pending_acks": 1000000
          },
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::statsd::StatsdSinkConfig": {
      "description": "Configuration for the `statsd` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "default_namespace": {
              "title": "Sets the default namespace for any metrics sent.",
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\n present, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "type": [
                "string",
                "null"
              ]
            },
            "acknowledgements": {
              "description": "Configuration of acknowledgement behavior.",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
            }
          }
        },
        {
          "description": "Socket mode.",
          "$ref": "#/definitions/vector::sinks::statsd::Mode"
        }
      ],
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::statsd::Mode": {
      "description": "Socket mode.",
      "oneOf": [
        {
          "description": "TCP.",
          "allOf": [
            {
              "description": "A TCP sink.",
              "$ref": "#/definitions/vector::sinks::util::tcp::TcpSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "tcp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Tcp"
          }
        },
        {
          "description": "UDP.",
          "allOf": [
            {
              "description": "UDP configuration.",
              "$ref": "#/definitions/vector::sinks::statsd::StatsdUdpConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "udp"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Udp"
          }
        },
        {
          "description": "Unix Domain Socket.",
          "allOf": [
            {
              "description": "A Unix Domain Socket sink.",
              "$ref": "#/definitions/vector::sinks::util::unix::UnixSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "unix"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Unix"
          }
        }
      ]
    },
    "vector::sinks::statsd::StatsdUdpConfig": {
      "description": "UDP configuration.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::statsd::StatsdDefaultBatchSettings>"
            }
          }
        },
        {
          "description": "A UDP sink.",
          "$ref": "#/definitions/vector::sinks::util::udp::UdpSinkConfig"
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::statsd::StatsdDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestSinkConfig": {
      "description": "Configuration for the `unit_test` sink.",
      "type": "object",
      "required": [
        "test_name",
        "transform_ids"
      ],
      "properties": {
        "test_name": {
          "description": "Name of the test that this sink is being used for.",
          "type": "string"
        },
        "transform_ids": {
          "description": "List of names of the transform/branch associated with this sink.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestStreamSinkConfig": {
      "description": "Configuration for the `unit_test_stream` sink.",
      "type": "object",
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::vector::config::VectorConfig": {
      "description": "Configuration for the `vector` sink.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "version": {
          "description": "Version of the configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::sinks::vector::VectorConfigVersion"
            }
          ]
        },
        "address": {
          "title": "The downstream Vector address to connect to.",
          "description": "The address _must_ include a port.",
          "type": "string"
        },
        "compression": {
          "title": "Whether or not to compress requests.",
          "description": "If set to `true`, requests will be compressed with [`gzip`][gzip_docs].\n\n[gzip_docs]: https://en.wikipedia.org/wiki/Gzip",
          "default": false,
          "type": "boolean"
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeEventBasedDefaultBatchSettings>"
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::sinks::vector::VectorConfigVersion": {
      "description": "Marker type for the version two of the configuration for the `vector` sink.",
      "oneOf": [
        {
          "description": "Marker value for version two.",
          "const": "2",
          "_metadata": {
            "logical_name": "V2"
          }
        }
      ]
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeEventBasedDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that will be processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\n serialized / compressed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "max_events": {
          "description": "The maximum size of a batch, in events, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "timeout_secs": {
          "description": "The maximum age of a batch, in seconds, before it is flushed.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector::sinks::websocket::config::WebSocketSinkConfig": {
      "description": "Configuration for the `websocket` sink.",
      "type": "object",
      "required": [
        "encoding",
        "uri"
      ],
      "properties": {
        "uri": {
          "title": "The WebSocket URI to connect to.",
          "description": "This should include the protocol and host, but can also include the port, path, and any other valid part of a URI.",
          "type": "string"
        },
        "tls": {
          "description": "Configures the TLS options for incoming/outgoing connections.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        },
        "encoding": {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig"
        },
        "ping_interval": {
          "description": "The interval, in seconds, between sending PINGs to the remote peer.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "ping_timeout": {
          "title": "The timeout, in seconds, while waiting for a PONG response from the remote peer.",
          "description": "If a response is not received in this time, the connection is reestablished.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "acknowledgements": {
          "description": "Configuration of acknowledgement behavior.",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig"
        },
        "auth": {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should almost always be used with HTTPS only, as the authentication credentials are passed as an\n HTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of the authentication strategy for HTTP requests.",
              "$ref": "#/definitions/vector::http::Auth"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "sink"
      }
    },
    "vector::config::transform::TransformOuter<alloc::string::String>": {
      "description": "Fully resolved transform component.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "inputs": {
              "description": "Inputs to the transforms.",
              "default": [],
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "Configurable transforms in Vector.",
          "$ref": "#/definitions/vector::transforms::Transforms"
        }
      ]
    },
    "vector::transforms::Transforms": {
      "description": "Configurable transforms in Vector.",
      "oneOf": [
        {
          "description": "Aggregate.",
          "allOf": [
            {
              "description": "Configuration for the `aggregate` transform.",
              "default": {
                "interval_ms": 0
              },
              "$ref": "#/definitions/vector::transforms::aggregate::AggregateConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aggregate"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Aggregate"
          }
        },
        {
          "description": "AWS EC2 metadata.",
          "allOf": [
            {
              "description": "Configuration for the `aws_ec2_metadata` transform.",
              "$ref": "#/definitions/vector::transforms::aws_ec2_metadata::Ec2Metadata",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "aws_ec2_metadata"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "AwsEc2Metadata"
          }
        },
        {
          "description": "Dedupe.",
          "allOf": [
            {
              "description": "Configuration for the `dedupe` transform.",
              "$ref": "#/definitions/vector::transforms::dedupe::DedupeConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "dedupe"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Dedupe"
          }
        },
        {
          "description": "Filter.",
          "allOf": [
            {
              "description": "Configuration for the `filter` transform.",
              "$ref": "#/definitions/vector::transforms::filter::FilterConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "filter"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Filter"
          }
        },
        {
          "description": "GeoIP.",
          "allOf": [
            {
              "description": "Configuration for the `geoip` transform.",
              "$ref": "#/definitions/vector::transforms::geoip::GeoipConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "geoip"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Geoip"
          }
        },
        {
          "description": "Log to metric.",
          "allOf": [
            {
              "description": "Configuration for the `log_to_metric` transform.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::LogToMetricConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "log_to_metric"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "LogToMetric"
          }
        },
        {
          "description": "Lua.",
          "allOf": [
            {
              "description": "Configuration for the `lua` transform.",
              "$ref": "#/definitions/vector::transforms::lua::LuaConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "lua"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Lua"
          }
        },
        {
          "description": "Metric to log.",
          "allOf": [
            {
              "description": "Configuration for the `metric_to_log` transform.",
              "default": {
                "host_tag": null,
                "timezone": null
              },
              "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "metric_to_log"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "MetricToLog"
          }
        },
        {
          "description": "Pipelines. (inner)",
          "allOf": [
            {
              "description": "Configuration for the `pipeline` transform.",
              "$ref": "#/definitions/vector::transforms::pipelines::config::PipelineConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "pipeline"
                }
              }
            }
          ],
          "_metadata": {
            "skip_docs": true,
            "logical_name": "Pipeline"
          }
        },
        {
          "description": "Pipelines.",
          "allOf": [
            {
              "description": "Configuration for the `pipelines` transform.",
              "$ref": "#/definitions/vector::transforms::pipelines::PipelinesConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "pipelines"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Pipelines"
          }
        },
        {
          "description": "Reduce.",
          "allOf": [
            {
              "description": "Configuration for the `reduce` transform.",
              "default": {
                "expire_after_ms": null,
                "flush_period_ms": null,
                "group_by": [],
                "merge_strategies": {},
                "ends_when": null,
                "starts_when": null
              },
              "$ref": "#/definitions/vector::transforms::reduce::ReduceConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "reduce"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Reduce"
          }
        },
        {
          "description": "Remap.",
          "allOf": [
            {
              "description": "Configuration for the `remap` transform.",
              "default": {
                "source": null,
                "file": null,
                "timezone": "local",
                "drop_on_error": false,
                "drop_on_abort": false,
                "reroute_dropped": false,
                "runtime": "ast"
              },
              "$ref": "#/definitions/vector::transforms::remap::RemapConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "remap"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Remap"
          }
        },
        {
          "description": "Route.",
          "allOf": [
            {
              "description": "Configuration for the `route` transform.",
              "$ref": "#/definitions/vector::transforms::route::RouteConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "route"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Route"
          }
        },
        {
          "description": "Sample.",
          "allOf": [
            {
              "description": "Configuration for the `sample` transform.",
              "$ref": "#/definitions/vector::transforms::sample::SampleConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "sample"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Sample"
          }
        },
        {
          "description": "Tag cardinality limit.",
          "allOf": [
            {
              "description": "Configuration for the `tag_cardinality_limit` transform.",
              "$ref": "#/definitions/vector::transforms::tag_cardinality_limit::TagCardinalityLimitConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "tag_cardinality_limit"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "TagCardinalityLimit"
          }
        },
        {
          "description": "Throttle.",
          "allOf": [
            {
              "description": "Configuration for the `throttle` transform.",
              "default": {
                "threshold": 0,
                "window_secs": 0.0,
                "key_field": null,
                "exclude": null
              },
              "$ref": "#/definitions/vector::transforms::throttle::ThrottleConfig",
              "_metadata": {
                "component_type": "transform"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "throttle"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Throttle"
          }
        }
      ]
    },
    "vector::transforms::aggregate::AggregateConfig": {
      "description": "Configuration for the `aggregate` transform.",
      "default": {
        "interval_ms": 0
      },
      "type": "object",
      "properties": {
        "interval_ms": {
          "title": "The interval between flushes, in milliseconds.",
          "description": "Over this period metrics with the same series data (name, namespace, tags, …) will be aggregated.",
          "default": 10000,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::aws_ec2_metadata::Ec2Metadata": {
      "description": "Configuration for the `aws_ec2_metadata` transform.",
      "type": "object",
      "properties": {
        "endpoint": {
          "description": "Overrides the default EC2 metadata endpoint.",
          "type": [
            "string",
            "null"
          ]
        },
        "namespace": {
          "description": "Sets a prefix for all event fields added by the transform.",
          "type": [
            "string",
            "null"
          ]
        },
        "refresh_interval_secs": {
          "description": "The interval between querying for updated metadata, in seconds.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "fields": {
          "description": "A list of metadata fields to include in each transformed event.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "refresh_timeout_secs": {
          "description": "The timeout for querying the EC2 metadata endpoint, in seconds.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "proxy": {
          "title": "Proxy configuration.",
          "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
          "default": {
            "enabled": true,
            "http": null,
            "https": null
          },
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig"
        },
        "required": {
          "description": "Requires the transform to be able to successfully query the EC2 metadata before Vector can start.",
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::dedupe::DedupeConfig": {
      "description": "Configuration for the `dedupe` transform.",
      "type": "object",
      "properties": {
        "fields": {
          "title": "Configuration for controlling what fields to match against.",
          "description": "When no field matching configuration is specified, events are matched using the `timestamp`,\n `host`, and `message` fields from an event. The specific field names used will be those set in\n the global [`log schema`][global_log_schema] configuration.\n\n[global_log_schema]: https://vector.dev/docs/reference/configuration/global-options/#log_schema",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration for controlling what fields to match against.",
              "$ref": "#/definitions/vector::transforms::dedupe::FieldMatchConfig"
            }
          ]
        },
        "cache": {
          "description": "Caching configuration for deduplication.",
          "default": {
            "num_events": 5000
          },
          "$ref": "#/definitions/vector::transforms::dedupe::CacheConfig"
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::dedupe::FieldMatchConfig": {
      "title": "Configuration for controlling what fields to match against.",
      "description": "When no field matching configuration is specified, events are matched using the `timestamp`,\n `host`, and `message` fields from an event. The specific field names used will be those set in\n the global [`log schema`][global_log_schema] configuration.\n\n[global_log_schema]: https://vector.dev/docs/reference/configuration/global-options/#log_schema",
      "oneOf": [
        {
          "description": "Matches events using only the specified fields.",
          "type": "object",
          "required": [
            "match"
          ],
          "properties": {
            "match": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "_metadata": {
            "logical_name": "MatchFields"
          }
        },
        {
          "description": "Matches events using all fields except for the ignored ones.",
          "type": "object",
          "required": [
            "ignore"
          ],
          "properties": {
            "ignore": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "_metadata": {
            "logical_name": "IgnoreFields"
          }
        }
      ]
    },
    "vector::transforms::dedupe::CacheConfig": {
      "description": "Caching configuration for deduplication.",
      "type": "object",
      "required": [
        "num_events"
      ],
      "properties": {
        "num_events": {
          "description": "Number of events to cache and use for comparing incoming events to previously seen events.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 1.0
        }
      }
    },
    "vector::transforms::filter::FilterConfig": {
      "description": "Configuration for the `filter` transform.",
      "type": "object",
      "required": [
        "condition"
      ],
      "properties": {
        "condition": {
          "title": "An event matching condition.",
          "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\n or hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\n directly in configuration by passing the VRL expression as a string:\n\n```toml\n condition = '.message == \"hooray\"'\n ```\n\nWhen other condition types are required, they can specified with an enum-style notation:\n\n```toml\n condition.type = 'check_fields'\n condition.\"message.equals\" = 'hooray'\n ```",
          "$ref": "#/definitions/vector::conditions::AnyCondition"
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::conditions::AnyCondition": {
      "title": "An event matching condition.",
      "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\n or hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\n directly in configuration by passing the VRL expression as a string:\n\n```toml\n condition = '.message == \"hooray\"'\n ```\n\nWhen other condition types are required, they can specified with an enum-style notation:\n\n```toml\n condition.type = 'check_fields'\n condition.\"message.equals\" = 'hooray'\n ```",
      "oneOf": [
        {
          "description": "A [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
          "type": "string",
          "_metadata": {
            "logical_name": "String"
          }
        },
        {
          "description": "A fully-specified condition.",
          "$ref": "#/definitions/vector::conditions::ConditionConfig",
          "_metadata": {
            "logical_name": "Map"
          }
        }
      ]
    },
    "vector::conditions::ConditionConfig": {
      "title": "An event matching condition.",
      "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\n or hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nThey can specified with an enum-style notation:\n\n```toml\n condition.type = 'check_fields'\n condition.\"message.equals\" = 'hooray'\n ```",
      "oneOf": [
        {
          "description": "Matches an event if it is a log.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "const": "is_log"
            }
          },
          "_metadata": {
            "logical_name": "IsLog"
          }
        },
        {
          "description": "Matches an event if it is a metric.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "const": "is_metric"
            }
          },
          "_metadata": {
            "logical_name": "IsMetric"
          }
        },
        {
          "description": "Matches an event if it is a trace.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "const": "is_trace"
            }
          },
          "_metadata": {
            "logical_name": "IsTrace"
          }
        },
        {
          "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
          "allOf": [
            {
              "description": "A condition that uses the [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions) against an event.",
              "$ref": "#/definitions/vector::conditions::vrl::VrlConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "vrl"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Vrl"
          }
        },
        {
          "description": "Matches an event against an arbitrary set of predicate/value combinations.",
          "allOf": [
            {
              "description": "A condition that checks the fields of an event against certain predicates.",
              "$ref": "#/definitions/vector::conditions::check_fields::CheckFieldsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "check_fields"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "CheckFields"
          }
        },
        {
          "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
          "allOf": [
            {
              "description": "A condition that uses the [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query syntax against an event.",
              "$ref": "#/definitions/vector::conditions::datadog_search::DatadogSearchConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "datadog_search"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "DatadogSearch"
          }
        }
      ]
    },
    "vector::conditions::vrl::VrlConfig": {
      "description": "A condition that uses the [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions) against an event.",
      "type": "object",
      "required": [
        "source"
      ],
      "properties": {
        "source": {
          "description": "The VRL boolean expression.",
          "type": "string"
        },
        "runtime": {
          "description": "Available VRL runtimes.",
          "default": "ast",
          "$ref": "#/definitions/vrl_compiler::VrlRuntime"
        }
      }
    },
    "vrl_compiler::VrlRuntime": {
      "description": "Available VRL runtimes.",
      "oneOf": [
        {
          "title": "Tree-walking runtime.",
          "description": "This is the only, and default, runtime.",
          "const": "ast",
          "_metadata": {
            "logical_name": "Ast"
          }
        }
      ]
    },
    "vector::conditions::check_fields::CheckFieldsConfig": {
      "description": "A condition that checks the fields of an event against certain predicates.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "title": "A map of fields, the predicate to use, and the value to match with the predicate.",
          "description": "The key is a compound of the field and the predicate, such as `host.eq`, where `host` is the field to look for\n in the event, and `eq` is the equality predicate, meaning we'll check if the `host` field equals a certain\n value. The value is the operand on the right hand side, such that `\"host.eq\" = \"localhost\"` would check to see\n if the `host` fields equals the string `localhost`.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::conditions::check_fields::CheckFieldsPredicateArg"
          }
        }
      ]
    },
    "vector::conditions::check_fields::CheckFieldsPredicateArg": {
      "description": "Field predicate argument.",
      "oneOf": [
        {
          "description": "A string.",
          "type": "string",
          "_metadata": {
            "logical_name": "String"
          }
        },
        {
          "description": "An array of strings.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "logical_name": "VecString"
          }
        },
        {
          "description": "An integer.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "logical_name": "Integer"
          }
        },
        {
          "description": "A floating-point integer.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "logical_name": "Float"
          }
        },
        {
          "description": "A boolean.",
          "type": "boolean",
          "_metadata": {
            "logical_name": "Boolean"
          }
        }
      ]
    },
    "vector::conditions::datadog_search::DatadogSearchConfig": {
      "description": "A condition that uses the [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query syntax against an event.",
      "type": "object",
      "required": [
        "source"
      ],
      "properties": {
        "source": {
          "description": "The query string.",
          "type": "string"
        }
      }
    },
    "vector::transforms::geoip::GeoipConfig": {
      "description": "Configuration for the `geoip` transform.",
      "type": "object",
      "required": [
        "database",
        "source"
      ],
      "properties": {
        "source": {
          "title": "The field name that contains the IP address.",
          "description": "This field should contain a valid IPv4 or IPv6 address.",
          "type": "string"
        },
        "database": {
          "title": "Path to the [MaxMind GeoIP2][geoip2] or [GeoLite2 binary city database file][geolite2]\n (**GeoLite2-City.mmdb**).",
          "description": "Other databases, such as the country database, are not supported.\n\n[geoip2]: https://dev.maxmind.com/geoip/geoip2/downloadable\n [geolite2]: https://dev.maxmind.com/geoip/geoip2/geolite2/#Download_Access",
          "type": "string"
        },
        "target": {
          "title": "The default field to insert the resulting GeoIP data into.",
          "description": "See output for more info.",
          "default": "geoip",
          "type": "string"
        },
        "locale": {
          "title": "The locale to use when querying the database.",
          "description": "MaxMind includes localized versions of some of the fields within their database, such as\n country name. This setting can control which of those localized versions are returned by the\n transform.\n\nMore information on which portions of the geolocation data are localized, and what languages\n are available, can be found [here][locale_docs].\n\n[locale_docs]: https://support.maxmind.com/hc/en-us/articles/4414877149467-IP-Geolocation-Data#h_01FRRGRYTGZB29ERDBZCX3MR8Q",
          "default": "en",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::log_to_metric::LogToMetricConfig": {
      "description": "Configuration for the `log_to_metric` transform.",
      "type": "object",
      "required": [
        "metrics"
      ],
      "properties": {
        "metrics": {
          "description": "A list of metrics to generate.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector::transforms::log_to_metric::MetricConfig"
          }
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::log_to_metric::MetricConfig": {
      "description": "Specification of a metric derived from a log event.",
      "oneOf": [
        {
          "description": "A counter.",
          "allOf": [
            {
              "description": "Specification of a counter derived from a log event.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::CounterConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "counter"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Counter"
          }
        },
        {
          "description": "A histogram.",
          "allOf": [
            {
              "description": "Specification of a histogram derived from a log event.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::HistogramConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "histogram"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Histogram"
          }
        },
        {
          "description": "A gauge.",
          "allOf": [
            {
              "description": "Specification of a gauge derived from a log event.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::GaugeConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "gauge"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Gauge"
          }
        },
        {
          "description": "A set.",
          "allOf": [
            {
              "description": "Specification of a set derived from a log event.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::SetConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "set"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Set"
          }
        },
        {
          "description": "A summary.",
          "allOf": [
            {
              "description": "Specification of a summary derived from a log event.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::SummaryConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "summary"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Summary"
          }
        }
      ]
    },
    "vector::transforms::log_to_metric::CounterConfig": {
      "description": "Specification of a counter derived from a log event.",
      "type": "object",
      "required": [
        "field"
      ],
      "properties": {
        "field": {
          "description": "Name of the field in the event to generate the counter.",
          "type": "string"
        },
        "name": {
          "title": "Overrides the name of the counter.",
          "description": "If not specified, `field` is used as the name of the counter.",
          "type": [
            "string",
            "null"
          ]
        },
        "namespace": {
          "description": "Sets the namespace for the counter.",
          "type": [
            "string",
            "null"
          ]
        },
        "increment_by_value": {
          "description": "Increments the counter by the value in `field`, instead of only by `1`.",
          "default": false,
          "type": "boolean"
        },
        "kind": {
          "title": "Metric kind.",
          "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\n where the latest absolute value seen is meant to be the actual metric value.  In constrast, and perhaps intuitively,\n incremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\n that we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\n which deals with, and expects, absolute values from clients.",
          "default": "incremental",
          "$ref": "#/definitions/vector_core::event::metric::MetricKind"
        },
        "tags": {
          "description": "Tags to apply to the counter.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector_core::event::metric::MetricKind": {
      "title": "Metric kind.",
      "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\n where the latest absolute value seen is meant to be the actual metric value.  In constrast, and perhaps intuitively,\n incremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\n that we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\n which deals with, and expects, absolute values from clients.",
      "oneOf": [
        {
          "description": "Incremental metric.",
          "const": "incremental",
          "_metadata": {
            "logical_name": "Incremental"
          }
        },
        {
          "description": "Absolute metric.",
          "const": "absolute",
          "_metadata": {
            "logical_name": "Absolute"
          }
        }
      ]
    },
    "vector::transforms::log_to_metric::HistogramConfig": {
      "description": "Specification of a histogram derived from a log event.",
      "type": "object",
      "required": [
        "field"
      ],
      "properties": {
        "field": {
          "description": "Name of the field in the event to generate the histogram from.",
          "type": "string"
        },
        "name": {
          "title": "Overrides the name of the histogram.",
          "description": "If not specified, `field` is used as the name of the histogram.",
          "type": [
            "string",
            "null"
          ]
        },
        "namespace": {
          "description": "Sets the namespace for the histogram.",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "description": "Tags to apply to the histogram.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector::transforms::log_to_metric::GaugeConfig": {
      "description": "Specification of a gauge derived from a log event.",
      "type": "object",
      "required": [
        "field"
      ],
      "properties": {
        "field": {
          "description": "Name of the field in the event to generate the gauge from.",
          "type": "string"
        },
        "name": {
          "title": "Overrides the name of the gauge.",
          "description": "If not specified, `field` is used as the name of the gauge.",
          "type": [
            "string",
            "null"
          ]
        },
        "namespace": {
          "description": "Sets the namespace for the gauge.",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "description": "Tags to apply to the gauge.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector::transforms::log_to_metric::SetConfig": {
      "description": "Specification of a set derived from a log event.",
      "type": "object",
      "required": [
        "field"
      ],
      "properties": {
        "field": {
          "description": "Name of the field in the event to generate the set from.",
          "type": "string"
        },
        "name": {
          "title": "Overrides the name of the set.",
          "description": "If not specified, `field` is used as the name of the set.",
          "type": [
            "string",
            "null"
          ]
        },
        "namespace": {
          "description": "Sets the namespace for the set.",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "description": "Tags to apply to the set.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector::transforms::log_to_metric::SummaryConfig": {
      "description": "Specification of a summary derived from a log event.",
      "type": "object",
      "required": [
        "field"
      ],
      "properties": {
        "field": {
          "description": "Name of the field in the event to generate the summary from.",
          "type": "string"
        },
        "name": {
          "title": "Overrides the name of the summary.",
          "description": "If not specified, `field` is used as the name of the summary.",
          "type": [
            "string",
            "null"
          ]
        },
        "namespace": {
          "description": "Sets the namespace for the summary.",
          "type": [
            "string",
            "null"
          ]
        },
        "tags": {
          "description": "Tags to apply to the summary.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector::transforms::lua::LuaConfig": {
      "description": "Configuration for the `lua` transform.",
      "oneOf": [
        {
          "description": "Configuration for version one.",
          "$ref": "#/definitions/vector::transforms::lua::LuaConfigV1",
          "_metadata": {
            "logical_name": "V1"
          }
        },
        {
          "description": "Configuration for version two.",
          "$ref": "#/definitions/vector::transforms::lua::LuaConfigV2",
          "_metadata": {
            "logical_name": "V2"
          }
        }
      ],
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::lua::LuaConfigV1": {
      "description": "Configuration for the version one of the `lua` transform.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "version": {
              "description": "Version of the configuration.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector::transforms::lua::V1"
                }
              ]
            }
          }
        },
        {
          "description": "Configuration for the version one of the `lua` transform.",
          "$ref": "#/definitions/vector::transforms::lua::v1::LuaConfig"
        }
      ]
    },
    "vector::transforms::lua::V1": {
      "description": "Marker type for the version one of the configuration for the `lua` transform.",
      "oneOf": [
        {
          "description": "Marker value for version one.",
          "const": "1",
          "_metadata": {
            "logical_name": "V1"
          }
        }
      ]
    },
    "vector::transforms::lua::v1::LuaConfig": {
      "description": "Configuration for the version one of the `lua` transform.",
      "type": "object",
      "required": [
        "source"
      ],
      "properties": {
        "source": {
          "description": "The Lua program to execute for each event.",
          "type": "string"
        },
        "search_dirs": {
          "title": "A list of directories to search when loading a Lua file via the `require` function.",
          "description": "If not specified, the modules are looked up in the directories of Vector’s configs.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "vector::transforms::lua::LuaConfigV2": {
      "description": "Configuration for the version two of the `lua` transform.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "version"
          ],
          "properties": {
            "version": {
              "description": "Version of the configuration.",
              "$ref": "#/definitions/vector::transforms::lua::V2"
            }
          }
        },
        {
          "description": "Configuration for the version two of the `lua` transform.",
          "$ref": "#/definitions/vector::transforms::lua::v2::LuaConfig"
        }
      ]
    },
    "vector::transforms::lua::V2": {
      "description": "Marker type for the version two of the configuration for the `lua` transform.",
      "oneOf": [
        {
          "description": "Marker value for version two.",
          "const": "2",
          "_metadata": {
            "logical_name": "V2"
          }
        }
      ]
    },
    "vector::transforms::lua::v2::LuaConfig": {
      "description": "Configuration for the version two of the `lua` transform.",
      "type": "object",
      "required": [
        "hooks"
      ],
      "properties": {
        "source": {
          "title": "The Lua program to initialize the transform with.",
          "description": "The program can be used to to import external dependencies, as well as define the functions\n used for the various lifecycle hooks. However, it's not strictly required, as the lifecycle\n hooks can be configured directly with inline Lua source for each respective hook.",
          "type": [
            "string",
            "null"
          ]
        },
        "search_dirs": {
          "title": "A list of directories to search when loading a Lua file via the `require` function.",
          "description": "If not specified, the modules are looked up in the directories of Vector’s configs.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          }
        },
        "hooks": {
          "title": "Lifecycle hooks.",
          "description": "These hooks can be set to perform additional processing during the lifecycle of the transform.",
          "$ref": "#/definitions/vector::transforms::lua::v2::HooksConfig"
        },
        "timers": {
          "description": "A list of timers which should be configured and executed periodically.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector::transforms::lua::v2::TimerConfig"
          }
        }
      }
    },
    "vector::transforms::lua::v2::HooksConfig": {
      "title": "Lifecycle hooks.",
      "description": "These hooks can be set to perform additional processing during the lifecycle of the transform.",
      "type": "object",
      "required": [
        "process"
      ],
      "properties": {
        "init": {
          "title": "A function which is called when the first event comes, before calling `hooks.process`.",
          "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\n cases, the closure/function takes a single parameter, `emit`, which is a reference to a function for emitting events.",
          "type": [
            "string",
            "null"
          ]
        },
        "process": {
          "title": "A function which is called for each incoming event.",
          "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\n cases, the closure/function takes two parameters. The first parameter, `event`, is the event being processed,\n while the second parameter, `emit`, is a reference to a function for emitting events.",
          "type": "string"
        },
        "shutdown": {
          "title": "A function which is called when Vector is stopped.",
          "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\n cases, the closure/function takes a single parameter, `emit`, which is a reference to a function for emitting events.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector::transforms::lua::v2::TimerConfig": {
      "description": "A Lua timer.",
      "type": "object",
      "required": [
        "handler",
        "interval_seconds"
      ],
      "properties": {
        "interval_seconds": {
          "description": "The interval to execute the handler, in seconds.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "handler": {
          "title": "The handler function which is called when the timer ticks.",
          "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\n cases, the closure/function takes a single parameter, `emit`, which is a reference to a function for emitting events.",
          "type": "string"
        }
      }
    },
    "vector::transforms::pipelines::config::PipelineConfig": {
      "description": "Configuration for the `pipeline` transform.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "description": "The name of the pipeline.",
          "type": "string"
        },
        "filter": {
          "title": "An event matching condition.",
          "description": "A logical condition used to determine if an event should be processed by this pipeline.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "An event matching condition.",
              "$ref": "#/definitions/vector::conditions::AnyCondition"
            }
          ]
        },
        "transforms": {
          "description": "A list of sequential transforms that will process any event that is passed to the pipeline.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector::transforms::Transforms"
          }
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::pipelines::PipelinesConfig": {
      "description": "Configuration for the `pipelines` transform.",
      "type": "object",
      "properties": {
        "logs": {
          "description": "Configuration for the logs-specific side of the pipeline.",
          "default": [],
          "$ref": "#/definitions/vector::transforms::pipelines::config::EventTypeConfig"
        },
        "metrics": {
          "description": "Configuration for the metrics-specific side of the pipeline.",
          "default": [],
          "$ref": "#/definitions/vector::transforms::pipelines::config::EventTypeConfig"
        },
        "traces": {
          "description": "Configuration for the traces-specific side of the pipeline.",
          "default": [],
          "$ref": "#/definitions/vector::transforms::pipelines::config::EventTypeConfig"
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::pipelines::config::EventTypeConfig": {
      "description": "An ordered list of transformations.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/vector::transforms::pipelines::config::PipelineConfig"
      }
    },
    "vector::transforms::reduce::ReduceConfig": {
      "description": "Configuration for the `reduce` transform.",
      "default": {
        "expire_after_ms": null,
        "flush_period_ms": null,
        "group_by": [],
        "merge_strategies": {},
        "ends_when": null,
        "starts_when": null
      },
      "type": "object",
      "properties": {
        "expire_after_ms": {
          "description": "The maximum period of time to wait after the last event is received, in milliseconds, before\n a combined event should be considered complete.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "flush_period_ms": {
          "description": "The interval to check for and flush any expired events, in milliseconds.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "group_by": {
          "title": "An ordered list of fields by which to group events.",
          "description": "Each group with matching values for the specified keys is reduced independently, allowing\n you to keep independent event streams separate. When no fields are specified, all events\n will be combined in a single group.\n\nFor example, if `group_by = [\"host\", \"region\"]`, then all incoming events that have the same\n host and region will be grouped together before being reduced.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "merge_strategies": {
          "title": "A map of field names to custom merge strategies.",
          "description": "For each field specified, the given strategy will be used for combining events rather than\n the default behavior.\n\nThe default behavior is as follows:\n\n- The first value of a string field is kept, subsequent values are discarded.\n - For timestamp fields the first is kept and a new field `[field-name]_end` is added with\n   the last received timestamp value.\n - Numeric values are summed.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::transforms::reduce::merge_strategy::MergeStrategy"
          }
        },
        "ends_when": {
          "title": "A condition used to distinguish the final event of a transaction.",
          "description": "If this condition resolves to `true` for an event, the current transaction is immediately\n flushed with this event.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "An event matching condition.",
              "$ref": "#/definitions/vector::conditions::AnyCondition"
            }
          ]
        },
        "starts_when": {
          "title": "A condition used to distinguish the first event of a transaction.",
          "description": "If this condition resolves to `true` for an event, the previous transaction is flushed\n (without this event) and a new transaction is started.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "An event matching condition.",
              "$ref": "#/definitions/vector::conditions::AnyCondition"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::reduce::merge_strategy::MergeStrategy": {
      "description": "Strategies for merging events.",
      "oneOf": [
        {
          "description": "Discard all but the first value found.",
          "const": "discard",
          "_metadata": {
            "logical_name": "Discard"
          }
        },
        {
          "title": "Discard all but the last value found.",
          "description": "Works as a way to coalesce by not retaining `null`.",
          "const": "retain",
          "_metadata": {
            "logical_name": "Retain"
          }
        },
        {
          "description": "Sum all numeric values.",
          "const": "sum",
          "_metadata": {
            "logical_name": "Sum"
          }
        },
        {
          "description": "Keep the maximum numeric value seen.",
          "const": "max",
          "_metadata": {
            "logical_name": "Max"
          }
        },
        {
          "description": "Keep the minimum numeric value seen.",
          "const": "min",
          "_metadata": {
            "logical_name": "Min"
          }
        },
        {
          "description": "Append each value to an array.",
          "const": "array",
          "_metadata": {
            "logical_name": "Array"
          }
        },
        {
          "description": "Concatenate each string value, delimited with a space.",
          "const": "concat",
          "_metadata": {
            "logical_name": "Concat"
          }
        },
        {
          "description": "Concatenate each string value, delimited with a newline.",
          "const": "concat_newline",
          "_metadata": {
            "logical_name": "ConcatNewline"
          }
        },
        {
          "description": "Concatenate each string, without a delimiter.",
          "const": "concat_raw",
          "_metadata": {
            "logical_name": "ConcatRaw"
          }
        },
        {
          "description": "Keep the shortest array seen.",
          "const": "shortest_array",
          "_metadata": {
            "logical_name": "ShortestArray"
          }
        },
        {
          "description": "Keep the longest array seen.",
          "const": "longest_array",
          "_metadata": {
            "logical_name": "LongestArray"
          }
        },
        {
          "description": "Create a flattened array of all unique values.",
          "const": "flat_unique",
          "_metadata": {
            "logical_name": "FlatUnique"
          }
        }
      ]
    },
    "vector::transforms::remap::RemapConfig": {
      "description": "Configuration for the `remap` transform.",
      "default": {
        "source": null,
        "file": null,
        "timezone": "local",
        "drop_on_error": false,
        "drop_on_abort": false,
        "reroute_dropped": false,
        "runtime": "ast"
      },
      "type": "object",
      "properties": {
        "source": {
          "title": "The [Vector Remap Language][vrl] (VRL) program to execute for each event.",
          "description": "Required if `file` is missing.\n\n[vrl]: https://vector.dev/docs/reference/vrl",
          "type": [
            "string",
            "null"
          ]
        },
        "file": {
          "title": "File path to the [Vector Remap Language][vrl] (VRL) program to execute for each event.",
          "description": "If a relative path is provided, its root is the current working directory.\n\nRequired if `source` is missing.\n\n[vrl]: https://vector.dev/docs/reference/vrl",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/stdlib::PathBuf"
            }
          ]
        },
        "timezone": {
          "title": "The name of the timezone to apply to timestamp conversions that do not contain an explicit\n time zone.",
          "description": "This overrides the [global `timezone`][global_timezone] option. The time zone name may be\n any name in the [TZ database][tz_database], or `local` to indicate system local time.\n\n[global_timezone]: https://vector.dev/docs/reference/configuration//global-options#timezone\n [tz_database]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "default": "local",
          "$ref": "#/definitions/vector_common::datetime::TimeZone"
        },
        "drop_on_error": {
          "title": "Drops any event that encounters an error during processing.",
          "description": "Normally, if a VRL program encounters an error when processing an event, the original,\n unmodified event will be sent downstream. In some cases, you may not wish to send the event\n any further, such as if certain transformation or enrichment is strictly required. Setting\n `drop_on_error` to `true` allows you to ensure these events do not get processed any\n further.\n\nAdditionally, dropped events can potentially be diverted to a specially named output for\n further logging and analysis by setting `reroute_dropped`.",
          "type": "boolean"
        },
        "drop_on_abort": {
          "title": "Drops any event that is manually aborted during processing.",
          "description": "Normally, if a VRL program is manually aborted (via [`abort`][vrl_docs_abort]) when\n processing an event, the original, unmodified event will be sent downstream. In some cases,\n you may not wish to send the event any further, such as if certain transformation or\n enrichment is strictly required. Setting `drop_on_abort` to `true` allows you to ensure\n these events do not get processed any further.\n\nAdditionally, dropped events can potentially be diverted to a specially-named output for\n further logging and analysis by setting `reroute_dropped`.\n\n[vrl_docs_abort]: https://vector.dev/docs/reference/vrl/expressions/#abort",
          "default": true,
          "type": "boolean"
        },
        "reroute_dropped": {
          "title": "Reroutes dropped events to a named output instead of halting processing on them.",
          "description": "When using `drop_on_error` or `drop_on_abort`, events that are \"dropped\" are processed no\n further. In some cases, it may be desirable to keep the events around for further analysis,\n debugging, or retrying.\n\nIn these cases, `reroute_dropped` can be set to `true` which will forward the original event\n to a specially-named output, `dropped`. The original event will be annotated with additional\n fields describing why the event was dropped.",
          "type": "boolean"
        },
        "runtime": {
          "description": "Available VRL runtimes.",
          "default": "ast",
          "$ref": "#/definitions/vrl_compiler::VrlRuntime"
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::route::RouteConfig": {
      "description": "Configuration for the `route` transform.",
      "type": "object",
      "properties": {
        "route": {
          "title": "A table of route identifiers to logical conditions representing the filter of the route.",
          "description": "Each route can then be referenced as an input by other components with the name\n `<transform_name>.<route_id>`. If an event doesn’t match any route, it will be sent to the\n `<transform_name>._unmatched` output.\n\nBoth `_unmatched`, as well as `_default`, are reserved output names and cannot be used as a\n route name.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::conditions::AnyCondition"
          }
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::sample::SampleConfig": {
      "description": "Configuration for the `sample` transform.",
      "type": "object",
      "required": [
        "rate"
      ],
      "properties": {
        "rate": {
          "title": "The rate at which events will be forwarded, expressed as `1/N`.",
          "description": "For example, `rate = 10` means 1 out of every 10 events will be forwarded and the rest will\n be dropped.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        },
        "key_field": {
          "title": "The name of the log field whose value will be hashed to determine if the event should be\n passed.",
          "description": "Consistently samples the same events. Actual rate of sampling may differ from the configured\n one if values in the field are not uniformly distributed. If left unspecified, or if the\n event doesn’t have `key_field`, events will be count rated.",
          "type": [
            "string",
            "null"
          ]
        },
        "exclude": {
          "title": "An event matching condition.",
          "description": "A logical condition used to exclude events from sampling.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "An event matching condition.",
              "$ref": "#/definitions/vector::conditions::AnyCondition"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::tag_cardinality_limit::TagCardinalityLimitConfig": {
      "description": "Configuration for the `tag_cardinality_limit` transform.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "value_limit": {
              "description": "How many distinct values to accept for any given key.",
              "default": 500,
              "type": "number",
              "maximum": 4294967295.0,
              "minimum": 0.0
            },
            "limit_exceeded_action": {
              "description": "Possible actions to take when an event arrives that would exceed the cardinality limit for one\n or more of its tags.",
              "default": "drop_tag",
              "$ref": "#/definitions/vector::transforms::tag_cardinality_limit::LimitExceededAction"
            }
          }
        },
        {
          "description": "Controls the approach taken for tracking tag cardinality.",
          "$ref": "#/definitions/vector::transforms::tag_cardinality_limit::Mode"
        }
      ],
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::transforms::tag_cardinality_limit::LimitExceededAction": {
      "description": "Possible actions to take when an event arrives that would exceed the cardinality limit for one\n or more of its tags.",
      "oneOf": [
        {
          "description": "Drop the tag(s) that would exceed the configured limit.",
          "const": "drop_tag",
          "_metadata": {
            "logical_name": "DropTag"
          }
        },
        {
          "description": "Drop the entire event itself.",
          "const": "drop_event",
          "_metadata": {
            "logical_name": "DropEvent"
          }
        }
      ]
    },
    "vector::transforms::tag_cardinality_limit::Mode": {
      "description": "Controls the approach taken for tracking tag cardinality.",
      "oneOf": [
        {
          "title": "Tracks cardinality exactly.",
          "description": "This mode has higher memory requirements than `probabilistic`, but never falsely outputs\n metrics with new tags after the limit has been hit.",
          "type": "object",
          "required": [
            "mode"
          ],
          "properties": {
            "mode": {
              "const": "exact"
            }
          },
          "_metadata": {
            "logical_name": "Exact"
          }
        },
        {
          "title": "Tracks cardinality probabilistically.",
          "description": "This mode has lower memory requirements than `exact`, but may occasionally allow metric\n events to pass through the transform even when they contain new tags that exceed the\n configured limit. The rate at which this happens can be controlled by changing the value of\n `cache_size_per_tag`.",
          "allOf": [
            {
              "description": "Bloom filter configuration in probabilistic mode.",
              "$ref": "#/definitions/vector::transforms::tag_cardinality_limit::BloomFilterConfig"
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "const": "probabilistic"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Probabilistic"
          }
        }
      ]
    },
    "vector::transforms::tag_cardinality_limit::BloomFilterConfig": {
      "description": "Bloom filter configuration in probabilistic mode.",
      "type": "object",
      "properties": {
        "cache_size_per_key": {
          "title": "The size of the cache for detecting duplicate tags, in bytes.",
          "description": "The larger the cache size, the less likely it is to have a false positive, or a case where\n we allow a new value for tag even after we have reached the configured limits.",
          "default": 5120000,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector::transforms::throttle::ThrottleConfig": {
      "description": "Configuration for the `throttle` transform.",
      "default": {
        "threshold": 0,
        "window_secs": 0.0,
        "key_field": null,
        "exclude": null
      },
      "type": "object",
      "properties": {
        "threshold": {
          "title": "The number of events allowed for a given bucket per configured `window_secs`.",
          "description": "Each unique key will have its own `threshold`.",
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "window_secs": {
          "description": "The time window in which the configured `threshold` is applied, in seconds.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "key_field": {
          "title": "The name of the log field whose value will be hashed to determine if the event should be\n rate limited.",
          "description": "Each unique key will create a bucket of related events to be rate limited separately. If\n left unspecified, or if the event doesn’t have `key_field`, the event be will not be rate\n limited separately.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A templated field.",
              "$ref": "#/definitions/vector::template::Template"
            }
          ],
          "_metadata": {
            "templatable": true
          }
        },
        "exclude": {
          "title": "An event matching condition.",
          "description": "A logical condition used to exclude events from sampling.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "An event matching condition.",
              "$ref": "#/definitions/vector::conditions::AnyCondition"
            }
          ]
        }
      },
      "_metadata": {
        "component_type": "transform"
      }
    },
    "vector::config::TestDefinition<alloc::string::String>": {
      "description": "A unit test definition.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "description": "The name of the unit test.",
          "type": "string"
        },
        "input": {
          "title": "A unit test input.",
          "description": "An input event to test against.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "A unit test input.",
              "$ref": "#/definitions/vector::config::TestInput"
            }
          ]
        },
        "inputs": {
          "description": "A set of input events to test against.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector::config::TestInput"
          }
        },
        "outputs": {
          "description": "A set of expected output events after the test has run.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector::config::TestOutput<alloc::string::String>"
          }
        },
        "no_outputs_from": {
          "description": "A set of component outputs that should not have emitted any events.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "vector::config::TestInput": {
      "title": "A unit test input.",
      "description": "An input describes not only the type of event to insert, but also which transform within the\n configuration to insert it to.",
      "type": "object",
      "required": [
        "insert_at"
      ],
      "properties": {
        "insert_at": {
          "description": "The name of the transform to insert the input event to.",
          "$ref": "#/definitions/vector_common::config::ComponentKey"
        },
        "type": {
          "title": "The type of the input event.",
          "description": "Can be either `raw`, `log`, or `metric.",
          "default": "raw",
          "type": "string"
        },
        "value": {
          "title": "The raw string value to use as the input event.",
          "description": "Use this only when the input event should be a raw event (i.e. unprocessed/undecoded log\n event) and when the input type is set to `raw`.",
          "type": [
            "string",
            "null"
          ]
        },
        "log_fields": {
          "title": "The set of log fields to use when creating a log input event.",
          "description": "Only relevant when `type` is `log`.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::TestInputValue"
          }
        },
        "metric": {
          "title": "The metric to use as an input event.",
          "description": "Only relevant when `type` is `metric`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::event::metric::Metric"
            }
          ]
        }
      }
    },
    "vector::config::TestInputValue": {
      "description": "Value for a log field.",
      "oneOf": [
        {
          "description": "A string.",
          "type": "string",
          "_metadata": {
            "logical_name": "String"
          }
        },
        {
          "description": "An integer.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "logical_name": "Integer"
          }
        },
        {
          "description": "A floating-point number.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "logical_name": "Float"
          }
        },
        {
          "description": "A boolean.",
          "type": "boolean",
          "_metadata": {
            "logical_name": "Boolean"
          }
        }
      ]
    },
    "vector_core::event::metric::Metric": {
      "description": "A metric.",
      "allOf": [
        {
          "type": "object"
        },
        {
          "description": "Metrics series.",
          "$ref": "#/definitions/vector_core::event::metric::series::MetricSeries"
        },
        {
          "description": "Metric data.",
          "$ref": "#/definitions/vector_core::event::metric::data::MetricData"
        }
      ]
    },
    "vector_core::event::metric::series::MetricSeries": {
      "description": "Metrics series.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "tags": {
              "description": "Tags for this metric series.",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "Metric name.",
          "$ref": "#/definitions/vector_core::event::metric::series::MetricName"
        }
      ]
    },
    "vector_core::event::metric::series::MetricName": {
      "description": "Metric name.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "title": "The name of the metric.",
          "description": "This would typically be a name for the metric itself, unrelated to where the metric\n originates from. For example, if the metric represented the amount of used system memory, it\n may be called `memory.used`.",
          "type": "string"
        },
        "namespace": {
          "title": "The namespace of the metric.",
          "description": "Namespace represents a grouping for a metric where the name itself may otherwise be too\n generic. For example, while the name of a metric may be `memory.used` for the amount of used\n system memory, the namespace could differentiate that by being `system` for the total amount\n of used memory across the system, or `vector` for the amount of used system memory specific\n to Vector, and so on.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "vector_core::event::metric::data::MetricData": {
      "description": "Metric data.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "kind"
          ],
          "properties": {
            "kind": {
              "title": "Metric kind.",
              "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\n where the latest absolute value seen is meant to be the actual metric value.  In constrast, and perhaps intuitively,\n incremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\n that we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\n which deals with, and expects, absolute values from clients.",
              "$ref": "#/definitions/vector_core::event::metric::MetricKind"
            }
          }
        },
        {
          "description": "Metric time.",
          "$ref": "#/definitions/vector_core::event::metric::data::MetricTime"
        },
        {
          "description": "Metric value.\n Container for the actual value of a metric.",
          "$ref": "#/definitions/vector_core::event::metric::value::MetricValue"
        }
      ]
    },
    "vector_core::event::metric::data::MetricTime": {
      "description": "Metric time.",
      "type": "object",
      "properties": {
        "timestamp": {
          "title": "The timestamp of when the metric was created.",
          "description": "Metrics may sometimes have no timestamp, or have no meaningful value if the metric is an\n aggregation or transformed heavily enough from its original form such that the original\n timestamp would not represent a meaningful value.",
          "type": [
            "string",
            "null"
          ]
        },
        "interval_ms": {
          "title": "The interval, in milliseconds, of this metric.",
          "description": "Intervals represent the time window over which this metric applies, and is generally only\n used for tracking rates (change over time) on counters.",
          "type": [
            "number",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 1.0
        }
      }
    },
    "vector_core::event::metric::value::MetricValue": {
      "description": "Metric value.\n Container for the actual value of a metric.",
      "oneOf": [
        {
          "description": "A cumulative numerical value that can only increase or be reset to zero.",
          "type": "object",
          "required": [
            "counter"
          ],
          "properties": {
            "counter": {
              "type": "object",
              "required": [
                "value"
              ],
              "properties": {
                "value": {
                  "description": "The value of the counter.",
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "Counter"
          }
        },
        {
          "description": "A single numerical value that can arbitrarily go up and down.",
          "type": "object",
          "required": [
            "gauge"
          ],
          "properties": {
            "gauge": {
              "type": "object",
              "required": [
                "value"
              ],
              "properties": {
                "value": {
                  "description": "The value of the gauge.",
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "Gauge"
          }
        },
        {
          "description": "A set of (unordered) unique values for a key.",
          "type": "object",
          "required": [
            "set"
          ],
          "properties": {
            "set": {
              "type": "object",
              "required": [
                "values"
              ],
              "properties": {
                "values": {
                  "description": "The values in the set.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "Set"
          }
        },
        {
          "description": "A set of observations without any aggregation or sampling.",
          "type": "object",
          "required": [
            "distribution"
          ],
          "properties": {
            "distribution": {
              "type": "object",
              "required": [
                "samples",
                "statistic"
              ],
              "properties": {
                "samples": {
                  "description": "The observed values within this distribution.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/vector_core::event::metric::value::Sample"
                  }
                },
                "statistic": {
                  "description": "The type of statistics to derive for this distribution.",
                  "$ref": "#/definitions/vector_core::event::metric::value::StatisticKind"
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "Distribution"
          }
        },
        {
          "title": "A set of observations which are counted into buckets.",
          "description": "It also contains the total count of all observations and their sum to allow calculating the mean.",
          "type": "object",
          "required": [
            "aggregated_histogram"
          ],
          "properties": {
            "aggregated_histogram": {
              "type": "object",
              "required": [
                "buckets",
                "count",
                "sum"
              ],
              "properties": {
                "buckets": {
                  "description": "The buckets within this histogram.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/vector_core::event::metric::value::Bucket"
                  }
                },
                "count": {
                  "description": "The total number of observations contained within this histogram.",
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0
                },
                "sum": {
                  "description": "The sum of all observations contained within this histogram.",
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "AggregatedHistogram"
          }
        },
        {
          "title": "A set of observations which are represented by quantiles.",
          "description": "Each quantile contains the upper value of the quantile (0 <= φ <= 1). It also contains the total count of all\n observations and their sum to allow calculating the mean.",
          "type": "object",
          "required": [
            "aggregated_summary"
          ],
          "properties": {
            "aggregated_summary": {
              "type": "object",
              "required": [
                "count",
                "quantiles",
                "sum"
              ],
              "properties": {
                "quantiles": {
                  "description": "The quantiles measured from this summary.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/vector_core::event::metric::value::Quantile"
                  }
                },
                "count": {
                  "description": "The total number of observations contained within this summary.",
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0
                },
                "sum": {
                  "description": "The sum of all observations contained within this histogram.",
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "AggregatedSummary"
          }
        },
        {
          "title": "A data structure that can answer questions about the cumulative distribution of the contained samples in\n space-efficient way.",
          "description": "Sketches represent the data in a way that queries over it have bounded error guarantees without needing to hold\n every single sample in memory. They are also, typically, able to be merged with other sketches of the same type\n such that client-side _and_ server-side aggregation can be accomplished without loss of accuracy in the queries.",
          "type": "object",
          "required": [
            "sketch"
          ],
          "properties": {
            "sketch": {
              "type": "object",
              "required": [
                "sketch"
              ],
              "properties": {
                "sketch": {
                  "description": "A generalized metrics sketch.",
                  "$ref": "#/definitions/vector_core::event::metric::value::MetricSketch"
                }
              }
            }
          },
          "_metadata": {
            "logical_name": "Sketch"
          }
        }
      ]
    },
    "vector_core::event::metric::value::Sample": {
      "description": "A single observation.",
      "type": "object",
      "required": [
        "rate",
        "value"
      ],
      "properties": {
        "value": {
          "description": "The value of the observation.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "rate": {
          "description": "The rate at which the value was observed.",
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        }
      }
    },
    "vector_core::event::metric::value::StatisticKind": {
      "description": "Type of statistics to generate for a distribution.",
      "oneOf": [
        {
          "description": "A histogram representation.",
          "const": "histogram",
          "_metadata": {
            "logical_name": "Histogram"
          }
        },
        {
          "description": "Corresponds to Datadog's Distribution Metric\n <https://docs.datadoghq.com/developers/metrics/types/?tab=distribution#definition>",
          "const": "summary",
          "_metadata": {
            "logical_name": "Summary"
          }
        }
      ]
    },
    "vector_core::event::metric::value::Bucket": {
      "title": "A histogram bucket.",
      "description": "Histogram buckets represent the `count` of observations where the value of the observations does\n not exceed the specified `upper_limit`.",
      "type": "object",
      "required": [
        "count",
        "upper_limit"
      ],
      "properties": {
        "upper_limit": {
          "description": "The upper limit of values in the bucket.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "count": {
          "description": "The number of values tracked in this bucket.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      }
    },
    "vector_core::event::metric::value::Quantile": {
      "title": "A single quantile observation.",
      "description": "Quantiles themselves are \"cut points diviing the range of a probability distribution into\n continuous intervals with equal probabilities\". [[1][quantiles_wikipedia]].\n\nWe use quantiles to measure the value along these probability distributions for representing\n client-side aggregations of distributions, which represent a collection of observations over a\n specific time window.\n\nIn general, we typically use the term \"quantile\" to represent the concept of _percentiles_,\n which deal with whole integers -- 0, 1, 2, .., 99, 100 -- even though quantiles are\n floating-point numbers and can represent higher-precision cut points, such as 0.9999, or the\n 99.99th percentile.\n\n[quantile_wikipedia]: https://en.wikipedia.org/wiki/Quantile",
      "type": "object",
      "required": [
        "quantile",
        "value"
      ],
      "properties": {
        "quantile": {
          "title": "The value of the quantile.",
          "description": "This value must be between 0.0 and 1.0, inclusive.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "value": {
          "description": "The estimated value of the given quantile within the probability distribution.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector_core::event::metric::value::MetricSketch": {
      "description": "A generalized metrics sketch.",
      "oneOf": [
        {
          "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
          "description": "While DDSketch has open-source implementations based on the white paper, the version used in\n the Datadog Agent itself is subtly different. This version is suitable for sending directly\n to Datadog's sketch ingest endpoint.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n [ddagent]: https://github.com/DataDog/datadog-agent",
          "type": "object",
          "required": [
            "AgentDDSketch"
          ],
          "properties": {
            "AgentDDSketch": {
              "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
              "description": "This implementation is subtly different from the open-source implementations of `DDSketch`, as\n Datadog made some slight tweaks to configuration values and in-memory layout to optimize it for\n insertion performance within the agent.\n\nWe've mimiced the agent version of `DDSketch` here in order to support a future where we can\n take sketches shipped by the agent, handle them internally, merge them, and so on, without any\n loss of accuracy, eventually forwarding them to Datadog ourselves.\n\nAs such, this implementation is constrained in the same ways: the configuration parameters\n cannot be changed, the collapsing strategy is fixed, and we support a limited number of methods\n for inserting into the sketch.\n\nImportantly, we have a special function, again taken from the agent version, to allow us to\n interpolate histograms, specifically our own aggregated histograms, into a sketch so that we can\n emit useful default quantiles, rather than having to ship the buckets -- upper bound and count\n -- to a downstream system that might have no native way to do the same thing, basically\n providing no value as they have no way to render useful data from them.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n [ddagent]: https://github.com/DataDog/datadog-agent",
              "$ref": "#/definitions/vector_core::metrics::ddsketch::AgentDDSketch"
            }
          },
          "_metadata": {
            "logical_name": "AgentDDSketch"
          }
        }
      ]
    },
    "vector_core::metrics::ddsketch::AgentDDSketch": {
      "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
      "description": "This implementation is subtly different from the open-source implementations of `DDSketch`, as\n Datadog made some slight tweaks to configuration values and in-memory layout to optimize it for\n insertion performance within the agent.\n\nWe've mimiced the agent version of `DDSketch` here in order to support a future where we can\n take sketches shipped by the agent, handle them internally, merge them, and so on, without any\n loss of accuracy, eventually forwarding them to Datadog ourselves.\n\nAs such, this implementation is constrained in the same ways: the configuration parameters\n cannot be changed, the collapsing strategy is fixed, and we support a limited number of methods\n for inserting into the sketch.\n\nImportantly, we have a special function, again taken from the agent version, to allow us to\n interpolate histograms, specifically our own aggregated histograms, into a sketch so that we can\n emit useful default quantiles, rather than having to ship the buckets -- upper bound and count\n -- to a downstream system that might have no native way to do the same thing, basically\n providing no value as they have no way to render useful data from them.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n [ddagent]: https://github.com/DataDog/datadog-agent",
      "type": "object",
      "required": [
        "avg",
        "bins",
        "count",
        "max",
        "min",
        "sum"
      ],
      "properties": {
        "bins": {
          "title": "A split representation of sketch bins.",
          "description": "The bins within the sketch.",
          "$ref": "#/definitions/vector_core::metrics::ddsketch::BinMap"
        },
        "count": {
          "description": "The number of observations within the sketch.",
          "type": "number",
          "maximum": 4294967295.0,
          "minimum": 0.0
        },
        "min": {
          "description": "The minimum value of all observations within the sketch.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "max": {
          "description": "The maximum value of all observations within the sketch.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "sum": {
          "description": "The sum of all observations within the sketch.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        },
        "avg": {
          "description": "The average value of all observations within the sketch.",
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0
        }
      }
    },
    "vector_core::metrics::ddsketch::BinMap": {
      "title": "A split representation of sketch bins.",
      "description": "While internally we depend on a vector of bins, the serialized form used in Protocol Buffers\n splits the bins -- which contain their own key and bin count -- into two separate vectors, one\n for the keys and one for the bin counts.\n\nThis type provides the glue to go from our internal representation to the Protocol\n Buffers-specific representation.",
      "type": "object",
      "required": [
        "k",
        "n"
      ],
      "properties": {
        "k": {
          "description": "The bin keys.",
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 32767.0,
            "minimum": -32768.0
          }
        },
        "n": {
          "description": "The bin counts.",
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 65535.0,
            "minimum": 0.0
          }
        }
      }
    },
    "vector::config::TestOutput<alloc::string::String>": {
      "title": "A unit test output.",
      "description": "An output describes what we expect a transform to emit when fed a certain event, or events, when\n running a unit test.",
      "type": "object",
      "required": [
        "extract_from"
      ],
      "properties": {
        "extract_from": {
          "description": "The transform outputs to extract events from.",
          "$ref": "#/definitions/vector::serde::OneOrMany<alloc::string::String>"
        },
        "conditions": {
          "description": "The conditions to run against the output to validate that they were transformed as expected.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector::conditions::AnyCondition"
          }
        }
      }
    },
    "vector::serde::OneOrMany<alloc::string::String>": {
      "description": "A value which can be (de)serialized from one or many instances of `T`.",
      "oneOf": [
        {
          "type": "string",
          "_metadata": {
            "logical_name": "One"
          }
        },
        {
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "logical_name": "Many"
          }
        }
      ]
    },
    "vector::providers::Providers": {
      "description": "Configurable providers in Vector.",
      "oneOf": [
        {
          "description": "HTTP.",
          "allOf": [
            {
              "description": "Configuration for the `http` provider.",
              "default": {
                "url": null,
                "request": {
                  "headers": {}
                },
                "poll_interval_secs": 30
              },
              "$ref": "#/definitions/vector::providers::http::HttpConfig",
              "_metadata": {
                "component_type": "provider"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "http"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Http"
          }
        }
      ]
    },
    "vector::providers::http::HttpConfig": {
      "description": "Configuration for the `http` provider.",
      "default": {
        "url": null,
        "request": {
          "headers": {}
        },
        "poll_interval_secs": 30
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "url": {
              "description": "URL for the HTTP provider.",
              "type": [
                "string",
                "null"
              ],
              "format": "uri"
            },
            "request": {
              "description": "Request settings.",
              "$ref": "#/definitions/vector::providers::http::RequestConfig"
            },
            "poll_interval_secs": {
              "description": "How often to poll the provider, in seconds.",
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0
            },
            "proxy": {
              "title": "Proxy configuration.",
              "description": "Vector can be configured to proxy traffic through an HTTP(S) proxy when making external requests. Similar to common\n proxy configuration convention, users can set different proxies to use based on the type of traffic being proxied,\n as well as set specific hosts that should not be proxied.",
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig"
            }
          }
        },
        {
          "description": "Standard TLS options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        }
      ],
      "_metadata": {
        "component_type": "provider"
      }
    },
    "vector::providers::http::RequestConfig": {
      "description": "Request settings.",
      "type": "object",
      "properties": {
        "headers": {
          "description": "HTTP headers to add to the request.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "vector::secrets::SecretBackends": {
      "description": "Configurable secret backends in Vector.",
      "oneOf": [
        {
          "description": "Exec.",
          "allOf": [
            {
              "description": "Configuration for the `exec` secrets backend.",
              "$ref": "#/definitions/vector::secrets::exec::ExecBackend",
              "_metadata": {
                "component_type": "secrets"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "exec"
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Exec"
          }
        },
        {
          "description": "Test.",
          "allOf": [
            {
              "description": "Configuration for the `test` secrets backend.",
              "$ref": "#/definitions/vector::secrets::test::TestBackend",
              "_metadata": {
                "component_type": "secrets"
              }
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "const": "test"
                }
              }
            }
          ],
          "_metadata": {
            "hidden": true,
            "logical_name": "Test"
          }
        }
      ]
    },
    "vector::secrets::exec::ExecBackend": {
      "description": "Configuration for the `exec` secrets backend.",
      "type": "object",
      "required": [
        "command"
      ],
      "properties": {
        "command": {
          "title": "Command arguments to execute.",
          "description": "The path to the script or binary must be the first argument.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "timeout": {
          "description": "The timeout, in seconds, to wait for the command to complete.",
          "default": 5,
          "type": "number",
          "maximum": 9007199254740991.0,
          "minimum": 0.0
        }
      },
      "_metadata": {
        "component_type": "secrets"
      }
    },
    "vector::secrets::test::TestBackend": {
      "description": "Configuration for the `test` secrets backend.",
      "type": "object",
      "required": [
        "replacement"
      ],
      "properties": {
        "replacement": {
          "description": "Fixed value to replace all secrets with.",
          "type": "string"
        }
      },
      "_metadata": {
        "component_type": "secrets"
      }
    }
  }
}
